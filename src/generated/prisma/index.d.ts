
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectOverview
 * 
 */
export type ProjectOverview = $Result.DefaultSelection<Prisma.$ProjectOverviewPayload>
/**
 * Model ProjectMetrics
 * 
 */
export type ProjectMetrics = $Result.DefaultSelection<Prisma.$ProjectMetricsPayload>
/**
 * Model TechnicalDetails
 * 
 */
export type TechnicalDetails = $Result.DefaultSelection<Prisma.$TechnicalDetailsPayload>
/**
 * Model Screenshot
 * 
 */
export type Screenshot = $Result.DefaultSelection<Prisma.$ScreenshotPayload>
/**
 * Model Technology
 * 
 */
export type Technology = $Result.DefaultSelection<Prisma.$TechnologyPayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ProjectTag
 * 
 */
export type ProjectTag = $Result.DefaultSelection<Prisma.$ProjectTagPayload>
/**
 * Model Lesson
 * 
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model BusinessOutcome
 * 
 */
export type BusinessOutcome = $Result.DefaultSelection<Prisma.$BusinessOutcomePayload>
/**
 * Model Improvement
 * 
 */
export type Improvement = $Result.DefaultSelection<Prisma.$ImprovementPayload>
/**
 * Model NextStep
 * 
 */
export type NextStep = $Result.DefaultSelection<Prisma.$NextStepPayload>
/**
 * Model FutureTool
 * 
 */
export type FutureTool = $Result.DefaultSelection<Prisma.$FutureToolPayload>
/**
 * Model PerformanceMetric
 * 
 */
export type PerformanceMetric = $Result.DefaultSelection<Prisma.$PerformanceMetricPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model BlogPost
 * 
 */
export type BlogPost = $Result.DefaultSelection<Prisma.$BlogPostPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model Series
 * 
 */
export type Series = $Result.DefaultSelection<Prisma.$SeriesPayload>
/**
 * Model ContentBlock
 * 
 */
export type ContentBlock = $Result.DefaultSelection<Prisma.$ContentBlockPayload>
/**
 * Model BlogTag
 * 
 */
export type BlogTag = $Result.DefaultSelection<Prisma.$BlogTagPayload>
/**
 * Model BlogPostTag
 * 
 */
export type BlogPostTag = $Result.DefaultSelection<Prisma.$BlogPostTagPayload>
/**
 * Model ContactSubmission
 * 
 */
export type ContactSubmission = $Result.DefaultSelection<Prisma.$ContactSubmissionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ProjectStatus: {
  LIVE: 'LIVE',
  IN_PROGRESS: 'IN_PROGRESS',
  ARCHIVED: 'ARCHIVED'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const ContentBlockType: {
  PARAGRAPH: 'PARAGRAPH',
  HEADING: 'HEADING',
  CODE: 'CODE',
  IMAGE: 'IMAGE',
  CALLOUT: 'CALLOUT',
  QUOTE: 'QUOTE',
  LIST: 'LIST',
  VIDEO: 'VIDEO'
};

export type ContentBlockType = (typeof ContentBlockType)[keyof typeof ContentBlockType]


export const CalloutVariant: {
  INFO: 'INFO',
  WARNING: 'WARNING',
  TIP: 'TIP',
  ERROR: 'ERROR'
};

export type CalloutVariant = (typeof CalloutVariant)[keyof typeof CalloutVariant]


export const ListStyle: {
  BULLET: 'BULLET',
  NUMBERED: 'NUMBERED'
};

export type ListStyle = (typeof ListStyle)[keyof typeof ListStyle]


export const VideoType: {
  YOUTUBE: 'YOUTUBE',
  VIMEO: 'VIMEO'
};

export type VideoType = (typeof VideoType)[keyof typeof VideoType]

}

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type ContentBlockType = $Enums.ContentBlockType

export const ContentBlockType: typeof $Enums.ContentBlockType

export type CalloutVariant = $Enums.CalloutVariant

export const CalloutVariant: typeof $Enums.CalloutVariant

export type ListStyle = $Enums.ListStyle

export const ListStyle: typeof $Enums.ListStyle

export type VideoType = $Enums.VideoType

export const VideoType: typeof $Enums.VideoType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Projects
 * const projects = await prisma.project.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Projects
   * const projects = await prisma.project.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectOverview`: Exposes CRUD operations for the **ProjectOverview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectOverviews
    * const projectOverviews = await prisma.projectOverview.findMany()
    * ```
    */
  get projectOverview(): Prisma.ProjectOverviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectMetrics`: Exposes CRUD operations for the **ProjectMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectMetrics
    * const projectMetrics = await prisma.projectMetrics.findMany()
    * ```
    */
  get projectMetrics(): Prisma.ProjectMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technicalDetails`: Exposes CRUD operations for the **TechnicalDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TechnicalDetails
    * const technicalDetails = await prisma.technicalDetails.findMany()
    * ```
    */
  get technicalDetails(): Prisma.TechnicalDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenshot`: Exposes CRUD operations for the **Screenshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Screenshots
    * const screenshots = await prisma.screenshot.findMany()
    * ```
    */
  get screenshot(): Prisma.ScreenshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.technology`: Exposes CRUD operations for the **Technology** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Technologies
    * const technologies = await prisma.technology.findMany()
    * ```
    */
  get technology(): Prisma.TechnologyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectTag`: Exposes CRUD operations for the **ProjectTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectTags
    * const projectTags = await prisma.projectTag.findMany()
    * ```
    */
  get projectTag(): Prisma.ProjectTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.businessOutcome`: Exposes CRUD operations for the **BusinessOutcome** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BusinessOutcomes
    * const businessOutcomes = await prisma.businessOutcome.findMany()
    * ```
    */
  get businessOutcome(): Prisma.BusinessOutcomeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.improvement`: Exposes CRUD operations for the **Improvement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Improvements
    * const improvements = await prisma.improvement.findMany()
    * ```
    */
  get improvement(): Prisma.ImprovementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.nextStep`: Exposes CRUD operations for the **NextStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NextSteps
    * const nextSteps = await prisma.nextStep.findMany()
    * ```
    */
  get nextStep(): Prisma.NextStepDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.futureTool`: Exposes CRUD operations for the **FutureTool** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FutureTools
    * const futureTools = await prisma.futureTool.findMany()
    * ```
    */
  get futureTool(): Prisma.FutureToolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.performanceMetric`: Exposes CRUD operations for the **PerformanceMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PerformanceMetrics
    * const performanceMetrics = await prisma.performanceMetric.findMany()
    * ```
    */
  get performanceMetric(): Prisma.PerformanceMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPost`: Exposes CRUD operations for the **BlogPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPosts
    * const blogPosts = await prisma.blogPost.findMany()
    * ```
    */
  get blogPost(): Prisma.BlogPostDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.series`: Exposes CRUD operations for the **Series** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Series
    * const series = await prisma.series.findMany()
    * ```
    */
  get series(): Prisma.SeriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentBlock`: Exposes CRUD operations for the **ContentBlock** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentBlocks
    * const contentBlocks = await prisma.contentBlock.findMany()
    * ```
    */
  get contentBlock(): Prisma.ContentBlockDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogTag`: Exposes CRUD operations for the **BlogTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogTags
    * const blogTags = await prisma.blogTag.findMany()
    * ```
    */
  get blogTag(): Prisma.BlogTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogPostTag`: Exposes CRUD operations for the **BlogPostTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlogPostTags
    * const blogPostTags = await prisma.blogPostTag.findMany()
    * ```
    */
  get blogPostTag(): Prisma.BlogPostTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contactSubmission`: Exposes CRUD operations for the **ContactSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContactSubmissions
    * const contactSubmissions = await prisma.contactSubmission.findMany()
    * ```
    */
  get contactSubmission(): Prisma.ContactSubmissionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Project: 'Project',
    ProjectOverview: 'ProjectOverview',
    ProjectMetrics: 'ProjectMetrics',
    TechnicalDetails: 'TechnicalDetails',
    Screenshot: 'Screenshot',
    Technology: 'Technology',
    Tag: 'Tag',
    ProjectTag: 'ProjectTag',
    Lesson: 'Lesson',
    BusinessOutcome: 'BusinessOutcome',
    Improvement: 'Improvement',
    NextStep: 'NextStep',
    FutureTool: 'FutureTool',
    PerformanceMetric: 'PerformanceMetric',
    User: 'User',
    BlogPost: 'BlogPost',
    Category: 'Category',
    Series: 'Series',
    ContentBlock: 'ContentBlock',
    BlogTag: 'BlogTag',
    BlogPostTag: 'BlogPostTag',
    ContactSubmission: 'ContactSubmission'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "project" | "projectOverview" | "projectMetrics" | "technicalDetails" | "screenshot" | "technology" | "tag" | "projectTag" | "lesson" | "businessOutcome" | "improvement" | "nextStep" | "futureTool" | "performanceMetric" | "user" | "blogPost" | "category" | "series" | "contentBlock" | "blogTag" | "blogPostTag" | "contactSubmission"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectOverview: {
        payload: Prisma.$ProjectOverviewPayload<ExtArgs>
        fields: Prisma.ProjectOverviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectOverviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectOverviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>
          }
          findFirst: {
            args: Prisma.ProjectOverviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectOverviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>
          }
          findMany: {
            args: Prisma.ProjectOverviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>[]
          }
          create: {
            args: Prisma.ProjectOverviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>
          }
          createMany: {
            args: Prisma.ProjectOverviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectOverviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>[]
          }
          delete: {
            args: Prisma.ProjectOverviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>
          }
          update: {
            args: Prisma.ProjectOverviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>
          }
          deleteMany: {
            args: Prisma.ProjectOverviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectOverviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectOverviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>[]
          }
          upsert: {
            args: Prisma.ProjectOverviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectOverviewPayload>
          }
          aggregate: {
            args: Prisma.ProjectOverviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectOverview>
          }
          groupBy: {
            args: Prisma.ProjectOverviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectOverviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectOverviewCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectOverviewCountAggregateOutputType> | number
          }
        }
      }
      ProjectMetrics: {
        payload: Prisma.$ProjectMetricsPayload<ExtArgs>
        fields: Prisma.ProjectMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>
          }
          findFirst: {
            args: Prisma.ProjectMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>
          }
          findMany: {
            args: Prisma.ProjectMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>[]
          }
          create: {
            args: Prisma.ProjectMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>
          }
          createMany: {
            args: Prisma.ProjectMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectMetricsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>[]
          }
          delete: {
            args: Prisma.ProjectMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>
          }
          update: {
            args: Prisma.ProjectMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>
          }
          deleteMany: {
            args: Prisma.ProjectMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectMetricsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>[]
          }
          upsert: {
            args: Prisma.ProjectMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectMetricsPayload>
          }
          aggregate: {
            args: Prisma.ProjectMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectMetrics>
          }
          groupBy: {
            args: Prisma.ProjectMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectMetricsCountAggregateOutputType> | number
          }
        }
      }
      TechnicalDetails: {
        payload: Prisma.$TechnicalDetailsPayload<ExtArgs>
        fields: Prisma.TechnicalDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnicalDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnicalDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>
          }
          findFirst: {
            args: Prisma.TechnicalDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnicalDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>
          }
          findMany: {
            args: Prisma.TechnicalDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>[]
          }
          create: {
            args: Prisma.TechnicalDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>
          }
          createMany: {
            args: Prisma.TechnicalDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnicalDetailsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>[]
          }
          delete: {
            args: Prisma.TechnicalDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>
          }
          update: {
            args: Prisma.TechnicalDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>
          }
          deleteMany: {
            args: Prisma.TechnicalDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnicalDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnicalDetailsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>[]
          }
          upsert: {
            args: Prisma.TechnicalDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnicalDetailsPayload>
          }
          aggregate: {
            args: Prisma.TechnicalDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnicalDetails>
          }
          groupBy: {
            args: Prisma.TechnicalDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnicalDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnicalDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<TechnicalDetailsCountAggregateOutputType> | number
          }
        }
      }
      Screenshot: {
        payload: Prisma.$ScreenshotPayload<ExtArgs>
        fields: Prisma.ScreenshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScreenshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScreenshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          findFirst: {
            args: Prisma.ScreenshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScreenshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          findMany: {
            args: Prisma.ScreenshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[]
          }
          create: {
            args: Prisma.ScreenshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          createMany: {
            args: Prisma.ScreenshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScreenshotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[]
          }
          delete: {
            args: Prisma.ScreenshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          update: {
            args: Prisma.ScreenshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          deleteMany: {
            args: Prisma.ScreenshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScreenshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScreenshotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>[]
          }
          upsert: {
            args: Prisma.ScreenshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScreenshotPayload>
          }
          aggregate: {
            args: Prisma.ScreenshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenshot>
          }
          groupBy: {
            args: Prisma.ScreenshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScreenshotCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenshotCountAggregateOutputType> | number
          }
        }
      }
      Technology: {
        payload: Prisma.$TechnologyPayload<ExtArgs>
        fields: Prisma.TechnologyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TechnologyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TechnologyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>
          }
          findFirst: {
            args: Prisma.TechnologyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TechnologyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>
          }
          findMany: {
            args: Prisma.TechnologyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>[]
          }
          create: {
            args: Prisma.TechnologyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>
          }
          createMany: {
            args: Prisma.TechnologyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TechnologyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>[]
          }
          delete: {
            args: Prisma.TechnologyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>
          }
          update: {
            args: Prisma.TechnologyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>
          }
          deleteMany: {
            args: Prisma.TechnologyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TechnologyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TechnologyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>[]
          }
          upsert: {
            args: Prisma.TechnologyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TechnologyPayload>
          }
          aggregate: {
            args: Prisma.TechnologyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTechnology>
          }
          groupBy: {
            args: Prisma.TechnologyGroupByArgs<ExtArgs>
            result: $Utils.Optional<TechnologyGroupByOutputType>[]
          }
          count: {
            args: Prisma.TechnologyCountArgs<ExtArgs>
            result: $Utils.Optional<TechnologyCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ProjectTag: {
        payload: Prisma.$ProjectTagPayload<ExtArgs>
        fields: Prisma.ProjectTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>
          }
          findFirst: {
            args: Prisma.ProjectTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>
          }
          findMany: {
            args: Prisma.ProjectTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>[]
          }
          create: {
            args: Prisma.ProjectTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>
          }
          createMany: {
            args: Prisma.ProjectTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>[]
          }
          delete: {
            args: Prisma.ProjectTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>
          }
          update: {
            args: Prisma.ProjectTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>
          }
          deleteMany: {
            args: Prisma.ProjectTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>[]
          }
          upsert: {
            args: Prisma.ProjectTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectTagPayload>
          }
          aggregate: {
            args: Prisma.ProjectTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectTag>
          }
          groupBy: {
            args: Prisma.ProjectTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectTagCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectTagCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      BusinessOutcome: {
        payload: Prisma.$BusinessOutcomePayload<ExtArgs>
        fields: Prisma.BusinessOutcomeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BusinessOutcomeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BusinessOutcomeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>
          }
          findFirst: {
            args: Prisma.BusinessOutcomeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BusinessOutcomeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>
          }
          findMany: {
            args: Prisma.BusinessOutcomeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>[]
          }
          create: {
            args: Prisma.BusinessOutcomeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>
          }
          createMany: {
            args: Prisma.BusinessOutcomeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BusinessOutcomeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>[]
          }
          delete: {
            args: Prisma.BusinessOutcomeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>
          }
          update: {
            args: Prisma.BusinessOutcomeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>
          }
          deleteMany: {
            args: Prisma.BusinessOutcomeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BusinessOutcomeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BusinessOutcomeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>[]
          }
          upsert: {
            args: Prisma.BusinessOutcomeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BusinessOutcomePayload>
          }
          aggregate: {
            args: Prisma.BusinessOutcomeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBusinessOutcome>
          }
          groupBy: {
            args: Prisma.BusinessOutcomeGroupByArgs<ExtArgs>
            result: $Utils.Optional<BusinessOutcomeGroupByOutputType>[]
          }
          count: {
            args: Prisma.BusinessOutcomeCountArgs<ExtArgs>
            result: $Utils.Optional<BusinessOutcomeCountAggregateOutputType> | number
          }
        }
      }
      Improvement: {
        payload: Prisma.$ImprovementPayload<ExtArgs>
        fields: Prisma.ImprovementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImprovementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImprovementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>
          }
          findFirst: {
            args: Prisma.ImprovementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImprovementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>
          }
          findMany: {
            args: Prisma.ImprovementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>[]
          }
          create: {
            args: Prisma.ImprovementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>
          }
          createMany: {
            args: Prisma.ImprovementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImprovementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>[]
          }
          delete: {
            args: Prisma.ImprovementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>
          }
          update: {
            args: Prisma.ImprovementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>
          }
          deleteMany: {
            args: Prisma.ImprovementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImprovementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImprovementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>[]
          }
          upsert: {
            args: Prisma.ImprovementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImprovementPayload>
          }
          aggregate: {
            args: Prisma.ImprovementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImprovement>
          }
          groupBy: {
            args: Prisma.ImprovementGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImprovementGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImprovementCountArgs<ExtArgs>
            result: $Utils.Optional<ImprovementCountAggregateOutputType> | number
          }
        }
      }
      NextStep: {
        payload: Prisma.$NextStepPayload<ExtArgs>
        fields: Prisma.NextStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NextStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NextStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>
          }
          findFirst: {
            args: Prisma.NextStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NextStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>
          }
          findMany: {
            args: Prisma.NextStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>[]
          }
          create: {
            args: Prisma.NextStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>
          }
          createMany: {
            args: Prisma.NextStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NextStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>[]
          }
          delete: {
            args: Prisma.NextStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>
          }
          update: {
            args: Prisma.NextStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>
          }
          deleteMany: {
            args: Prisma.NextStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NextStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NextStepUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>[]
          }
          upsert: {
            args: Prisma.NextStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NextStepPayload>
          }
          aggregate: {
            args: Prisma.NextStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNextStep>
          }
          groupBy: {
            args: Prisma.NextStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<NextStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.NextStepCountArgs<ExtArgs>
            result: $Utils.Optional<NextStepCountAggregateOutputType> | number
          }
        }
      }
      FutureTool: {
        payload: Prisma.$FutureToolPayload<ExtArgs>
        fields: Prisma.FutureToolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FutureToolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FutureToolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>
          }
          findFirst: {
            args: Prisma.FutureToolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FutureToolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>
          }
          findMany: {
            args: Prisma.FutureToolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>[]
          }
          create: {
            args: Prisma.FutureToolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>
          }
          createMany: {
            args: Prisma.FutureToolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FutureToolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>[]
          }
          delete: {
            args: Prisma.FutureToolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>
          }
          update: {
            args: Prisma.FutureToolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>
          }
          deleteMany: {
            args: Prisma.FutureToolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FutureToolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FutureToolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>[]
          }
          upsert: {
            args: Prisma.FutureToolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FutureToolPayload>
          }
          aggregate: {
            args: Prisma.FutureToolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFutureTool>
          }
          groupBy: {
            args: Prisma.FutureToolGroupByArgs<ExtArgs>
            result: $Utils.Optional<FutureToolGroupByOutputType>[]
          }
          count: {
            args: Prisma.FutureToolCountArgs<ExtArgs>
            result: $Utils.Optional<FutureToolCountAggregateOutputType> | number
          }
        }
      }
      PerformanceMetric: {
        payload: Prisma.$PerformanceMetricPayload<ExtArgs>
        fields: Prisma.PerformanceMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PerformanceMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findFirst: {
            args: Prisma.PerformanceMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PerformanceMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          findMany: {
            args: Prisma.PerformanceMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          create: {
            args: Prisma.PerformanceMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          createMany: {
            args: Prisma.PerformanceMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PerformanceMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          delete: {
            args: Prisma.PerformanceMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          update: {
            args: Prisma.PerformanceMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          deleteMany: {
            args: Prisma.PerformanceMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PerformanceMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PerformanceMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>[]
          }
          upsert: {
            args: Prisma.PerformanceMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PerformanceMetricPayload>
          }
          aggregate: {
            args: Prisma.PerformanceMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePerformanceMetric>
          }
          groupBy: {
            args: Prisma.PerformanceMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.PerformanceMetricCountArgs<ExtArgs>
            result: $Utils.Optional<PerformanceMetricCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      BlogPost: {
        payload: Prisma.$BlogPostPayload<ExtArgs>
        fields: Prisma.BlogPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findFirst: {
            args: Prisma.BlogPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          findMany: {
            args: Prisma.BlogPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          create: {
            args: Prisma.BlogPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          createMany: {
            args: Prisma.BlogPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          delete: {
            args: Prisma.BlogPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          update: {
            args: Prisma.BlogPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostPayload>
          }
          aggregate: {
            args: Prisma.BlogPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPost>
          }
          groupBy: {
            args: Prisma.BlogPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      Series: {
        payload: Prisma.$SeriesPayload<ExtArgs>
        fields: Prisma.SeriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SeriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SeriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findFirst: {
            args: Prisma.SeriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SeriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          findMany: {
            args: Prisma.SeriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          create: {
            args: Prisma.SeriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          createMany: {
            args: Prisma.SeriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SeriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          delete: {
            args: Prisma.SeriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          update: {
            args: Prisma.SeriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          deleteMany: {
            args: Prisma.SeriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SeriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SeriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>[]
          }
          upsert: {
            args: Prisma.SeriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SeriesPayload>
          }
          aggregate: {
            args: Prisma.SeriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeries>
          }
          groupBy: {
            args: Prisma.SeriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<SeriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.SeriesCountArgs<ExtArgs>
            result: $Utils.Optional<SeriesCountAggregateOutputType> | number
          }
        }
      }
      ContentBlock: {
        payload: Prisma.$ContentBlockPayload<ExtArgs>
        fields: Prisma.ContentBlockFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentBlockFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentBlockFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          findFirst: {
            args: Prisma.ContentBlockFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentBlockFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          findMany: {
            args: Prisma.ContentBlockFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>[]
          }
          create: {
            args: Prisma.ContentBlockCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          createMany: {
            args: Prisma.ContentBlockCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentBlockCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>[]
          }
          delete: {
            args: Prisma.ContentBlockDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          update: {
            args: Prisma.ContentBlockUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          deleteMany: {
            args: Prisma.ContentBlockDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentBlockUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentBlockUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>[]
          }
          upsert: {
            args: Prisma.ContentBlockUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentBlockPayload>
          }
          aggregate: {
            args: Prisma.ContentBlockAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentBlock>
          }
          groupBy: {
            args: Prisma.ContentBlockGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentBlockGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentBlockCountArgs<ExtArgs>
            result: $Utils.Optional<ContentBlockCountAggregateOutputType> | number
          }
        }
      }
      BlogTag: {
        payload: Prisma.$BlogTagPayload<ExtArgs>
        fields: Prisma.BlogTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findFirst: {
            args: Prisma.BlogTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          findMany: {
            args: Prisma.BlogTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          create: {
            args: Prisma.BlogTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          createMany: {
            args: Prisma.BlogTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          delete: {
            args: Prisma.BlogTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          update: {
            args: Prisma.BlogTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>[]
          }
          upsert: {
            args: Prisma.BlogTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogTagPayload>
          }
          aggregate: {
            args: Prisma.BlogTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogTag>
          }
          groupBy: {
            args: Prisma.BlogTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogTagCountArgs<ExtArgs>
            result: $Utils.Optional<BlogTagCountAggregateOutputType> | number
          }
        }
      }
      BlogPostTag: {
        payload: Prisma.$BlogPostTagPayload<ExtArgs>
        fields: Prisma.BlogPostTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlogPostTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlogPostTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          findFirst: {
            args: Prisma.BlogPostTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlogPostTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          findMany: {
            args: Prisma.BlogPostTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>[]
          }
          create: {
            args: Prisma.BlogPostTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          createMany: {
            args: Prisma.BlogPostTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlogPostTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>[]
          }
          delete: {
            args: Prisma.BlogPostTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          update: {
            args: Prisma.BlogPostTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          deleteMany: {
            args: Prisma.BlogPostTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlogPostTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlogPostTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>[]
          }
          upsert: {
            args: Prisma.BlogPostTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlogPostTagPayload>
          }
          aggregate: {
            args: Prisma.BlogPostTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogPostTag>
          }
          groupBy: {
            args: Prisma.BlogPostTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogPostTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlogPostTagCountArgs<ExtArgs>
            result: $Utils.Optional<BlogPostTagCountAggregateOutputType> | number
          }
        }
      }
      ContactSubmission: {
        payload: Prisma.$ContactSubmissionPayload<ExtArgs>
        fields: Prisma.ContactSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findFirst: {
            args: Prisma.ContactSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          findMany: {
            args: Prisma.ContactSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          create: {
            args: Prisma.ContactSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          createMany: {
            args: Prisma.ContactSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          delete: {
            args: Prisma.ContactSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          update: {
            args: Prisma.ContactSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.ContactSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.ContactSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactSubmissionPayload>
          }
          aggregate: {
            args: Prisma.ContactSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactSubmission>
          }
          groupBy: {
            args: Prisma.ContactSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<ContactSubmissionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    project?: ProjectOmit
    projectOverview?: ProjectOverviewOmit
    projectMetrics?: ProjectMetricsOmit
    technicalDetails?: TechnicalDetailsOmit
    screenshot?: ScreenshotOmit
    technology?: TechnologyOmit
    tag?: TagOmit
    projectTag?: ProjectTagOmit
    lesson?: LessonOmit
    businessOutcome?: BusinessOutcomeOmit
    improvement?: ImprovementOmit
    nextStep?: NextStepOmit
    futureTool?: FutureToolOmit
    performanceMetric?: PerformanceMetricOmit
    user?: UserOmit
    blogPost?: BlogPostOmit
    category?: CategoryOmit
    series?: SeriesOmit
    contentBlock?: ContentBlockOmit
    blogTag?: BlogTagOmit
    blogPostTag?: BlogPostTagOmit
    contactSubmission?: ContactSubmissionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    screenshots: number
    technologies: number
    projectTags: number
    lessons: number
    businessOutcomes: number
    improvements: number
    nextSteps: number
    futureTools: number
    performanceMetrics: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    screenshots?: boolean | ProjectCountOutputTypeCountScreenshotsArgs
    technologies?: boolean | ProjectCountOutputTypeCountTechnologiesArgs
    projectTags?: boolean | ProjectCountOutputTypeCountProjectTagsArgs
    lessons?: boolean | ProjectCountOutputTypeCountLessonsArgs
    businessOutcomes?: boolean | ProjectCountOutputTypeCountBusinessOutcomesArgs
    improvements?: boolean | ProjectCountOutputTypeCountImprovementsArgs
    nextSteps?: boolean | ProjectCountOutputTypeCountNextStepsArgs
    futureTools?: boolean | ProjectCountOutputTypeCountFutureToolsArgs
    performanceMetrics?: boolean | ProjectCountOutputTypeCountPerformanceMetricsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountScreenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenshotWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTechnologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnologyWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountProjectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTagWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountBusinessOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessOutcomeWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountImprovementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImprovementWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountNextStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NextStepWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFutureToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FutureToolWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPerformanceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    projectTags: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectTags?: boolean | TagCountOutputTypeCountProjectTagsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountProjectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTagWhereInput
  }


  /**
   * Count Type BlogPostCountOutputType
   */

  export type BlogPostCountOutputType = {
    contentBlocks: number
    blogPostTags: number
  }

  export type BlogPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentBlocks?: boolean | BlogPostCountOutputTypeCountContentBlocksArgs
    blogPostTags?: boolean | BlogPostCountOutputTypeCountBlogPostTagsArgs
  }

  // Custom InputTypes
  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostCountOutputType
     */
    select?: BlogPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountContentBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentBlockWhereInput
  }

  /**
   * BlogPostCountOutputType without action
   */
  export type BlogPostCountOutputTypeCountBlogPostTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    blogPosts: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | CategoryCountOutputTypeCountBlogPostsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type SeriesCountOutputType
   */

  export type SeriesCountOutputType = {
    blogPosts: number
  }

  export type SeriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | SeriesCountOutputTypeCountBlogPostsArgs
  }

  // Custom InputTypes
  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SeriesCountOutputType
     */
    select?: SeriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SeriesCountOutputType without action
   */
  export type SeriesCountOutputTypeCountBlogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
  }


  /**
   * Count Type BlogTagCountOutputType
   */

  export type BlogTagCountOutputType = {
    blogPostTags: number
  }

  export type BlogTagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPostTags?: boolean | BlogTagCountOutputTypeCountBlogPostTagsArgs
  }

  // Custom InputTypes
  /**
   * BlogTagCountOutputType without action
   */
  export type BlogTagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTagCountOutputType
     */
    select?: BlogTagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BlogTagCountOutputType without action
   */
  export type BlogTagCountOutputTypeCountBlogPostTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    id: number | null
  }

  export type ProjectSumAggregateOutputType = {
    id: number | null
  }

  export type ProjectMinAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    slug: string | null
    status: $Enums.ProjectStatus | null
    heroImage: string | null
    liveDemo: string | null
    github: string | null
    caseStudy: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: number | null
    title: string | null
    subtitle: string | null
    slug: string | null
    status: $Enums.ProjectStatus | null
    heroImage: string | null
    liveDemo: string | null
    github: string | null
    caseStudy: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    title: number
    subtitle: number
    slug: number
    status: number
    heroImage: number
    liveDemo: number
    github: number
    caseStudy: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    id?: true
  }

  export type ProjectSumAggregateInputType = {
    id?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    status?: true
    heroImage?: true
    liveDemo?: true
    github?: true
    caseStudy?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    status?: true
    heroImage?: true
    liveDemo?: true
    github?: true
    caseStudy?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    title?: true
    subtitle?: true
    slug?: true
    status?: true
    heroImage?: true
    liveDemo?: true
    github?: true
    caseStudy?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo: string | null
    github: string | null
    caseStudy: string | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    status?: boolean
    heroImage?: boolean
    liveDemo?: boolean
    github?: boolean
    caseStudy?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    overview?: boolean | Project$overviewArgs<ExtArgs>
    metrics?: boolean | Project$metricsArgs<ExtArgs>
    technicalDetails?: boolean | Project$technicalDetailsArgs<ExtArgs>
    screenshots?: boolean | Project$screenshotsArgs<ExtArgs>
    technologies?: boolean | Project$technologiesArgs<ExtArgs>
    projectTags?: boolean | Project$projectTagsArgs<ExtArgs>
    lessons?: boolean | Project$lessonsArgs<ExtArgs>
    businessOutcomes?: boolean | Project$businessOutcomesArgs<ExtArgs>
    improvements?: boolean | Project$improvementsArgs<ExtArgs>
    nextSteps?: boolean | Project$nextStepsArgs<ExtArgs>
    futureTools?: boolean | Project$futureToolsArgs<ExtArgs>
    performanceMetrics?: boolean | Project$performanceMetricsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    status?: boolean
    heroImage?: boolean
    liveDemo?: boolean
    github?: boolean
    caseStudy?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    status?: boolean
    heroImage?: boolean
    liveDemo?: boolean
    github?: boolean
    caseStudy?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    title?: boolean
    subtitle?: boolean
    slug?: boolean
    status?: boolean
    heroImage?: boolean
    liveDemo?: boolean
    github?: boolean
    caseStudy?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "subtitle" | "slug" | "status" | "heroImage" | "liveDemo" | "github" | "caseStudy" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    overview?: boolean | Project$overviewArgs<ExtArgs>
    metrics?: boolean | Project$metricsArgs<ExtArgs>
    technicalDetails?: boolean | Project$technicalDetailsArgs<ExtArgs>
    screenshots?: boolean | Project$screenshotsArgs<ExtArgs>
    technologies?: boolean | Project$technologiesArgs<ExtArgs>
    projectTags?: boolean | Project$projectTagsArgs<ExtArgs>
    lessons?: boolean | Project$lessonsArgs<ExtArgs>
    businessOutcomes?: boolean | Project$businessOutcomesArgs<ExtArgs>
    improvements?: boolean | Project$improvementsArgs<ExtArgs>
    nextSteps?: boolean | Project$nextStepsArgs<ExtArgs>
    futureTools?: boolean | Project$futureToolsArgs<ExtArgs>
    performanceMetrics?: boolean | Project$performanceMetricsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      overview: Prisma.$ProjectOverviewPayload<ExtArgs> | null
      metrics: Prisma.$ProjectMetricsPayload<ExtArgs> | null
      technicalDetails: Prisma.$TechnicalDetailsPayload<ExtArgs> | null
      screenshots: Prisma.$ScreenshotPayload<ExtArgs>[]
      technologies: Prisma.$TechnologyPayload<ExtArgs>[]
      projectTags: Prisma.$ProjectTagPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      businessOutcomes: Prisma.$BusinessOutcomePayload<ExtArgs>[]
      improvements: Prisma.$ImprovementPayload<ExtArgs>[]
      nextSteps: Prisma.$NextStepPayload<ExtArgs>[]
      futureTools: Prisma.$FutureToolPayload<ExtArgs>[]
      performanceMetrics: Prisma.$PerformanceMetricPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      subtitle: string
      slug: string
      status: $Enums.ProjectStatus
      heroImage: string
      liveDemo: string | null
      github: string | null
      caseStudy: string | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    overview<T extends Project$overviewArgs<ExtArgs> = {}>(args?: Subset<T, Project$overviewArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    metrics<T extends Project$metricsArgs<ExtArgs> = {}>(args?: Subset<T, Project$metricsArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    technicalDetails<T extends Project$technicalDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Project$technicalDetailsArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    screenshots<T extends Project$screenshotsArgs<ExtArgs> = {}>(args?: Subset<T, Project$screenshotsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    technologies<T extends Project$technologiesArgs<ExtArgs> = {}>(args?: Subset<T, Project$technologiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projectTags<T extends Project$projectTagsArgs<ExtArgs> = {}>(args?: Subset<T, Project$projectTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Project$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Project$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    businessOutcomes<T extends Project$businessOutcomesArgs<ExtArgs> = {}>(args?: Subset<T, Project$businessOutcomesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    improvements<T extends Project$improvementsArgs<ExtArgs> = {}>(args?: Subset<T, Project$improvementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    nextSteps<T extends Project$nextStepsArgs<ExtArgs> = {}>(args?: Subset<T, Project$nextStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    futureTools<T extends Project$futureToolsArgs<ExtArgs> = {}>(args?: Subset<T, Project$futureToolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    performanceMetrics<T extends Project$performanceMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Project$performanceMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'Int'>
    readonly title: FieldRef<"Project", 'String'>
    readonly subtitle: FieldRef<"Project", 'String'>
    readonly slug: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly heroImage: FieldRef<"Project", 'String'>
    readonly liveDemo: FieldRef<"Project", 'String'>
    readonly github: FieldRef<"Project", 'String'>
    readonly caseStudy: FieldRef<"Project", 'String'>
    readonly publishedAt: FieldRef<"Project", 'DateTime'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.overview
   */
  export type Project$overviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    where?: ProjectOverviewWhereInput
  }

  /**
   * Project.metrics
   */
  export type Project$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    where?: ProjectMetricsWhereInput
  }

  /**
   * Project.technicalDetails
   */
  export type Project$technicalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    where?: TechnicalDetailsWhereInput
  }

  /**
   * Project.screenshots
   */
  export type Project$screenshotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    where?: ScreenshotWhereInput
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    cursor?: ScreenshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Project.technologies
   */
  export type Project$technologiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    where?: TechnologyWhereInput
    orderBy?: TechnologyOrderByWithRelationInput | TechnologyOrderByWithRelationInput[]
    cursor?: TechnologyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TechnologyScalarFieldEnum | TechnologyScalarFieldEnum[]
  }

  /**
   * Project.projectTags
   */
  export type Project$projectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    where?: ProjectTagWhereInput
    orderBy?: ProjectTagOrderByWithRelationInput | ProjectTagOrderByWithRelationInput[]
    cursor?: ProjectTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTagScalarFieldEnum | ProjectTagScalarFieldEnum[]
  }

  /**
   * Project.lessons
   */
  export type Project$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Project.businessOutcomes
   */
  export type Project$businessOutcomesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    where?: BusinessOutcomeWhereInput
    orderBy?: BusinessOutcomeOrderByWithRelationInput | BusinessOutcomeOrderByWithRelationInput[]
    cursor?: BusinessOutcomeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BusinessOutcomeScalarFieldEnum | BusinessOutcomeScalarFieldEnum[]
  }

  /**
   * Project.improvements
   */
  export type Project$improvementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    where?: ImprovementWhereInput
    orderBy?: ImprovementOrderByWithRelationInput | ImprovementOrderByWithRelationInput[]
    cursor?: ImprovementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImprovementScalarFieldEnum | ImprovementScalarFieldEnum[]
  }

  /**
   * Project.nextSteps
   */
  export type Project$nextStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    where?: NextStepWhereInput
    orderBy?: NextStepOrderByWithRelationInput | NextStepOrderByWithRelationInput[]
    cursor?: NextStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NextStepScalarFieldEnum | NextStepScalarFieldEnum[]
  }

  /**
   * Project.futureTools
   */
  export type Project$futureToolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    where?: FutureToolWhereInput
    orderBy?: FutureToolOrderByWithRelationInput | FutureToolOrderByWithRelationInput[]
    cursor?: FutureToolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FutureToolScalarFieldEnum | FutureToolScalarFieldEnum[]
  }

  /**
   * Project.performanceMetrics
   */
  export type Project$performanceMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    cursor?: PerformanceMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectOverview
   */

  export type AggregateProjectOverview = {
    _count: ProjectOverviewCountAggregateOutputType | null
    _avg: ProjectOverviewAvgAggregateOutputType | null
    _sum: ProjectOverviewSumAggregateOutputType | null
    _min: ProjectOverviewMinAggregateOutputType | null
    _max: ProjectOverviewMaxAggregateOutputType | null
  }

  export type ProjectOverviewAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectOverviewSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectOverviewMinAggregateOutputType = {
    id: number | null
    problem: string | null
    solution: string | null
    role: string | null
    impact: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ProjectOverviewMaxAggregateOutputType = {
    id: number | null
    problem: string | null
    solution: string | null
    role: string | null
    impact: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ProjectOverviewCountAggregateOutputType = {
    id: number
    problem: number
    solution: number
    role: number
    impact: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ProjectOverviewAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectOverviewSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectOverviewMinAggregateInputType = {
    id?: true
    problem?: true
    solution?: true
    role?: true
    impact?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ProjectOverviewMaxAggregateInputType = {
    id?: true
    problem?: true
    solution?: true
    role?: true
    impact?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ProjectOverviewCountAggregateInputType = {
    id?: true
    problem?: true
    solution?: true
    role?: true
    impact?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ProjectOverviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectOverview to aggregate.
     */
    where?: ProjectOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOverviews to fetch.
     */
    orderBy?: ProjectOverviewOrderByWithRelationInput | ProjectOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectOverviews
    **/
    _count?: true | ProjectOverviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectOverviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectOverviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectOverviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectOverviewMaxAggregateInputType
  }

  export type GetProjectOverviewAggregateType<T extends ProjectOverviewAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectOverview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectOverview[P]>
      : GetScalarType<T[P], AggregateProjectOverview[P]>
  }




  export type ProjectOverviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectOverviewWhereInput
    orderBy?: ProjectOverviewOrderByWithAggregationInput | ProjectOverviewOrderByWithAggregationInput[]
    by: ProjectOverviewScalarFieldEnum[] | ProjectOverviewScalarFieldEnum
    having?: ProjectOverviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectOverviewCountAggregateInputType | true
    _avg?: ProjectOverviewAvgAggregateInputType
    _sum?: ProjectOverviewSumAggregateInputType
    _min?: ProjectOverviewMinAggregateInputType
    _max?: ProjectOverviewMaxAggregateInputType
  }

  export type ProjectOverviewGroupByOutputType = {
    id: number
    problem: string
    solution: string
    role: string
    impact: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: ProjectOverviewCountAggregateOutputType | null
    _avg: ProjectOverviewAvgAggregateOutputType | null
    _sum: ProjectOverviewSumAggregateOutputType | null
    _min: ProjectOverviewMinAggregateOutputType | null
    _max: ProjectOverviewMaxAggregateOutputType | null
  }

  type GetProjectOverviewGroupByPayload<T extends ProjectOverviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectOverviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectOverviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectOverviewGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectOverviewGroupByOutputType[P]>
        }
      >
    >


  export type ProjectOverviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    problem?: boolean
    solution?: boolean
    role?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectOverview"]>

  export type ProjectOverviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    problem?: boolean
    solution?: boolean
    role?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectOverview"]>

  export type ProjectOverviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    problem?: boolean
    solution?: boolean
    role?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectOverview"]>

  export type ProjectOverviewSelectScalar = {
    id?: boolean
    problem?: boolean
    solution?: boolean
    role?: boolean
    impact?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ProjectOverviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "problem" | "solution" | "role" | "impact" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["projectOverview"]>
  export type ProjectOverviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectOverviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectOverviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectOverviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectOverview"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      problem: string
      solution: string
      role: string
      impact: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["projectOverview"]>
    composites: {}
  }

  type ProjectOverviewGetPayload<S extends boolean | null | undefined | ProjectOverviewDefaultArgs> = $Result.GetResult<Prisma.$ProjectOverviewPayload, S>

  type ProjectOverviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectOverviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectOverviewCountAggregateInputType | true
    }

  export interface ProjectOverviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectOverview'], meta: { name: 'ProjectOverview' } }
    /**
     * Find zero or one ProjectOverview that matches the filter.
     * @param {ProjectOverviewFindUniqueArgs} args - Arguments to find a ProjectOverview
     * @example
     * // Get one ProjectOverview
     * const projectOverview = await prisma.projectOverview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectOverviewFindUniqueArgs>(args: SelectSubset<T, ProjectOverviewFindUniqueArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectOverview that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectOverviewFindUniqueOrThrowArgs} args - Arguments to find a ProjectOverview
     * @example
     * // Get one ProjectOverview
     * const projectOverview = await prisma.projectOverview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectOverviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectOverviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectOverview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewFindFirstArgs} args - Arguments to find a ProjectOverview
     * @example
     * // Get one ProjectOverview
     * const projectOverview = await prisma.projectOverview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectOverviewFindFirstArgs>(args?: SelectSubset<T, ProjectOverviewFindFirstArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectOverview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewFindFirstOrThrowArgs} args - Arguments to find a ProjectOverview
     * @example
     * // Get one ProjectOverview
     * const projectOverview = await prisma.projectOverview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectOverviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectOverviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectOverviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectOverviews
     * const projectOverviews = await prisma.projectOverview.findMany()
     * 
     * // Get first 10 ProjectOverviews
     * const projectOverviews = await prisma.projectOverview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectOverviewWithIdOnly = await prisma.projectOverview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectOverviewFindManyArgs>(args?: SelectSubset<T, ProjectOverviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectOverview.
     * @param {ProjectOverviewCreateArgs} args - Arguments to create a ProjectOverview.
     * @example
     * // Create one ProjectOverview
     * const ProjectOverview = await prisma.projectOverview.create({
     *   data: {
     *     // ... data to create a ProjectOverview
     *   }
     * })
     * 
     */
    create<T extends ProjectOverviewCreateArgs>(args: SelectSubset<T, ProjectOverviewCreateArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectOverviews.
     * @param {ProjectOverviewCreateManyArgs} args - Arguments to create many ProjectOverviews.
     * @example
     * // Create many ProjectOverviews
     * const projectOverview = await prisma.projectOverview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectOverviewCreateManyArgs>(args?: SelectSubset<T, ProjectOverviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectOverviews and returns the data saved in the database.
     * @param {ProjectOverviewCreateManyAndReturnArgs} args - Arguments to create many ProjectOverviews.
     * @example
     * // Create many ProjectOverviews
     * const projectOverview = await prisma.projectOverview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectOverviews and only return the `id`
     * const projectOverviewWithIdOnly = await prisma.projectOverview.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectOverviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectOverviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectOverview.
     * @param {ProjectOverviewDeleteArgs} args - Arguments to delete one ProjectOverview.
     * @example
     * // Delete one ProjectOverview
     * const ProjectOverview = await prisma.projectOverview.delete({
     *   where: {
     *     // ... filter to delete one ProjectOverview
     *   }
     * })
     * 
     */
    delete<T extends ProjectOverviewDeleteArgs>(args: SelectSubset<T, ProjectOverviewDeleteArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectOverview.
     * @param {ProjectOverviewUpdateArgs} args - Arguments to update one ProjectOverview.
     * @example
     * // Update one ProjectOverview
     * const projectOverview = await prisma.projectOverview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectOverviewUpdateArgs>(args: SelectSubset<T, ProjectOverviewUpdateArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectOverviews.
     * @param {ProjectOverviewDeleteManyArgs} args - Arguments to filter ProjectOverviews to delete.
     * @example
     * // Delete a few ProjectOverviews
     * const { count } = await prisma.projectOverview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectOverviewDeleteManyArgs>(args?: SelectSubset<T, ProjectOverviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectOverviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectOverviews
     * const projectOverview = await prisma.projectOverview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectOverviewUpdateManyArgs>(args: SelectSubset<T, ProjectOverviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectOverviews and returns the data updated in the database.
     * @param {ProjectOverviewUpdateManyAndReturnArgs} args - Arguments to update many ProjectOverviews.
     * @example
     * // Update many ProjectOverviews
     * const projectOverview = await prisma.projectOverview.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectOverviews and only return the `id`
     * const projectOverviewWithIdOnly = await prisma.projectOverview.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectOverviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectOverviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectOverview.
     * @param {ProjectOverviewUpsertArgs} args - Arguments to update or create a ProjectOverview.
     * @example
     * // Update or create a ProjectOverview
     * const projectOverview = await prisma.projectOverview.upsert({
     *   create: {
     *     // ... data to create a ProjectOverview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectOverview we want to update
     *   }
     * })
     */
    upsert<T extends ProjectOverviewUpsertArgs>(args: SelectSubset<T, ProjectOverviewUpsertArgs<ExtArgs>>): Prisma__ProjectOverviewClient<$Result.GetResult<Prisma.$ProjectOverviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectOverviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewCountArgs} args - Arguments to filter ProjectOverviews to count.
     * @example
     * // Count the number of ProjectOverviews
     * const count = await prisma.projectOverview.count({
     *   where: {
     *     // ... the filter for the ProjectOverviews we want to count
     *   }
     * })
    **/
    count<T extends ProjectOverviewCountArgs>(
      args?: Subset<T, ProjectOverviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectOverviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectOverview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectOverviewAggregateArgs>(args: Subset<T, ProjectOverviewAggregateArgs>): Prisma.PrismaPromise<GetProjectOverviewAggregateType<T>>

    /**
     * Group by ProjectOverview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectOverviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectOverviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectOverviewGroupByArgs['orderBy'] }
        : { orderBy?: ProjectOverviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectOverviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectOverviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectOverview model
   */
  readonly fields: ProjectOverviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectOverview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectOverviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectOverview model
   */
  interface ProjectOverviewFieldRefs {
    readonly id: FieldRef<"ProjectOverview", 'Int'>
    readonly problem: FieldRef<"ProjectOverview", 'String'>
    readonly solution: FieldRef<"ProjectOverview", 'String'>
    readonly role: FieldRef<"ProjectOverview", 'String'>
    readonly impact: FieldRef<"ProjectOverview", 'String'>
    readonly createdAt: FieldRef<"ProjectOverview", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectOverview", 'DateTime'>
    readonly projectId: FieldRef<"ProjectOverview", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectOverview findUnique
   */
  export type ProjectOverviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOverview to fetch.
     */
    where: ProjectOverviewWhereUniqueInput
  }

  /**
   * ProjectOverview findUniqueOrThrow
   */
  export type ProjectOverviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOverview to fetch.
     */
    where: ProjectOverviewWhereUniqueInput
  }

  /**
   * ProjectOverview findFirst
   */
  export type ProjectOverviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOverview to fetch.
     */
    where?: ProjectOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOverviews to fetch.
     */
    orderBy?: ProjectOverviewOrderByWithRelationInput | ProjectOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectOverviews.
     */
    cursor?: ProjectOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectOverviews.
     */
    distinct?: ProjectOverviewScalarFieldEnum | ProjectOverviewScalarFieldEnum[]
  }

  /**
   * ProjectOverview findFirstOrThrow
   */
  export type ProjectOverviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOverview to fetch.
     */
    where?: ProjectOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOverviews to fetch.
     */
    orderBy?: ProjectOverviewOrderByWithRelationInput | ProjectOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectOverviews.
     */
    cursor?: ProjectOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOverviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectOverviews.
     */
    distinct?: ProjectOverviewScalarFieldEnum | ProjectOverviewScalarFieldEnum[]
  }

  /**
   * ProjectOverview findMany
   */
  export type ProjectOverviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * Filter, which ProjectOverviews to fetch.
     */
    where?: ProjectOverviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectOverviews to fetch.
     */
    orderBy?: ProjectOverviewOrderByWithRelationInput | ProjectOverviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectOverviews.
     */
    cursor?: ProjectOverviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectOverviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectOverviews.
     */
    skip?: number
    distinct?: ProjectOverviewScalarFieldEnum | ProjectOverviewScalarFieldEnum[]
  }

  /**
   * ProjectOverview create
   */
  export type ProjectOverviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectOverview.
     */
    data: XOR<ProjectOverviewCreateInput, ProjectOverviewUncheckedCreateInput>
  }

  /**
   * ProjectOverview createMany
   */
  export type ProjectOverviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectOverviews.
     */
    data: ProjectOverviewCreateManyInput | ProjectOverviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectOverview createManyAndReturn
   */
  export type ProjectOverviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectOverviews.
     */
    data: ProjectOverviewCreateManyInput | ProjectOverviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectOverview update
   */
  export type ProjectOverviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectOverview.
     */
    data: XOR<ProjectOverviewUpdateInput, ProjectOverviewUncheckedUpdateInput>
    /**
     * Choose, which ProjectOverview to update.
     */
    where: ProjectOverviewWhereUniqueInput
  }

  /**
   * ProjectOverview updateMany
   */
  export type ProjectOverviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectOverviews.
     */
    data: XOR<ProjectOverviewUpdateManyMutationInput, ProjectOverviewUncheckedUpdateManyInput>
    /**
     * Filter which ProjectOverviews to update
     */
    where?: ProjectOverviewWhereInput
    /**
     * Limit how many ProjectOverviews to update.
     */
    limit?: number
  }

  /**
   * ProjectOverview updateManyAndReturn
   */
  export type ProjectOverviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * The data used to update ProjectOverviews.
     */
    data: XOR<ProjectOverviewUpdateManyMutationInput, ProjectOverviewUncheckedUpdateManyInput>
    /**
     * Filter which ProjectOverviews to update
     */
    where?: ProjectOverviewWhereInput
    /**
     * Limit how many ProjectOverviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectOverview upsert
   */
  export type ProjectOverviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectOverview to update in case it exists.
     */
    where: ProjectOverviewWhereUniqueInput
    /**
     * In case the ProjectOverview found by the `where` argument doesn't exist, create a new ProjectOverview with this data.
     */
    create: XOR<ProjectOverviewCreateInput, ProjectOverviewUncheckedCreateInput>
    /**
     * In case the ProjectOverview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectOverviewUpdateInput, ProjectOverviewUncheckedUpdateInput>
  }

  /**
   * ProjectOverview delete
   */
  export type ProjectOverviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
    /**
     * Filter which ProjectOverview to delete.
     */
    where: ProjectOverviewWhereUniqueInput
  }

  /**
   * ProjectOverview deleteMany
   */
  export type ProjectOverviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectOverviews to delete
     */
    where?: ProjectOverviewWhereInput
    /**
     * Limit how many ProjectOverviews to delete.
     */
    limit?: number
  }

  /**
   * ProjectOverview without action
   */
  export type ProjectOverviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectOverview
     */
    select?: ProjectOverviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectOverview
     */
    omit?: ProjectOverviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectOverviewInclude<ExtArgs> | null
  }


  /**
   * Model ProjectMetrics
   */

  export type AggregateProjectMetrics = {
    _count: ProjectMetricsCountAggregateOutputType | null
    _avg: ProjectMetricsAvgAggregateOutputType | null
    _sum: ProjectMetricsSumAggregateOutputType | null
    _min: ProjectMetricsMinAggregateOutputType | null
    _max: ProjectMetricsMaxAggregateOutputType | null
  }

  export type ProjectMetricsAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectMetricsSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ProjectMetricsMinAggregateOutputType = {
    id: number | null
    launchDate: string | null
    duration: string | null
    teamSize: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ProjectMetricsMaxAggregateOutputType = {
    id: number | null
    launchDate: string | null
    duration: string | null
    teamSize: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ProjectMetricsCountAggregateOutputType = {
    id: number
    launchDate: number
    duration: number
    teamSize: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ProjectMetricsAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectMetricsSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ProjectMetricsMinAggregateInputType = {
    id?: true
    launchDate?: true
    duration?: true
    teamSize?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ProjectMetricsMaxAggregateInputType = {
    id?: true
    launchDate?: true
    duration?: true
    teamSize?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ProjectMetricsCountAggregateInputType = {
    id?: true
    launchDate?: true
    duration?: true
    teamSize?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ProjectMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMetrics to aggregate.
     */
    where?: ProjectMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricsOrderByWithRelationInput | ProjectMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectMetrics
    **/
    _count?: true | ProjectMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMetricsMaxAggregateInputType
  }

  export type GetProjectMetricsAggregateType<T extends ProjectMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectMetrics[P]>
      : GetScalarType<T[P], AggregateProjectMetrics[P]>
  }




  export type ProjectMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectMetricsWhereInput
    orderBy?: ProjectMetricsOrderByWithAggregationInput | ProjectMetricsOrderByWithAggregationInput[]
    by: ProjectMetricsScalarFieldEnum[] | ProjectMetricsScalarFieldEnum
    having?: ProjectMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectMetricsCountAggregateInputType | true
    _avg?: ProjectMetricsAvgAggregateInputType
    _sum?: ProjectMetricsSumAggregateInputType
    _min?: ProjectMetricsMinAggregateInputType
    _max?: ProjectMetricsMaxAggregateInputType
  }

  export type ProjectMetricsGroupByOutputType = {
    id: number
    launchDate: string
    duration: string
    teamSize: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: ProjectMetricsCountAggregateOutputType | null
    _avg: ProjectMetricsAvgAggregateOutputType | null
    _sum: ProjectMetricsSumAggregateOutputType | null
    _min: ProjectMetricsMinAggregateOutputType | null
    _max: ProjectMetricsMaxAggregateOutputType | null
  }

  type GetProjectMetricsGroupByPayload<T extends ProjectMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectMetricsGroupByOutputType[P]>
        }
      >
    >


  export type ProjectMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    launchDate?: boolean
    duration?: boolean
    teamSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMetrics"]>

  export type ProjectMetricsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    launchDate?: boolean
    duration?: boolean
    teamSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMetrics"]>

  export type ProjectMetricsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    launchDate?: boolean
    duration?: boolean
    teamSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectMetrics"]>

  export type ProjectMetricsSelectScalar = {
    id?: boolean
    launchDate?: boolean
    duration?: boolean
    teamSize?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ProjectMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "launchDate" | "duration" | "teamSize" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["projectMetrics"]>
  export type ProjectMetricsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectMetricsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ProjectMetricsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ProjectMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectMetrics"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      launchDate: string
      duration: string
      teamSize: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["projectMetrics"]>
    composites: {}
  }

  type ProjectMetricsGetPayload<S extends boolean | null | undefined | ProjectMetricsDefaultArgs> = $Result.GetResult<Prisma.$ProjectMetricsPayload, S>

  type ProjectMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectMetricsCountAggregateInputType | true
    }

  export interface ProjectMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectMetrics'], meta: { name: 'ProjectMetrics' } }
    /**
     * Find zero or one ProjectMetrics that matches the filter.
     * @param {ProjectMetricsFindUniqueArgs} args - Arguments to find a ProjectMetrics
     * @example
     * // Get one ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectMetricsFindUniqueArgs>(args: SelectSubset<T, ProjectMetricsFindUniqueArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectMetricsFindUniqueOrThrowArgs} args - Arguments to find a ProjectMetrics
     * @example
     * // Get one ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsFindFirstArgs} args - Arguments to find a ProjectMetrics
     * @example
     * // Get one ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectMetricsFindFirstArgs>(args?: SelectSubset<T, ProjectMetricsFindFirstArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsFindFirstOrThrowArgs} args - Arguments to find a ProjectMetrics
     * @example
     * // Get one ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.findMany()
     * 
     * // Get first 10 ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectMetricsWithIdOnly = await prisma.projectMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectMetricsFindManyArgs>(args?: SelectSubset<T, ProjectMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectMetrics.
     * @param {ProjectMetricsCreateArgs} args - Arguments to create a ProjectMetrics.
     * @example
     * // Create one ProjectMetrics
     * const ProjectMetrics = await prisma.projectMetrics.create({
     *   data: {
     *     // ... data to create a ProjectMetrics
     *   }
     * })
     * 
     */
    create<T extends ProjectMetricsCreateArgs>(args: SelectSubset<T, ProjectMetricsCreateArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectMetrics.
     * @param {ProjectMetricsCreateManyArgs} args - Arguments to create many ProjectMetrics.
     * @example
     * // Create many ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectMetricsCreateManyArgs>(args?: SelectSubset<T, ProjectMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectMetrics and returns the data saved in the database.
     * @param {ProjectMetricsCreateManyAndReturnArgs} args - Arguments to create many ProjectMetrics.
     * @example
     * // Create many ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectMetrics and only return the `id`
     * const projectMetricsWithIdOnly = await prisma.projectMetrics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectMetricsCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectMetricsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectMetrics.
     * @param {ProjectMetricsDeleteArgs} args - Arguments to delete one ProjectMetrics.
     * @example
     * // Delete one ProjectMetrics
     * const ProjectMetrics = await prisma.projectMetrics.delete({
     *   where: {
     *     // ... filter to delete one ProjectMetrics
     *   }
     * })
     * 
     */
    delete<T extends ProjectMetricsDeleteArgs>(args: SelectSubset<T, ProjectMetricsDeleteArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectMetrics.
     * @param {ProjectMetricsUpdateArgs} args - Arguments to update one ProjectMetrics.
     * @example
     * // Update one ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectMetricsUpdateArgs>(args: SelectSubset<T, ProjectMetricsUpdateArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectMetrics.
     * @param {ProjectMetricsDeleteManyArgs} args - Arguments to filter ProjectMetrics to delete.
     * @example
     * // Delete a few ProjectMetrics
     * const { count } = await prisma.projectMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectMetricsDeleteManyArgs>(args?: SelectSubset<T, ProjectMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectMetricsUpdateManyArgs>(args: SelectSubset<T, ProjectMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectMetrics and returns the data updated in the database.
     * @param {ProjectMetricsUpdateManyAndReturnArgs} args - Arguments to update many ProjectMetrics.
     * @example
     * // Update many ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectMetrics and only return the `id`
     * const projectMetricsWithIdOnly = await prisma.projectMetrics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectMetricsUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectMetricsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectMetrics.
     * @param {ProjectMetricsUpsertArgs} args - Arguments to update or create a ProjectMetrics.
     * @example
     * // Update or create a ProjectMetrics
     * const projectMetrics = await prisma.projectMetrics.upsert({
     *   create: {
     *     // ... data to create a ProjectMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectMetrics we want to update
     *   }
     * })
     */
    upsert<T extends ProjectMetricsUpsertArgs>(args: SelectSubset<T, ProjectMetricsUpsertArgs<ExtArgs>>): Prisma__ProjectMetricsClient<$Result.GetResult<Prisma.$ProjectMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsCountArgs} args - Arguments to filter ProjectMetrics to count.
     * @example
     * // Count the number of ProjectMetrics
     * const count = await prisma.projectMetrics.count({
     *   where: {
     *     // ... the filter for the ProjectMetrics we want to count
     *   }
     * })
    **/
    count<T extends ProjectMetricsCountArgs>(
      args?: Subset<T, ProjectMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectMetricsAggregateArgs>(args: Subset<T, ProjectMetricsAggregateArgs>): Prisma.PrismaPromise<GetProjectMetricsAggregateType<T>>

    /**
     * Group by ProjectMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectMetricsGroupByArgs['orderBy'] }
        : { orderBy?: ProjectMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectMetrics model
   */
  readonly fields: ProjectMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectMetrics model
   */
  interface ProjectMetricsFieldRefs {
    readonly id: FieldRef<"ProjectMetrics", 'Int'>
    readonly launchDate: FieldRef<"ProjectMetrics", 'String'>
    readonly duration: FieldRef<"ProjectMetrics", 'String'>
    readonly teamSize: FieldRef<"ProjectMetrics", 'String'>
    readonly createdAt: FieldRef<"ProjectMetrics", 'DateTime'>
    readonly updatedAt: FieldRef<"ProjectMetrics", 'DateTime'>
    readonly projectId: FieldRef<"ProjectMetrics", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectMetrics findUnique
   */
  export type ProjectMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetrics to fetch.
     */
    where: ProjectMetricsWhereUniqueInput
  }

  /**
   * ProjectMetrics findUniqueOrThrow
   */
  export type ProjectMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetrics to fetch.
     */
    where: ProjectMetricsWhereUniqueInput
  }

  /**
   * ProjectMetrics findFirst
   */
  export type ProjectMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetrics to fetch.
     */
    where?: ProjectMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricsOrderByWithRelationInput | ProjectMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMetrics.
     */
    cursor?: ProjectMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMetrics.
     */
    distinct?: ProjectMetricsScalarFieldEnum | ProjectMetricsScalarFieldEnum[]
  }

  /**
   * ProjectMetrics findFirstOrThrow
   */
  export type ProjectMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetrics to fetch.
     */
    where?: ProjectMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricsOrderByWithRelationInput | ProjectMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectMetrics.
     */
    cursor?: ProjectMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectMetrics.
     */
    distinct?: ProjectMetricsScalarFieldEnum | ProjectMetricsScalarFieldEnum[]
  }

  /**
   * ProjectMetrics findMany
   */
  export type ProjectMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * Filter, which ProjectMetrics to fetch.
     */
    where?: ProjectMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectMetrics to fetch.
     */
    orderBy?: ProjectMetricsOrderByWithRelationInput | ProjectMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectMetrics.
     */
    cursor?: ProjectMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectMetrics.
     */
    skip?: number
    distinct?: ProjectMetricsScalarFieldEnum | ProjectMetricsScalarFieldEnum[]
  }

  /**
   * ProjectMetrics create
   */
  export type ProjectMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectMetrics.
     */
    data: XOR<ProjectMetricsCreateInput, ProjectMetricsUncheckedCreateInput>
  }

  /**
   * ProjectMetrics createMany
   */
  export type ProjectMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectMetrics.
     */
    data: ProjectMetricsCreateManyInput | ProjectMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectMetrics createManyAndReturn
   */
  export type ProjectMetricsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectMetrics.
     */
    data: ProjectMetricsCreateManyInput | ProjectMetricsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMetrics update
   */
  export type ProjectMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectMetrics.
     */
    data: XOR<ProjectMetricsUpdateInput, ProjectMetricsUncheckedUpdateInput>
    /**
     * Choose, which ProjectMetrics to update.
     */
    where: ProjectMetricsWhereUniqueInput
  }

  /**
   * ProjectMetrics updateMany
   */
  export type ProjectMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectMetrics.
     */
    data: XOR<ProjectMetricsUpdateManyMutationInput, ProjectMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMetrics to update
     */
    where?: ProjectMetricsWhereInput
    /**
     * Limit how many ProjectMetrics to update.
     */
    limit?: number
  }

  /**
   * ProjectMetrics updateManyAndReturn
   */
  export type ProjectMetricsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * The data used to update ProjectMetrics.
     */
    data: XOR<ProjectMetricsUpdateManyMutationInput, ProjectMetricsUncheckedUpdateManyInput>
    /**
     * Filter which ProjectMetrics to update
     */
    where?: ProjectMetricsWhereInput
    /**
     * Limit how many ProjectMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectMetrics upsert
   */
  export type ProjectMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectMetrics to update in case it exists.
     */
    where: ProjectMetricsWhereUniqueInput
    /**
     * In case the ProjectMetrics found by the `where` argument doesn't exist, create a new ProjectMetrics with this data.
     */
    create: XOR<ProjectMetricsCreateInput, ProjectMetricsUncheckedCreateInput>
    /**
     * In case the ProjectMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectMetricsUpdateInput, ProjectMetricsUncheckedUpdateInput>
  }

  /**
   * ProjectMetrics delete
   */
  export type ProjectMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
    /**
     * Filter which ProjectMetrics to delete.
     */
    where: ProjectMetricsWhereUniqueInput
  }

  /**
   * ProjectMetrics deleteMany
   */
  export type ProjectMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectMetrics to delete
     */
    where?: ProjectMetricsWhereInput
    /**
     * Limit how many ProjectMetrics to delete.
     */
    limit?: number
  }

  /**
   * ProjectMetrics without action
   */
  export type ProjectMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectMetrics
     */
    select?: ProjectMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectMetrics
     */
    omit?: ProjectMetricsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectMetricsInclude<ExtArgs> | null
  }


  /**
   * Model TechnicalDetails
   */

  export type AggregateTechnicalDetails = {
    _count: TechnicalDetailsCountAggregateOutputType | null
    _avg: TechnicalDetailsAvgAggregateOutputType | null
    _sum: TechnicalDetailsSumAggregateOutputType | null
    _min: TechnicalDetailsMinAggregateOutputType | null
    _max: TechnicalDetailsMaxAggregateOutputType | null
  }

  export type TechnicalDetailsAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TechnicalDetailsSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TechnicalDetailsMinAggregateOutputType = {
    id: number | null
    database: string | null
    api: string | null
    components: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type TechnicalDetailsMaxAggregateOutputType = {
    id: number | null
    database: string | null
    api: string | null
    components: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type TechnicalDetailsCountAggregateOutputType = {
    id: number
    database: number
    api: number
    components: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type TechnicalDetailsAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TechnicalDetailsSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TechnicalDetailsMinAggregateInputType = {
    id?: true
    database?: true
    api?: true
    components?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TechnicalDetailsMaxAggregateInputType = {
    id?: true
    database?: true
    api?: true
    components?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TechnicalDetailsCountAggregateInputType = {
    id?: true
    database?: true
    api?: true
    components?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type TechnicalDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalDetails to aggregate.
     */
    where?: TechnicalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalDetails to fetch.
     */
    orderBy?: TechnicalDetailsOrderByWithRelationInput | TechnicalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnicalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TechnicalDetails
    **/
    _count?: true | TechnicalDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnicalDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnicalDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnicalDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnicalDetailsMaxAggregateInputType
  }

  export type GetTechnicalDetailsAggregateType<T extends TechnicalDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnicalDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnicalDetails[P]>
      : GetScalarType<T[P], AggregateTechnicalDetails[P]>
  }




  export type TechnicalDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnicalDetailsWhereInput
    orderBy?: TechnicalDetailsOrderByWithAggregationInput | TechnicalDetailsOrderByWithAggregationInput[]
    by: TechnicalDetailsScalarFieldEnum[] | TechnicalDetailsScalarFieldEnum
    having?: TechnicalDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnicalDetailsCountAggregateInputType | true
    _avg?: TechnicalDetailsAvgAggregateInputType
    _sum?: TechnicalDetailsSumAggregateInputType
    _min?: TechnicalDetailsMinAggregateInputType
    _max?: TechnicalDetailsMaxAggregateInputType
  }

  export type TechnicalDetailsGroupByOutputType = {
    id: number
    database: string
    api: string
    components: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: TechnicalDetailsCountAggregateOutputType | null
    _avg: TechnicalDetailsAvgAggregateOutputType | null
    _sum: TechnicalDetailsSumAggregateOutputType | null
    _min: TechnicalDetailsMinAggregateOutputType | null
    _max: TechnicalDetailsMaxAggregateOutputType | null
  }

  type GetTechnicalDetailsGroupByPayload<T extends TechnicalDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnicalDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnicalDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnicalDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], TechnicalDetailsGroupByOutputType[P]>
        }
      >
    >


  export type TechnicalDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    database?: boolean
    api?: boolean
    components?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalDetails"]>

  export type TechnicalDetailsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    database?: boolean
    api?: boolean
    components?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalDetails"]>

  export type TechnicalDetailsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    database?: boolean
    api?: boolean
    components?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technicalDetails"]>

  export type TechnicalDetailsSelectScalar = {
    id?: boolean
    database?: boolean
    api?: boolean
    components?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type TechnicalDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "database" | "api" | "components" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["technicalDetails"]>
  export type TechnicalDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TechnicalDetailsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TechnicalDetailsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TechnicalDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TechnicalDetails"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      database: string
      api: string
      components: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["technicalDetails"]>
    composites: {}
  }

  type TechnicalDetailsGetPayload<S extends boolean | null | undefined | TechnicalDetailsDefaultArgs> = $Result.GetResult<Prisma.$TechnicalDetailsPayload, S>

  type TechnicalDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnicalDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnicalDetailsCountAggregateInputType | true
    }

  export interface TechnicalDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TechnicalDetails'], meta: { name: 'TechnicalDetails' } }
    /**
     * Find zero or one TechnicalDetails that matches the filter.
     * @param {TechnicalDetailsFindUniqueArgs} args - Arguments to find a TechnicalDetails
     * @example
     * // Get one TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnicalDetailsFindUniqueArgs>(args: SelectSubset<T, TechnicalDetailsFindUniqueArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TechnicalDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnicalDetailsFindUniqueOrThrowArgs} args - Arguments to find a TechnicalDetails
     * @example
     * // Get one TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnicalDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnicalDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsFindFirstArgs} args - Arguments to find a TechnicalDetails
     * @example
     * // Get one TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnicalDetailsFindFirstArgs>(args?: SelectSubset<T, TechnicalDetailsFindFirstArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TechnicalDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsFindFirstOrThrowArgs} args - Arguments to find a TechnicalDetails
     * @example
     * // Get one TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnicalDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnicalDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TechnicalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.findMany()
     * 
     * // Get first 10 TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technicalDetailsWithIdOnly = await prisma.technicalDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnicalDetailsFindManyArgs>(args?: SelectSubset<T, TechnicalDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TechnicalDetails.
     * @param {TechnicalDetailsCreateArgs} args - Arguments to create a TechnicalDetails.
     * @example
     * // Create one TechnicalDetails
     * const TechnicalDetails = await prisma.technicalDetails.create({
     *   data: {
     *     // ... data to create a TechnicalDetails
     *   }
     * })
     * 
     */
    create<T extends TechnicalDetailsCreateArgs>(args: SelectSubset<T, TechnicalDetailsCreateArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TechnicalDetails.
     * @param {TechnicalDetailsCreateManyArgs} args - Arguments to create many TechnicalDetails.
     * @example
     * // Create many TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnicalDetailsCreateManyArgs>(args?: SelectSubset<T, TechnicalDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TechnicalDetails and returns the data saved in the database.
     * @param {TechnicalDetailsCreateManyAndReturnArgs} args - Arguments to create many TechnicalDetails.
     * @example
     * // Create many TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TechnicalDetails and only return the `id`
     * const technicalDetailsWithIdOnly = await prisma.technicalDetails.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnicalDetailsCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnicalDetailsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TechnicalDetails.
     * @param {TechnicalDetailsDeleteArgs} args - Arguments to delete one TechnicalDetails.
     * @example
     * // Delete one TechnicalDetails
     * const TechnicalDetails = await prisma.technicalDetails.delete({
     *   where: {
     *     // ... filter to delete one TechnicalDetails
     *   }
     * })
     * 
     */
    delete<T extends TechnicalDetailsDeleteArgs>(args: SelectSubset<T, TechnicalDetailsDeleteArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TechnicalDetails.
     * @param {TechnicalDetailsUpdateArgs} args - Arguments to update one TechnicalDetails.
     * @example
     * // Update one TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnicalDetailsUpdateArgs>(args: SelectSubset<T, TechnicalDetailsUpdateArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TechnicalDetails.
     * @param {TechnicalDetailsDeleteManyArgs} args - Arguments to filter TechnicalDetails to delete.
     * @example
     * // Delete a few TechnicalDetails
     * const { count } = await prisma.technicalDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnicalDetailsDeleteManyArgs>(args?: SelectSubset<T, TechnicalDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnicalDetailsUpdateManyArgs>(args: SelectSubset<T, TechnicalDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TechnicalDetails and returns the data updated in the database.
     * @param {TechnicalDetailsUpdateManyAndReturnArgs} args - Arguments to update many TechnicalDetails.
     * @example
     * // Update many TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TechnicalDetails and only return the `id`
     * const technicalDetailsWithIdOnly = await prisma.technicalDetails.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnicalDetailsUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnicalDetailsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TechnicalDetails.
     * @param {TechnicalDetailsUpsertArgs} args - Arguments to update or create a TechnicalDetails.
     * @example
     * // Update or create a TechnicalDetails
     * const technicalDetails = await prisma.technicalDetails.upsert({
     *   create: {
     *     // ... data to create a TechnicalDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TechnicalDetails we want to update
     *   }
     * })
     */
    upsert<T extends TechnicalDetailsUpsertArgs>(args: SelectSubset<T, TechnicalDetailsUpsertArgs<ExtArgs>>): Prisma__TechnicalDetailsClient<$Result.GetResult<Prisma.$TechnicalDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TechnicalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsCountArgs} args - Arguments to filter TechnicalDetails to count.
     * @example
     * // Count the number of TechnicalDetails
     * const count = await prisma.technicalDetails.count({
     *   where: {
     *     // ... the filter for the TechnicalDetails we want to count
     *   }
     * })
    **/
    count<T extends TechnicalDetailsCountArgs>(
      args?: Subset<T, TechnicalDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnicalDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TechnicalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnicalDetailsAggregateArgs>(args: Subset<T, TechnicalDetailsAggregateArgs>): Prisma.PrismaPromise<GetTechnicalDetailsAggregateType<T>>

    /**
     * Group by TechnicalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnicalDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnicalDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnicalDetailsGroupByArgs['orderBy'] }
        : { orderBy?: TechnicalDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnicalDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnicalDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TechnicalDetails model
   */
  readonly fields: TechnicalDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TechnicalDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnicalDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TechnicalDetails model
   */
  interface TechnicalDetailsFieldRefs {
    readonly id: FieldRef<"TechnicalDetails", 'Int'>
    readonly database: FieldRef<"TechnicalDetails", 'String'>
    readonly api: FieldRef<"TechnicalDetails", 'String'>
    readonly components: FieldRef<"TechnicalDetails", 'String'>
    readonly createdAt: FieldRef<"TechnicalDetails", 'DateTime'>
    readonly updatedAt: FieldRef<"TechnicalDetails", 'DateTime'>
    readonly projectId: FieldRef<"TechnicalDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TechnicalDetails findUnique
   */
  export type TechnicalDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalDetails to fetch.
     */
    where: TechnicalDetailsWhereUniqueInput
  }

  /**
   * TechnicalDetails findUniqueOrThrow
   */
  export type TechnicalDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalDetails to fetch.
     */
    where: TechnicalDetailsWhereUniqueInput
  }

  /**
   * TechnicalDetails findFirst
   */
  export type TechnicalDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalDetails to fetch.
     */
    where?: TechnicalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalDetails to fetch.
     */
    orderBy?: TechnicalDetailsOrderByWithRelationInput | TechnicalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalDetails.
     */
    cursor?: TechnicalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalDetails.
     */
    distinct?: TechnicalDetailsScalarFieldEnum | TechnicalDetailsScalarFieldEnum[]
  }

  /**
   * TechnicalDetails findFirstOrThrow
   */
  export type TechnicalDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalDetails to fetch.
     */
    where?: TechnicalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalDetails to fetch.
     */
    orderBy?: TechnicalDetailsOrderByWithRelationInput | TechnicalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TechnicalDetails.
     */
    cursor?: TechnicalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TechnicalDetails.
     */
    distinct?: TechnicalDetailsScalarFieldEnum | TechnicalDetailsScalarFieldEnum[]
  }

  /**
   * TechnicalDetails findMany
   */
  export type TechnicalDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which TechnicalDetails to fetch.
     */
    where?: TechnicalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TechnicalDetails to fetch.
     */
    orderBy?: TechnicalDetailsOrderByWithRelationInput | TechnicalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TechnicalDetails.
     */
    cursor?: TechnicalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TechnicalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TechnicalDetails.
     */
    skip?: number
    distinct?: TechnicalDetailsScalarFieldEnum | TechnicalDetailsScalarFieldEnum[]
  }

  /**
   * TechnicalDetails create
   */
  export type TechnicalDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a TechnicalDetails.
     */
    data: XOR<TechnicalDetailsCreateInput, TechnicalDetailsUncheckedCreateInput>
  }

  /**
   * TechnicalDetails createMany
   */
  export type TechnicalDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TechnicalDetails.
     */
    data: TechnicalDetailsCreateManyInput | TechnicalDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TechnicalDetails createManyAndReturn
   */
  export type TechnicalDetailsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * The data used to create many TechnicalDetails.
     */
    data: TechnicalDetailsCreateManyInput | TechnicalDetailsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalDetails update
   */
  export type TechnicalDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a TechnicalDetails.
     */
    data: XOR<TechnicalDetailsUpdateInput, TechnicalDetailsUncheckedUpdateInput>
    /**
     * Choose, which TechnicalDetails to update.
     */
    where: TechnicalDetailsWhereUniqueInput
  }

  /**
   * TechnicalDetails updateMany
   */
  export type TechnicalDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TechnicalDetails.
     */
    data: XOR<TechnicalDetailsUpdateManyMutationInput, TechnicalDetailsUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalDetails to update
     */
    where?: TechnicalDetailsWhereInput
    /**
     * Limit how many TechnicalDetails to update.
     */
    limit?: number
  }

  /**
   * TechnicalDetails updateManyAndReturn
   */
  export type TechnicalDetailsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * The data used to update TechnicalDetails.
     */
    data: XOR<TechnicalDetailsUpdateManyMutationInput, TechnicalDetailsUncheckedUpdateManyInput>
    /**
     * Filter which TechnicalDetails to update
     */
    where?: TechnicalDetailsWhereInput
    /**
     * Limit how many TechnicalDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TechnicalDetails upsert
   */
  export type TechnicalDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the TechnicalDetails to update in case it exists.
     */
    where: TechnicalDetailsWhereUniqueInput
    /**
     * In case the TechnicalDetails found by the `where` argument doesn't exist, create a new TechnicalDetails with this data.
     */
    create: XOR<TechnicalDetailsCreateInput, TechnicalDetailsUncheckedCreateInput>
    /**
     * In case the TechnicalDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnicalDetailsUpdateInput, TechnicalDetailsUncheckedUpdateInput>
  }

  /**
   * TechnicalDetails delete
   */
  export type TechnicalDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
    /**
     * Filter which TechnicalDetails to delete.
     */
    where: TechnicalDetailsWhereUniqueInput
  }

  /**
   * TechnicalDetails deleteMany
   */
  export type TechnicalDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TechnicalDetails to delete
     */
    where?: TechnicalDetailsWhereInput
    /**
     * Limit how many TechnicalDetails to delete.
     */
    limit?: number
  }

  /**
   * TechnicalDetails without action
   */
  export type TechnicalDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TechnicalDetails
     */
    select?: TechnicalDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TechnicalDetails
     */
    omit?: TechnicalDetailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnicalDetailsInclude<ExtArgs> | null
  }


  /**
   * Model Screenshot
   */

  export type AggregateScreenshot = {
    _count: ScreenshotCountAggregateOutputType | null
    _avg: ScreenshotAvgAggregateOutputType | null
    _sum: ScreenshotSumAggregateOutputType | null
    _min: ScreenshotMinAggregateOutputType | null
    _max: ScreenshotMaxAggregateOutputType | null
  }

  export type ScreenshotAvgAggregateOutputType = {
    id: number | null
    order: number | null
    projectId: number | null
  }

  export type ScreenshotSumAggregateOutputType = {
    id: number | null
    order: number | null
    projectId: number | null
  }

  export type ScreenshotMinAggregateOutputType = {
    id: number | null
    url: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ScreenshotMaxAggregateOutputType = {
    id: number | null
    url: string | null
    description: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ScreenshotCountAggregateOutputType = {
    id: number
    url: number
    description: number
    order: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ScreenshotAvgAggregateInputType = {
    id?: true
    order?: true
    projectId?: true
  }

  export type ScreenshotSumAggregateInputType = {
    id?: true
    order?: true
    projectId?: true
  }

  export type ScreenshotMinAggregateInputType = {
    id?: true
    url?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ScreenshotMaxAggregateInputType = {
    id?: true
    url?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ScreenshotCountAggregateInputType = {
    id?: true
    url?: true
    description?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ScreenshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Screenshot to aggregate.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Screenshots
    **/
    _count?: true | ScreenshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScreenshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScreenshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenshotMaxAggregateInputType
  }

  export type GetScreenshotAggregateType<T extends ScreenshotAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenshot[P]>
      : GetScalarType<T[P], AggregateScreenshot[P]>
  }




  export type ScreenshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScreenshotWhereInput
    orderBy?: ScreenshotOrderByWithAggregationInput | ScreenshotOrderByWithAggregationInput[]
    by: ScreenshotScalarFieldEnum[] | ScreenshotScalarFieldEnum
    having?: ScreenshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenshotCountAggregateInputType | true
    _avg?: ScreenshotAvgAggregateInputType
    _sum?: ScreenshotSumAggregateInputType
    _min?: ScreenshotMinAggregateInputType
    _max?: ScreenshotMaxAggregateInputType
  }

  export type ScreenshotGroupByOutputType = {
    id: number
    url: string
    description: string
    order: number
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: ScreenshotCountAggregateOutputType | null
    _avg: ScreenshotAvgAggregateOutputType | null
    _sum: ScreenshotSumAggregateOutputType | null
    _min: ScreenshotMinAggregateOutputType | null
    _max: ScreenshotMaxAggregateOutputType | null
  }

  type GetScreenshotGroupByPayload<T extends ScreenshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
        }
      >
    >


  export type ScreenshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenshot"]>

  export type ScreenshotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenshot"]>

  export type ScreenshotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    url?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["screenshot"]>

  export type ScreenshotSelectScalar = {
    id?: boolean
    url?: boolean
    description?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ScreenshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "url" | "description" | "order" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["screenshot"]>
  export type ScreenshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ScreenshotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ScreenshotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ScreenshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Screenshot"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      url: string
      description: string
      order: number
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["screenshot"]>
    composites: {}
  }

  type ScreenshotGetPayload<S extends boolean | null | undefined | ScreenshotDefaultArgs> = $Result.GetResult<Prisma.$ScreenshotPayload, S>

  type ScreenshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScreenshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenshotCountAggregateInputType | true
    }

  export interface ScreenshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Screenshot'], meta: { name: 'Screenshot' } }
    /**
     * Find zero or one Screenshot that matches the filter.
     * @param {ScreenshotFindUniqueArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScreenshotFindUniqueArgs>(args: SelectSubset<T, ScreenshotFindUniqueArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Screenshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScreenshotFindUniqueOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScreenshotFindUniqueOrThrowArgs>(args: SelectSubset<T, ScreenshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Screenshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindFirstArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScreenshotFindFirstArgs>(args?: SelectSubset<T, ScreenshotFindFirstArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Screenshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindFirstOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScreenshotFindFirstOrThrowArgs>(args?: SelectSubset<T, ScreenshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Screenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Screenshots
     * const screenshots = await prisma.screenshot.findMany()
     * 
     * // Get first 10 Screenshots
     * const screenshots = await prisma.screenshot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScreenshotFindManyArgs>(args?: SelectSubset<T, ScreenshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Screenshot.
     * @param {ScreenshotCreateArgs} args - Arguments to create a Screenshot.
     * @example
     * // Create one Screenshot
     * const Screenshot = await prisma.screenshot.create({
     *   data: {
     *     // ... data to create a Screenshot
     *   }
     * })
     * 
     */
    create<T extends ScreenshotCreateArgs>(args: SelectSubset<T, ScreenshotCreateArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Screenshots.
     * @param {ScreenshotCreateManyArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScreenshotCreateManyArgs>(args?: SelectSubset<T, ScreenshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Screenshots and returns the data saved in the database.
     * @param {ScreenshotCreateManyAndReturnArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Screenshots and only return the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScreenshotCreateManyAndReturnArgs>(args?: SelectSubset<T, ScreenshotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Screenshot.
     * @param {ScreenshotDeleteArgs} args - Arguments to delete one Screenshot.
     * @example
     * // Delete one Screenshot
     * const Screenshot = await prisma.screenshot.delete({
     *   where: {
     *     // ... filter to delete one Screenshot
     *   }
     * })
     * 
     */
    delete<T extends ScreenshotDeleteArgs>(args: SelectSubset<T, ScreenshotDeleteArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Screenshot.
     * @param {ScreenshotUpdateArgs} args - Arguments to update one Screenshot.
     * @example
     * // Update one Screenshot
     * const screenshot = await prisma.screenshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScreenshotUpdateArgs>(args: SelectSubset<T, ScreenshotUpdateArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Screenshots.
     * @param {ScreenshotDeleteManyArgs} args - Arguments to filter Screenshots to delete.
     * @example
     * // Delete a few Screenshots
     * const { count } = await prisma.screenshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScreenshotDeleteManyArgs>(args?: SelectSubset<T, ScreenshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Screenshots
     * const screenshot = await prisma.screenshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScreenshotUpdateManyArgs>(args: SelectSubset<T, ScreenshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Screenshots and returns the data updated in the database.
     * @param {ScreenshotUpdateManyAndReturnArgs} args - Arguments to update many Screenshots.
     * @example
     * // Update many Screenshots
     * const screenshot = await prisma.screenshot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Screenshots and only return the `id`
     * const screenshotWithIdOnly = await prisma.screenshot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScreenshotUpdateManyAndReturnArgs>(args: SelectSubset<T, ScreenshotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Screenshot.
     * @param {ScreenshotUpsertArgs} args - Arguments to update or create a Screenshot.
     * @example
     * // Update or create a Screenshot
     * const screenshot = await prisma.screenshot.upsert({
     *   create: {
     *     // ... data to create a Screenshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Screenshot we want to update
     *   }
     * })
     */
    upsert<T extends ScreenshotUpsertArgs>(args: SelectSubset<T, ScreenshotUpsertArgs<ExtArgs>>): Prisma__ScreenshotClient<$Result.GetResult<Prisma.$ScreenshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotCountArgs} args - Arguments to filter Screenshots to count.
     * @example
     * // Count the number of Screenshots
     * const count = await prisma.screenshot.count({
     *   where: {
     *     // ... the filter for the Screenshots we want to count
     *   }
     * })
    **/
    count<T extends ScreenshotCountArgs>(
      args?: Subset<T, ScreenshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenshotAggregateArgs>(args: Subset<T, ScreenshotAggregateArgs>): Prisma.PrismaPromise<GetScreenshotAggregateType<T>>

    /**
     * Group by Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScreenshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScreenshotGroupByArgs['orderBy'] }
        : { orderBy?: ScreenshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScreenshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Screenshot model
   */
  readonly fields: ScreenshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Screenshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScreenshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Screenshot model
   */
  interface ScreenshotFieldRefs {
    readonly id: FieldRef<"Screenshot", 'Int'>
    readonly url: FieldRef<"Screenshot", 'String'>
    readonly description: FieldRef<"Screenshot", 'String'>
    readonly order: FieldRef<"Screenshot", 'Int'>
    readonly createdAt: FieldRef<"Screenshot", 'DateTime'>
    readonly updatedAt: FieldRef<"Screenshot", 'DateTime'>
    readonly projectId: FieldRef<"Screenshot", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Screenshot findUnique
   */
  export type ScreenshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot findUniqueOrThrow
   */
  export type ScreenshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot findFirst
   */
  export type ScreenshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Screenshot findFirstOrThrow
   */
  export type ScreenshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshot to fetch.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Screenshot findMany
   */
  export type ScreenshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter, which Screenshots to fetch.
     */
    where?: ScreenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Screenshots to fetch.
     */
    orderBy?: ScreenshotOrderByWithRelationInput | ScreenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Screenshots.
     */
    cursor?: ScreenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Screenshots.
     */
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * Screenshot create
   */
  export type ScreenshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * The data needed to create a Screenshot.
     */
    data: XOR<ScreenshotCreateInput, ScreenshotUncheckedCreateInput>
  }

  /**
   * Screenshot createMany
   */
  export type ScreenshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Screenshots.
     */
    data: ScreenshotCreateManyInput | ScreenshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Screenshot createManyAndReturn
   */
  export type ScreenshotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * The data used to create many Screenshots.
     */
    data: ScreenshotCreateManyInput | ScreenshotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Screenshot update
   */
  export type ScreenshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * The data needed to update a Screenshot.
     */
    data: XOR<ScreenshotUpdateInput, ScreenshotUncheckedUpdateInput>
    /**
     * Choose, which Screenshot to update.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot updateMany
   */
  export type ScreenshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Screenshots.
     */
    data: XOR<ScreenshotUpdateManyMutationInput, ScreenshotUncheckedUpdateManyInput>
    /**
     * Filter which Screenshots to update
     */
    where?: ScreenshotWhereInput
    /**
     * Limit how many Screenshots to update.
     */
    limit?: number
  }

  /**
   * Screenshot updateManyAndReturn
   */
  export type ScreenshotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * The data used to update Screenshots.
     */
    data: XOR<ScreenshotUpdateManyMutationInput, ScreenshotUncheckedUpdateManyInput>
    /**
     * Filter which Screenshots to update
     */
    where?: ScreenshotWhereInput
    /**
     * Limit how many Screenshots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Screenshot upsert
   */
  export type ScreenshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * The filter to search for the Screenshot to update in case it exists.
     */
    where: ScreenshotWhereUniqueInput
    /**
     * In case the Screenshot found by the `where` argument doesn't exist, create a new Screenshot with this data.
     */
    create: XOR<ScreenshotCreateInput, ScreenshotUncheckedCreateInput>
    /**
     * In case the Screenshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScreenshotUpdateInput, ScreenshotUncheckedUpdateInput>
  }

  /**
   * Screenshot delete
   */
  export type ScreenshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
    /**
     * Filter which Screenshot to delete.
     */
    where: ScreenshotWhereUniqueInput
  }

  /**
   * Screenshot deleteMany
   */
  export type ScreenshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Screenshots to delete
     */
    where?: ScreenshotWhereInput
    /**
     * Limit how many Screenshots to delete.
     */
    limit?: number
  }

  /**
   * Screenshot without action
   */
  export type ScreenshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Screenshot
     */
    select?: ScreenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Screenshot
     */
    omit?: ScreenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScreenshotInclude<ExtArgs> | null
  }


  /**
   * Model Technology
   */

  export type AggregateTechnology = {
    _count: TechnologyCountAggregateOutputType | null
    _avg: TechnologyAvgAggregateOutputType | null
    _sum: TechnologySumAggregateOutputType | null
    _min: TechnologyMinAggregateOutputType | null
    _max: TechnologyMaxAggregateOutputType | null
  }

  export type TechnologyAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TechnologySumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type TechnologyMinAggregateOutputType = {
    id: number | null
    name: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type TechnologyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type TechnologyCountAggregateOutputType = {
    id: number
    name: number
    reason: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type TechnologyAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TechnologySumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type TechnologyMinAggregateInputType = {
    id?: true
    name?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TechnologyMaxAggregateInputType = {
    id?: true
    name?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type TechnologyCountAggregateInputType = {
    id?: true
    name?: true
    reason?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type TechnologyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technology to aggregate.
     */
    where?: TechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technologies to fetch.
     */
    orderBy?: TechnologyOrderByWithRelationInput | TechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Technologies
    **/
    _count?: true | TechnologyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TechnologyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TechnologySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TechnologyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TechnologyMaxAggregateInputType
  }

  export type GetTechnologyAggregateType<T extends TechnologyAggregateArgs> = {
        [P in keyof T & keyof AggregateTechnology]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTechnology[P]>
      : GetScalarType<T[P], AggregateTechnology[P]>
  }




  export type TechnologyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TechnologyWhereInput
    orderBy?: TechnologyOrderByWithAggregationInput | TechnologyOrderByWithAggregationInput[]
    by: TechnologyScalarFieldEnum[] | TechnologyScalarFieldEnum
    having?: TechnologyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TechnologyCountAggregateInputType | true
    _avg?: TechnologyAvgAggregateInputType
    _sum?: TechnologySumAggregateInputType
    _min?: TechnologyMinAggregateInputType
    _max?: TechnologyMaxAggregateInputType
  }

  export type TechnologyGroupByOutputType = {
    id: number
    name: string
    reason: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: TechnologyCountAggregateOutputType | null
    _avg: TechnologyAvgAggregateOutputType | null
    _sum: TechnologySumAggregateOutputType | null
    _min: TechnologyMinAggregateOutputType | null
    _max: TechnologyMaxAggregateOutputType | null
  }

  type GetTechnologyGroupByPayload<T extends TechnologyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TechnologyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TechnologyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TechnologyGroupByOutputType[P]>
            : GetScalarType<T[P], TechnologyGroupByOutputType[P]>
        }
      >
    >


  export type TechnologySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technology"]>

  export type TechnologySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technology"]>

  export type TechnologySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["technology"]>

  export type TechnologySelectScalar = {
    id?: boolean
    name?: boolean
    reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type TechnologyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "reason" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["technology"]>
  export type TechnologyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TechnologyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type TechnologyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $TechnologyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Technology"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      reason: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["technology"]>
    composites: {}
  }

  type TechnologyGetPayload<S extends boolean | null | undefined | TechnologyDefaultArgs> = $Result.GetResult<Prisma.$TechnologyPayload, S>

  type TechnologyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TechnologyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TechnologyCountAggregateInputType | true
    }

  export interface TechnologyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Technology'], meta: { name: 'Technology' } }
    /**
     * Find zero or one Technology that matches the filter.
     * @param {TechnologyFindUniqueArgs} args - Arguments to find a Technology
     * @example
     * // Get one Technology
     * const technology = await prisma.technology.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TechnologyFindUniqueArgs>(args: SelectSubset<T, TechnologyFindUniqueArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Technology that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TechnologyFindUniqueOrThrowArgs} args - Arguments to find a Technology
     * @example
     * // Get one Technology
     * const technology = await prisma.technology.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TechnologyFindUniqueOrThrowArgs>(args: SelectSubset<T, TechnologyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Technology that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyFindFirstArgs} args - Arguments to find a Technology
     * @example
     * // Get one Technology
     * const technology = await prisma.technology.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TechnologyFindFirstArgs>(args?: SelectSubset<T, TechnologyFindFirstArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Technology that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyFindFirstOrThrowArgs} args - Arguments to find a Technology
     * @example
     * // Get one Technology
     * const technology = await prisma.technology.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TechnologyFindFirstOrThrowArgs>(args?: SelectSubset<T, TechnologyFindFirstOrThrowArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Technologies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Technologies
     * const technologies = await prisma.technology.findMany()
     * 
     * // Get first 10 Technologies
     * const technologies = await prisma.technology.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const technologyWithIdOnly = await prisma.technology.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TechnologyFindManyArgs>(args?: SelectSubset<T, TechnologyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Technology.
     * @param {TechnologyCreateArgs} args - Arguments to create a Technology.
     * @example
     * // Create one Technology
     * const Technology = await prisma.technology.create({
     *   data: {
     *     // ... data to create a Technology
     *   }
     * })
     * 
     */
    create<T extends TechnologyCreateArgs>(args: SelectSubset<T, TechnologyCreateArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Technologies.
     * @param {TechnologyCreateManyArgs} args - Arguments to create many Technologies.
     * @example
     * // Create many Technologies
     * const technology = await prisma.technology.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TechnologyCreateManyArgs>(args?: SelectSubset<T, TechnologyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Technologies and returns the data saved in the database.
     * @param {TechnologyCreateManyAndReturnArgs} args - Arguments to create many Technologies.
     * @example
     * // Create many Technologies
     * const technology = await prisma.technology.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Technologies and only return the `id`
     * const technologyWithIdOnly = await prisma.technology.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TechnologyCreateManyAndReturnArgs>(args?: SelectSubset<T, TechnologyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Technology.
     * @param {TechnologyDeleteArgs} args - Arguments to delete one Technology.
     * @example
     * // Delete one Technology
     * const Technology = await prisma.technology.delete({
     *   where: {
     *     // ... filter to delete one Technology
     *   }
     * })
     * 
     */
    delete<T extends TechnologyDeleteArgs>(args: SelectSubset<T, TechnologyDeleteArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Technology.
     * @param {TechnologyUpdateArgs} args - Arguments to update one Technology.
     * @example
     * // Update one Technology
     * const technology = await prisma.technology.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TechnologyUpdateArgs>(args: SelectSubset<T, TechnologyUpdateArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Technologies.
     * @param {TechnologyDeleteManyArgs} args - Arguments to filter Technologies to delete.
     * @example
     * // Delete a few Technologies
     * const { count } = await prisma.technology.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TechnologyDeleteManyArgs>(args?: SelectSubset<T, TechnologyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Technologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Technologies
     * const technology = await prisma.technology.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TechnologyUpdateManyArgs>(args: SelectSubset<T, TechnologyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Technologies and returns the data updated in the database.
     * @param {TechnologyUpdateManyAndReturnArgs} args - Arguments to update many Technologies.
     * @example
     * // Update many Technologies
     * const technology = await prisma.technology.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Technologies and only return the `id`
     * const technologyWithIdOnly = await prisma.technology.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TechnologyUpdateManyAndReturnArgs>(args: SelectSubset<T, TechnologyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Technology.
     * @param {TechnologyUpsertArgs} args - Arguments to update or create a Technology.
     * @example
     * // Update or create a Technology
     * const technology = await prisma.technology.upsert({
     *   create: {
     *     // ... data to create a Technology
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Technology we want to update
     *   }
     * })
     */
    upsert<T extends TechnologyUpsertArgs>(args: SelectSubset<T, TechnologyUpsertArgs<ExtArgs>>): Prisma__TechnologyClient<$Result.GetResult<Prisma.$TechnologyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Technologies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyCountArgs} args - Arguments to filter Technologies to count.
     * @example
     * // Count the number of Technologies
     * const count = await prisma.technology.count({
     *   where: {
     *     // ... the filter for the Technologies we want to count
     *   }
     * })
    **/
    count<T extends TechnologyCountArgs>(
      args?: Subset<T, TechnologyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TechnologyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Technology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TechnologyAggregateArgs>(args: Subset<T, TechnologyAggregateArgs>): Prisma.PrismaPromise<GetTechnologyAggregateType<T>>

    /**
     * Group by Technology.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TechnologyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TechnologyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TechnologyGroupByArgs['orderBy'] }
        : { orderBy?: TechnologyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TechnologyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTechnologyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Technology model
   */
  readonly fields: TechnologyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Technology.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TechnologyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Technology model
   */
  interface TechnologyFieldRefs {
    readonly id: FieldRef<"Technology", 'Int'>
    readonly name: FieldRef<"Technology", 'String'>
    readonly reason: FieldRef<"Technology", 'String'>
    readonly createdAt: FieldRef<"Technology", 'DateTime'>
    readonly updatedAt: FieldRef<"Technology", 'DateTime'>
    readonly projectId: FieldRef<"Technology", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Technology findUnique
   */
  export type TechnologyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * Filter, which Technology to fetch.
     */
    where: TechnologyWhereUniqueInput
  }

  /**
   * Technology findUniqueOrThrow
   */
  export type TechnologyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * Filter, which Technology to fetch.
     */
    where: TechnologyWhereUniqueInput
  }

  /**
   * Technology findFirst
   */
  export type TechnologyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * Filter, which Technology to fetch.
     */
    where?: TechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technologies to fetch.
     */
    orderBy?: TechnologyOrderByWithRelationInput | TechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Technologies.
     */
    cursor?: TechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Technologies.
     */
    distinct?: TechnologyScalarFieldEnum | TechnologyScalarFieldEnum[]
  }

  /**
   * Technology findFirstOrThrow
   */
  export type TechnologyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * Filter, which Technology to fetch.
     */
    where?: TechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technologies to fetch.
     */
    orderBy?: TechnologyOrderByWithRelationInput | TechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Technologies.
     */
    cursor?: TechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technologies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Technologies.
     */
    distinct?: TechnologyScalarFieldEnum | TechnologyScalarFieldEnum[]
  }

  /**
   * Technology findMany
   */
  export type TechnologyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * Filter, which Technologies to fetch.
     */
    where?: TechnologyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Technologies to fetch.
     */
    orderBy?: TechnologyOrderByWithRelationInput | TechnologyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Technologies.
     */
    cursor?: TechnologyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Technologies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Technologies.
     */
    skip?: number
    distinct?: TechnologyScalarFieldEnum | TechnologyScalarFieldEnum[]
  }

  /**
   * Technology create
   */
  export type TechnologyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * The data needed to create a Technology.
     */
    data: XOR<TechnologyCreateInput, TechnologyUncheckedCreateInput>
  }

  /**
   * Technology createMany
   */
  export type TechnologyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Technologies.
     */
    data: TechnologyCreateManyInput | TechnologyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Technology createManyAndReturn
   */
  export type TechnologyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * The data used to create many Technologies.
     */
    data: TechnologyCreateManyInput | TechnologyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Technology update
   */
  export type TechnologyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * The data needed to update a Technology.
     */
    data: XOR<TechnologyUpdateInput, TechnologyUncheckedUpdateInput>
    /**
     * Choose, which Technology to update.
     */
    where: TechnologyWhereUniqueInput
  }

  /**
   * Technology updateMany
   */
  export type TechnologyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Technologies.
     */
    data: XOR<TechnologyUpdateManyMutationInput, TechnologyUncheckedUpdateManyInput>
    /**
     * Filter which Technologies to update
     */
    where?: TechnologyWhereInput
    /**
     * Limit how many Technologies to update.
     */
    limit?: number
  }

  /**
   * Technology updateManyAndReturn
   */
  export type TechnologyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * The data used to update Technologies.
     */
    data: XOR<TechnologyUpdateManyMutationInput, TechnologyUncheckedUpdateManyInput>
    /**
     * Filter which Technologies to update
     */
    where?: TechnologyWhereInput
    /**
     * Limit how many Technologies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Technology upsert
   */
  export type TechnologyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * The filter to search for the Technology to update in case it exists.
     */
    where: TechnologyWhereUniqueInput
    /**
     * In case the Technology found by the `where` argument doesn't exist, create a new Technology with this data.
     */
    create: XOR<TechnologyCreateInput, TechnologyUncheckedCreateInput>
    /**
     * In case the Technology was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TechnologyUpdateInput, TechnologyUncheckedUpdateInput>
  }

  /**
   * Technology delete
   */
  export type TechnologyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
    /**
     * Filter which Technology to delete.
     */
    where: TechnologyWhereUniqueInput
  }

  /**
   * Technology deleteMany
   */
  export type TechnologyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Technologies to delete
     */
    where?: TechnologyWhereInput
    /**
     * Limit how many Technologies to delete.
     */
    limit?: number
  }

  /**
   * Technology without action
   */
  export type TechnologyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Technology
     */
    select?: TechnologySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Technology
     */
    omit?: TechnologyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TechnologyInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagAvgAggregateOutputType = {
    id: number | null
  }

  export type TagSumAggregateOutputType = {
    id: number | null
  }

  export type TagMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagAvgAggregateInputType = {
    id?: true
  }

  export type TagSumAggregateInputType = {
    id?: true
  }

  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _avg?: TagAvgAggregateInputType
    _sum?: TagSumAggregateInputType
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: number
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _avg: TagAvgAggregateOutputType | null
    _sum: TagSumAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectTags?: boolean | Tag$projectTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projectTags?: boolean | Tag$projectTagsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      projectTags: Prisma.$ProjectTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projectTags<T extends Tag$projectTagsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$projectTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'Int'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.projectTags
   */
  export type Tag$projectTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    where?: ProjectTagWhereInput
    orderBy?: ProjectTagOrderByWithRelationInput | ProjectTagOrderByWithRelationInput[]
    cursor?: ProjectTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectTagScalarFieldEnum | ProjectTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ProjectTag
   */

  export type AggregateProjectTag = {
    _count: ProjectTagCountAggregateOutputType | null
    _avg: ProjectTagAvgAggregateOutputType | null
    _sum: ProjectTagSumAggregateOutputType | null
    _min: ProjectTagMinAggregateOutputType | null
    _max: ProjectTagMaxAggregateOutputType | null
  }

  export type ProjectTagAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
    tagId: number | null
  }

  export type ProjectTagSumAggregateOutputType = {
    id: number | null
    projectId: number | null
    tagId: number | null
  }

  export type ProjectTagMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    projectId: number | null
    tagId: number | null
  }

  export type ProjectTagMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    projectId: number | null
    tagId: number | null
  }

  export type ProjectTagCountAggregateOutputType = {
    id: number
    createdAt: number
    projectId: number
    tagId: number
    _all: number
  }


  export type ProjectTagAvgAggregateInputType = {
    id?: true
    projectId?: true
    tagId?: true
  }

  export type ProjectTagSumAggregateInputType = {
    id?: true
    projectId?: true
    tagId?: true
  }

  export type ProjectTagMinAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    tagId?: true
  }

  export type ProjectTagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    tagId?: true
  }

  export type ProjectTagCountAggregateInputType = {
    id?: true
    createdAt?: true
    projectId?: true
    tagId?: true
    _all?: true
  }

  export type ProjectTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTag to aggregate.
     */
    where?: ProjectTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagOrderByWithRelationInput | ProjectTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectTags
    **/
    _count?: true | ProjectTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectTagMaxAggregateInputType
  }

  export type GetProjectTagAggregateType<T extends ProjectTagAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectTag[P]>
      : GetScalarType<T[P], AggregateProjectTag[P]>
  }




  export type ProjectTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectTagWhereInput
    orderBy?: ProjectTagOrderByWithAggregationInput | ProjectTagOrderByWithAggregationInput[]
    by: ProjectTagScalarFieldEnum[] | ProjectTagScalarFieldEnum
    having?: ProjectTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectTagCountAggregateInputType | true
    _avg?: ProjectTagAvgAggregateInputType
    _sum?: ProjectTagSumAggregateInputType
    _min?: ProjectTagMinAggregateInputType
    _max?: ProjectTagMaxAggregateInputType
  }

  export type ProjectTagGroupByOutputType = {
    id: number
    createdAt: Date
    projectId: number
    tagId: number
    _count: ProjectTagCountAggregateOutputType | null
    _avg: ProjectTagAvgAggregateOutputType | null
    _sum: ProjectTagSumAggregateOutputType | null
    _min: ProjectTagMinAggregateOutputType | null
    _max: ProjectTagMaxAggregateOutputType | null
  }

  type GetProjectTagGroupByPayload<T extends ProjectTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectTagGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectTagGroupByOutputType[P]>
        }
      >
    >


  export type ProjectTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    tagId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTag"]>

  export type ProjectTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    tagId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTag"]>

  export type ProjectTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    tagId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectTag"]>

  export type ProjectTagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    projectId?: boolean
    tagId?: boolean
  }

  export type ProjectTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "projectId" | "tagId", ExtArgs["result"]["projectTag"]>
  export type ProjectTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ProjectTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ProjectTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ProjectTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectTag"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      projectId: number
      tagId: number
    }, ExtArgs["result"]["projectTag"]>
    composites: {}
  }

  type ProjectTagGetPayload<S extends boolean | null | undefined | ProjectTagDefaultArgs> = $Result.GetResult<Prisma.$ProjectTagPayload, S>

  type ProjectTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectTagCountAggregateInputType | true
    }

  export interface ProjectTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectTag'], meta: { name: 'ProjectTag' } }
    /**
     * Find zero or one ProjectTag that matches the filter.
     * @param {ProjectTagFindUniqueArgs} args - Arguments to find a ProjectTag
     * @example
     * // Get one ProjectTag
     * const projectTag = await prisma.projectTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectTagFindUniqueArgs>(args: SelectSubset<T, ProjectTagFindUniqueArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectTagFindUniqueOrThrowArgs} args - Arguments to find a ProjectTag
     * @example
     * // Get one ProjectTag
     * const projectTag = await prisma.projectTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagFindFirstArgs} args - Arguments to find a ProjectTag
     * @example
     * // Get one ProjectTag
     * const projectTag = await prisma.projectTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectTagFindFirstArgs>(args?: SelectSubset<T, ProjectTagFindFirstArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagFindFirstOrThrowArgs} args - Arguments to find a ProjectTag
     * @example
     * // Get one ProjectTag
     * const projectTag = await prisma.projectTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectTags
     * const projectTags = await prisma.projectTag.findMany()
     * 
     * // Get first 10 ProjectTags
     * const projectTags = await prisma.projectTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectTagWithIdOnly = await prisma.projectTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectTagFindManyArgs>(args?: SelectSubset<T, ProjectTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectTag.
     * @param {ProjectTagCreateArgs} args - Arguments to create a ProjectTag.
     * @example
     * // Create one ProjectTag
     * const ProjectTag = await prisma.projectTag.create({
     *   data: {
     *     // ... data to create a ProjectTag
     *   }
     * })
     * 
     */
    create<T extends ProjectTagCreateArgs>(args: SelectSubset<T, ProjectTagCreateArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectTags.
     * @param {ProjectTagCreateManyArgs} args - Arguments to create many ProjectTags.
     * @example
     * // Create many ProjectTags
     * const projectTag = await prisma.projectTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectTagCreateManyArgs>(args?: SelectSubset<T, ProjectTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectTags and returns the data saved in the database.
     * @param {ProjectTagCreateManyAndReturnArgs} args - Arguments to create many ProjectTags.
     * @example
     * // Create many ProjectTags
     * const projectTag = await prisma.projectTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectTags and only return the `id`
     * const projectTagWithIdOnly = await prisma.projectTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectTag.
     * @param {ProjectTagDeleteArgs} args - Arguments to delete one ProjectTag.
     * @example
     * // Delete one ProjectTag
     * const ProjectTag = await prisma.projectTag.delete({
     *   where: {
     *     // ... filter to delete one ProjectTag
     *   }
     * })
     * 
     */
    delete<T extends ProjectTagDeleteArgs>(args: SelectSubset<T, ProjectTagDeleteArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectTag.
     * @param {ProjectTagUpdateArgs} args - Arguments to update one ProjectTag.
     * @example
     * // Update one ProjectTag
     * const projectTag = await prisma.projectTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectTagUpdateArgs>(args: SelectSubset<T, ProjectTagUpdateArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectTags.
     * @param {ProjectTagDeleteManyArgs} args - Arguments to filter ProjectTags to delete.
     * @example
     * // Delete a few ProjectTags
     * const { count } = await prisma.projectTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectTagDeleteManyArgs>(args?: SelectSubset<T, ProjectTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectTags
     * const projectTag = await prisma.projectTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectTagUpdateManyArgs>(args: SelectSubset<T, ProjectTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectTags and returns the data updated in the database.
     * @param {ProjectTagUpdateManyAndReturnArgs} args - Arguments to update many ProjectTags.
     * @example
     * // Update many ProjectTags
     * const projectTag = await prisma.projectTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectTags and only return the `id`
     * const projectTagWithIdOnly = await prisma.projectTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectTag.
     * @param {ProjectTagUpsertArgs} args - Arguments to update or create a ProjectTag.
     * @example
     * // Update or create a ProjectTag
     * const projectTag = await prisma.projectTag.upsert({
     *   create: {
     *     // ... data to create a ProjectTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectTag we want to update
     *   }
     * })
     */
    upsert<T extends ProjectTagUpsertArgs>(args: SelectSubset<T, ProjectTagUpsertArgs<ExtArgs>>): Prisma__ProjectTagClient<$Result.GetResult<Prisma.$ProjectTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagCountArgs} args - Arguments to filter ProjectTags to count.
     * @example
     * // Count the number of ProjectTags
     * const count = await prisma.projectTag.count({
     *   where: {
     *     // ... the filter for the ProjectTags we want to count
     *   }
     * })
    **/
    count<T extends ProjectTagCountArgs>(
      args?: Subset<T, ProjectTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectTagAggregateArgs>(args: Subset<T, ProjectTagAggregateArgs>): Prisma.PrismaPromise<GetProjectTagAggregateType<T>>

    /**
     * Group by ProjectTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectTagGroupByArgs['orderBy'] }
        : { orderBy?: ProjectTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectTag model
   */
  readonly fields: ProjectTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectTag model
   */
  interface ProjectTagFieldRefs {
    readonly id: FieldRef<"ProjectTag", 'Int'>
    readonly createdAt: FieldRef<"ProjectTag", 'DateTime'>
    readonly projectId: FieldRef<"ProjectTag", 'Int'>
    readonly tagId: FieldRef<"ProjectTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProjectTag findUnique
   */
  export type ProjectTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTag to fetch.
     */
    where: ProjectTagWhereUniqueInput
  }

  /**
   * ProjectTag findUniqueOrThrow
   */
  export type ProjectTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTag to fetch.
     */
    where: ProjectTagWhereUniqueInput
  }

  /**
   * ProjectTag findFirst
   */
  export type ProjectTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTag to fetch.
     */
    where?: ProjectTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagOrderByWithRelationInput | ProjectTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTags.
     */
    cursor?: ProjectTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTags.
     */
    distinct?: ProjectTagScalarFieldEnum | ProjectTagScalarFieldEnum[]
  }

  /**
   * ProjectTag findFirstOrThrow
   */
  export type ProjectTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTag to fetch.
     */
    where?: ProjectTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagOrderByWithRelationInput | ProjectTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectTags.
     */
    cursor?: ProjectTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectTags.
     */
    distinct?: ProjectTagScalarFieldEnum | ProjectTagScalarFieldEnum[]
  }

  /**
   * ProjectTag findMany
   */
  export type ProjectTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * Filter, which ProjectTags to fetch.
     */
    where?: ProjectTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectTags to fetch.
     */
    orderBy?: ProjectTagOrderByWithRelationInput | ProjectTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectTags.
     */
    cursor?: ProjectTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectTags.
     */
    skip?: number
    distinct?: ProjectTagScalarFieldEnum | ProjectTagScalarFieldEnum[]
  }

  /**
   * ProjectTag create
   */
  export type ProjectTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectTag.
     */
    data: XOR<ProjectTagCreateInput, ProjectTagUncheckedCreateInput>
  }

  /**
   * ProjectTag createMany
   */
  export type ProjectTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectTags.
     */
    data: ProjectTagCreateManyInput | ProjectTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectTag createManyAndReturn
   */
  export type ProjectTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectTags.
     */
    data: ProjectTagCreateManyInput | ProjectTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTag update
   */
  export type ProjectTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectTag.
     */
    data: XOR<ProjectTagUpdateInput, ProjectTagUncheckedUpdateInput>
    /**
     * Choose, which ProjectTag to update.
     */
    where: ProjectTagWhereUniqueInput
  }

  /**
   * ProjectTag updateMany
   */
  export type ProjectTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectTags.
     */
    data: XOR<ProjectTagUpdateManyMutationInput, ProjectTagUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTags to update
     */
    where?: ProjectTagWhereInput
    /**
     * Limit how many ProjectTags to update.
     */
    limit?: number
  }

  /**
   * ProjectTag updateManyAndReturn
   */
  export type ProjectTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * The data used to update ProjectTags.
     */
    data: XOR<ProjectTagUpdateManyMutationInput, ProjectTagUncheckedUpdateManyInput>
    /**
     * Filter which ProjectTags to update
     */
    where?: ProjectTagWhereInput
    /**
     * Limit how many ProjectTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectTag upsert
   */
  export type ProjectTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectTag to update in case it exists.
     */
    where: ProjectTagWhereUniqueInput
    /**
     * In case the ProjectTag found by the `where` argument doesn't exist, create a new ProjectTag with this data.
     */
    create: XOR<ProjectTagCreateInput, ProjectTagUncheckedCreateInput>
    /**
     * In case the ProjectTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectTagUpdateInput, ProjectTagUncheckedUpdateInput>
  }

  /**
   * ProjectTag delete
   */
  export type ProjectTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
    /**
     * Filter which ProjectTag to delete.
     */
    where: ProjectTagWhereUniqueInput
  }

  /**
   * ProjectTag deleteMany
   */
  export type ProjectTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectTags to delete
     */
    where?: ProjectTagWhereInput
    /**
     * Limit how many ProjectTags to delete.
     */
    limit?: number
  }

  /**
   * ProjectTag without action
   */
  export type ProjectTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectTag
     */
    select?: ProjectTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectTag
     */
    omit?: ProjectTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectTagInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type LessonSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type LessonMinAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type LessonMaxAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type LessonSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: number
    description: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'Int'>
    readonly description: FieldRef<"Lesson", 'String'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
    readonly projectId: FieldRef<"Lesson", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model BusinessOutcome
   */

  export type AggregateBusinessOutcome = {
    _count: BusinessOutcomeCountAggregateOutputType | null
    _avg: BusinessOutcomeAvgAggregateOutputType | null
    _sum: BusinessOutcomeSumAggregateOutputType | null
    _min: BusinessOutcomeMinAggregateOutputType | null
    _max: BusinessOutcomeMaxAggregateOutputType | null
  }

  export type BusinessOutcomeAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type BusinessOutcomeSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type BusinessOutcomeMinAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type BusinessOutcomeMaxAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type BusinessOutcomeCountAggregateOutputType = {
    id: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type BusinessOutcomeAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type BusinessOutcomeSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type BusinessOutcomeMinAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type BusinessOutcomeMaxAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type BusinessOutcomeCountAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type BusinessOutcomeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessOutcome to aggregate.
     */
    where?: BusinessOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOutcomes to fetch.
     */
    orderBy?: BusinessOutcomeOrderByWithRelationInput | BusinessOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BusinessOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BusinessOutcomes
    **/
    _count?: true | BusinessOutcomeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BusinessOutcomeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BusinessOutcomeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BusinessOutcomeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BusinessOutcomeMaxAggregateInputType
  }

  export type GetBusinessOutcomeAggregateType<T extends BusinessOutcomeAggregateArgs> = {
        [P in keyof T & keyof AggregateBusinessOutcome]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBusinessOutcome[P]>
      : GetScalarType<T[P], AggregateBusinessOutcome[P]>
  }




  export type BusinessOutcomeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BusinessOutcomeWhereInput
    orderBy?: BusinessOutcomeOrderByWithAggregationInput | BusinessOutcomeOrderByWithAggregationInput[]
    by: BusinessOutcomeScalarFieldEnum[] | BusinessOutcomeScalarFieldEnum
    having?: BusinessOutcomeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BusinessOutcomeCountAggregateInputType | true
    _avg?: BusinessOutcomeAvgAggregateInputType
    _sum?: BusinessOutcomeSumAggregateInputType
    _min?: BusinessOutcomeMinAggregateInputType
    _max?: BusinessOutcomeMaxAggregateInputType
  }

  export type BusinessOutcomeGroupByOutputType = {
    id: number
    description: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: BusinessOutcomeCountAggregateOutputType | null
    _avg: BusinessOutcomeAvgAggregateOutputType | null
    _sum: BusinessOutcomeSumAggregateOutputType | null
    _min: BusinessOutcomeMinAggregateOutputType | null
    _max: BusinessOutcomeMaxAggregateOutputType | null
  }

  type GetBusinessOutcomeGroupByPayload<T extends BusinessOutcomeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BusinessOutcomeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BusinessOutcomeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BusinessOutcomeGroupByOutputType[P]>
            : GetScalarType<T[P], BusinessOutcomeGroupByOutputType[P]>
        }
      >
    >


  export type BusinessOutcomeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessOutcome"]>

  export type BusinessOutcomeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessOutcome"]>

  export type BusinessOutcomeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["businessOutcome"]>

  export type BusinessOutcomeSelectScalar = {
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type BusinessOutcomeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["businessOutcome"]>
  export type BusinessOutcomeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type BusinessOutcomeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type BusinessOutcomeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $BusinessOutcomePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BusinessOutcome"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["businessOutcome"]>
    composites: {}
  }

  type BusinessOutcomeGetPayload<S extends boolean | null | undefined | BusinessOutcomeDefaultArgs> = $Result.GetResult<Prisma.$BusinessOutcomePayload, S>

  type BusinessOutcomeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BusinessOutcomeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BusinessOutcomeCountAggregateInputType | true
    }

  export interface BusinessOutcomeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BusinessOutcome'], meta: { name: 'BusinessOutcome' } }
    /**
     * Find zero or one BusinessOutcome that matches the filter.
     * @param {BusinessOutcomeFindUniqueArgs} args - Arguments to find a BusinessOutcome
     * @example
     * // Get one BusinessOutcome
     * const businessOutcome = await prisma.businessOutcome.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BusinessOutcomeFindUniqueArgs>(args: SelectSubset<T, BusinessOutcomeFindUniqueArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BusinessOutcome that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BusinessOutcomeFindUniqueOrThrowArgs} args - Arguments to find a BusinessOutcome
     * @example
     * // Get one BusinessOutcome
     * const businessOutcome = await prisma.businessOutcome.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BusinessOutcomeFindUniqueOrThrowArgs>(args: SelectSubset<T, BusinessOutcomeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessOutcome that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeFindFirstArgs} args - Arguments to find a BusinessOutcome
     * @example
     * // Get one BusinessOutcome
     * const businessOutcome = await prisma.businessOutcome.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BusinessOutcomeFindFirstArgs>(args?: SelectSubset<T, BusinessOutcomeFindFirstArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BusinessOutcome that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeFindFirstOrThrowArgs} args - Arguments to find a BusinessOutcome
     * @example
     * // Get one BusinessOutcome
     * const businessOutcome = await prisma.businessOutcome.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BusinessOutcomeFindFirstOrThrowArgs>(args?: SelectSubset<T, BusinessOutcomeFindFirstOrThrowArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BusinessOutcomes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BusinessOutcomes
     * const businessOutcomes = await prisma.businessOutcome.findMany()
     * 
     * // Get first 10 BusinessOutcomes
     * const businessOutcomes = await prisma.businessOutcome.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const businessOutcomeWithIdOnly = await prisma.businessOutcome.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BusinessOutcomeFindManyArgs>(args?: SelectSubset<T, BusinessOutcomeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BusinessOutcome.
     * @param {BusinessOutcomeCreateArgs} args - Arguments to create a BusinessOutcome.
     * @example
     * // Create one BusinessOutcome
     * const BusinessOutcome = await prisma.businessOutcome.create({
     *   data: {
     *     // ... data to create a BusinessOutcome
     *   }
     * })
     * 
     */
    create<T extends BusinessOutcomeCreateArgs>(args: SelectSubset<T, BusinessOutcomeCreateArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BusinessOutcomes.
     * @param {BusinessOutcomeCreateManyArgs} args - Arguments to create many BusinessOutcomes.
     * @example
     * // Create many BusinessOutcomes
     * const businessOutcome = await prisma.businessOutcome.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BusinessOutcomeCreateManyArgs>(args?: SelectSubset<T, BusinessOutcomeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BusinessOutcomes and returns the data saved in the database.
     * @param {BusinessOutcomeCreateManyAndReturnArgs} args - Arguments to create many BusinessOutcomes.
     * @example
     * // Create many BusinessOutcomes
     * const businessOutcome = await prisma.businessOutcome.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BusinessOutcomes and only return the `id`
     * const businessOutcomeWithIdOnly = await prisma.businessOutcome.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BusinessOutcomeCreateManyAndReturnArgs>(args?: SelectSubset<T, BusinessOutcomeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BusinessOutcome.
     * @param {BusinessOutcomeDeleteArgs} args - Arguments to delete one BusinessOutcome.
     * @example
     * // Delete one BusinessOutcome
     * const BusinessOutcome = await prisma.businessOutcome.delete({
     *   where: {
     *     // ... filter to delete one BusinessOutcome
     *   }
     * })
     * 
     */
    delete<T extends BusinessOutcomeDeleteArgs>(args: SelectSubset<T, BusinessOutcomeDeleteArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BusinessOutcome.
     * @param {BusinessOutcomeUpdateArgs} args - Arguments to update one BusinessOutcome.
     * @example
     * // Update one BusinessOutcome
     * const businessOutcome = await prisma.businessOutcome.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BusinessOutcomeUpdateArgs>(args: SelectSubset<T, BusinessOutcomeUpdateArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BusinessOutcomes.
     * @param {BusinessOutcomeDeleteManyArgs} args - Arguments to filter BusinessOutcomes to delete.
     * @example
     * // Delete a few BusinessOutcomes
     * const { count } = await prisma.businessOutcome.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BusinessOutcomeDeleteManyArgs>(args?: SelectSubset<T, BusinessOutcomeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BusinessOutcomes
     * const businessOutcome = await prisma.businessOutcome.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BusinessOutcomeUpdateManyArgs>(args: SelectSubset<T, BusinessOutcomeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BusinessOutcomes and returns the data updated in the database.
     * @param {BusinessOutcomeUpdateManyAndReturnArgs} args - Arguments to update many BusinessOutcomes.
     * @example
     * // Update many BusinessOutcomes
     * const businessOutcome = await prisma.businessOutcome.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BusinessOutcomes and only return the `id`
     * const businessOutcomeWithIdOnly = await prisma.businessOutcome.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BusinessOutcomeUpdateManyAndReturnArgs>(args: SelectSubset<T, BusinessOutcomeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BusinessOutcome.
     * @param {BusinessOutcomeUpsertArgs} args - Arguments to update or create a BusinessOutcome.
     * @example
     * // Update or create a BusinessOutcome
     * const businessOutcome = await prisma.businessOutcome.upsert({
     *   create: {
     *     // ... data to create a BusinessOutcome
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BusinessOutcome we want to update
     *   }
     * })
     */
    upsert<T extends BusinessOutcomeUpsertArgs>(args: SelectSubset<T, BusinessOutcomeUpsertArgs<ExtArgs>>): Prisma__BusinessOutcomeClient<$Result.GetResult<Prisma.$BusinessOutcomePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BusinessOutcomes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeCountArgs} args - Arguments to filter BusinessOutcomes to count.
     * @example
     * // Count the number of BusinessOutcomes
     * const count = await prisma.businessOutcome.count({
     *   where: {
     *     // ... the filter for the BusinessOutcomes we want to count
     *   }
     * })
    **/
    count<T extends BusinessOutcomeCountArgs>(
      args?: Subset<T, BusinessOutcomeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BusinessOutcomeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BusinessOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BusinessOutcomeAggregateArgs>(args: Subset<T, BusinessOutcomeAggregateArgs>): Prisma.PrismaPromise<GetBusinessOutcomeAggregateType<T>>

    /**
     * Group by BusinessOutcome.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BusinessOutcomeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BusinessOutcomeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BusinessOutcomeGroupByArgs['orderBy'] }
        : { orderBy?: BusinessOutcomeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BusinessOutcomeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBusinessOutcomeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BusinessOutcome model
   */
  readonly fields: BusinessOutcomeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BusinessOutcome.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BusinessOutcomeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BusinessOutcome model
   */
  interface BusinessOutcomeFieldRefs {
    readonly id: FieldRef<"BusinessOutcome", 'Int'>
    readonly description: FieldRef<"BusinessOutcome", 'String'>
    readonly createdAt: FieldRef<"BusinessOutcome", 'DateTime'>
    readonly updatedAt: FieldRef<"BusinessOutcome", 'DateTime'>
    readonly projectId: FieldRef<"BusinessOutcome", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BusinessOutcome findUnique
   */
  export type BusinessOutcomeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOutcome to fetch.
     */
    where: BusinessOutcomeWhereUniqueInput
  }

  /**
   * BusinessOutcome findUniqueOrThrow
   */
  export type BusinessOutcomeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOutcome to fetch.
     */
    where: BusinessOutcomeWhereUniqueInput
  }

  /**
   * BusinessOutcome findFirst
   */
  export type BusinessOutcomeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOutcome to fetch.
     */
    where?: BusinessOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOutcomes to fetch.
     */
    orderBy?: BusinessOutcomeOrderByWithRelationInput | BusinessOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessOutcomes.
     */
    cursor?: BusinessOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessOutcomes.
     */
    distinct?: BusinessOutcomeScalarFieldEnum | BusinessOutcomeScalarFieldEnum[]
  }

  /**
   * BusinessOutcome findFirstOrThrow
   */
  export type BusinessOutcomeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOutcome to fetch.
     */
    where?: BusinessOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOutcomes to fetch.
     */
    orderBy?: BusinessOutcomeOrderByWithRelationInput | BusinessOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BusinessOutcomes.
     */
    cursor?: BusinessOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOutcomes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BusinessOutcomes.
     */
    distinct?: BusinessOutcomeScalarFieldEnum | BusinessOutcomeScalarFieldEnum[]
  }

  /**
   * BusinessOutcome findMany
   */
  export type BusinessOutcomeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * Filter, which BusinessOutcomes to fetch.
     */
    where?: BusinessOutcomeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BusinessOutcomes to fetch.
     */
    orderBy?: BusinessOutcomeOrderByWithRelationInput | BusinessOutcomeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BusinessOutcomes.
     */
    cursor?: BusinessOutcomeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BusinessOutcomes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BusinessOutcomes.
     */
    skip?: number
    distinct?: BusinessOutcomeScalarFieldEnum | BusinessOutcomeScalarFieldEnum[]
  }

  /**
   * BusinessOutcome create
   */
  export type BusinessOutcomeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to create a BusinessOutcome.
     */
    data: XOR<BusinessOutcomeCreateInput, BusinessOutcomeUncheckedCreateInput>
  }

  /**
   * BusinessOutcome createMany
   */
  export type BusinessOutcomeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BusinessOutcomes.
     */
    data: BusinessOutcomeCreateManyInput | BusinessOutcomeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BusinessOutcome createManyAndReturn
   */
  export type BusinessOutcomeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * The data used to create many BusinessOutcomes.
     */
    data: BusinessOutcomeCreateManyInput | BusinessOutcomeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessOutcome update
   */
  export type BusinessOutcomeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * The data needed to update a BusinessOutcome.
     */
    data: XOR<BusinessOutcomeUpdateInput, BusinessOutcomeUncheckedUpdateInput>
    /**
     * Choose, which BusinessOutcome to update.
     */
    where: BusinessOutcomeWhereUniqueInput
  }

  /**
   * BusinessOutcome updateMany
   */
  export type BusinessOutcomeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BusinessOutcomes.
     */
    data: XOR<BusinessOutcomeUpdateManyMutationInput, BusinessOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessOutcomes to update
     */
    where?: BusinessOutcomeWhereInput
    /**
     * Limit how many BusinessOutcomes to update.
     */
    limit?: number
  }

  /**
   * BusinessOutcome updateManyAndReturn
   */
  export type BusinessOutcomeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * The data used to update BusinessOutcomes.
     */
    data: XOR<BusinessOutcomeUpdateManyMutationInput, BusinessOutcomeUncheckedUpdateManyInput>
    /**
     * Filter which BusinessOutcomes to update
     */
    where?: BusinessOutcomeWhereInput
    /**
     * Limit how many BusinessOutcomes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BusinessOutcome upsert
   */
  export type BusinessOutcomeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * The filter to search for the BusinessOutcome to update in case it exists.
     */
    where: BusinessOutcomeWhereUniqueInput
    /**
     * In case the BusinessOutcome found by the `where` argument doesn't exist, create a new BusinessOutcome with this data.
     */
    create: XOR<BusinessOutcomeCreateInput, BusinessOutcomeUncheckedCreateInput>
    /**
     * In case the BusinessOutcome was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BusinessOutcomeUpdateInput, BusinessOutcomeUncheckedUpdateInput>
  }

  /**
   * BusinessOutcome delete
   */
  export type BusinessOutcomeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
    /**
     * Filter which BusinessOutcome to delete.
     */
    where: BusinessOutcomeWhereUniqueInput
  }

  /**
   * BusinessOutcome deleteMany
   */
  export type BusinessOutcomeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BusinessOutcomes to delete
     */
    where?: BusinessOutcomeWhereInput
    /**
     * Limit how many BusinessOutcomes to delete.
     */
    limit?: number
  }

  /**
   * BusinessOutcome without action
   */
  export type BusinessOutcomeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BusinessOutcome
     */
    select?: BusinessOutcomeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BusinessOutcome
     */
    omit?: BusinessOutcomeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BusinessOutcomeInclude<ExtArgs> | null
  }


  /**
   * Model Improvement
   */

  export type AggregateImprovement = {
    _count: ImprovementCountAggregateOutputType | null
    _avg: ImprovementAvgAggregateOutputType | null
    _sum: ImprovementSumAggregateOutputType | null
    _min: ImprovementMinAggregateOutputType | null
    _max: ImprovementMaxAggregateOutputType | null
  }

  export type ImprovementAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ImprovementSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type ImprovementMinAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ImprovementMaxAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type ImprovementCountAggregateOutputType = {
    id: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type ImprovementAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ImprovementSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type ImprovementMinAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ImprovementMaxAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type ImprovementCountAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type ImprovementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Improvement to aggregate.
     */
    where?: ImprovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Improvements to fetch.
     */
    orderBy?: ImprovementOrderByWithRelationInput | ImprovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImprovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Improvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Improvements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Improvements
    **/
    _count?: true | ImprovementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ImprovementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ImprovementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImprovementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImprovementMaxAggregateInputType
  }

  export type GetImprovementAggregateType<T extends ImprovementAggregateArgs> = {
        [P in keyof T & keyof AggregateImprovement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImprovement[P]>
      : GetScalarType<T[P], AggregateImprovement[P]>
  }




  export type ImprovementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImprovementWhereInput
    orderBy?: ImprovementOrderByWithAggregationInput | ImprovementOrderByWithAggregationInput[]
    by: ImprovementScalarFieldEnum[] | ImprovementScalarFieldEnum
    having?: ImprovementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImprovementCountAggregateInputType | true
    _avg?: ImprovementAvgAggregateInputType
    _sum?: ImprovementSumAggregateInputType
    _min?: ImprovementMinAggregateInputType
    _max?: ImprovementMaxAggregateInputType
  }

  export type ImprovementGroupByOutputType = {
    id: number
    description: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: ImprovementCountAggregateOutputType | null
    _avg: ImprovementAvgAggregateOutputType | null
    _sum: ImprovementSumAggregateOutputType | null
    _min: ImprovementMinAggregateOutputType | null
    _max: ImprovementMaxAggregateOutputType | null
  }

  type GetImprovementGroupByPayload<T extends ImprovementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImprovementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImprovementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImprovementGroupByOutputType[P]>
            : GetScalarType<T[P], ImprovementGroupByOutputType[P]>
        }
      >
    >


  export type ImprovementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["improvement"]>

  export type ImprovementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["improvement"]>

  export type ImprovementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["improvement"]>

  export type ImprovementSelectScalar = {
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type ImprovementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["improvement"]>
  export type ImprovementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ImprovementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type ImprovementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $ImprovementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Improvement"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["improvement"]>
    composites: {}
  }

  type ImprovementGetPayload<S extends boolean | null | undefined | ImprovementDefaultArgs> = $Result.GetResult<Prisma.$ImprovementPayload, S>

  type ImprovementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImprovementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImprovementCountAggregateInputType | true
    }

  export interface ImprovementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Improvement'], meta: { name: 'Improvement' } }
    /**
     * Find zero or one Improvement that matches the filter.
     * @param {ImprovementFindUniqueArgs} args - Arguments to find a Improvement
     * @example
     * // Get one Improvement
     * const improvement = await prisma.improvement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImprovementFindUniqueArgs>(args: SelectSubset<T, ImprovementFindUniqueArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Improvement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImprovementFindUniqueOrThrowArgs} args - Arguments to find a Improvement
     * @example
     * // Get one Improvement
     * const improvement = await prisma.improvement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImprovementFindUniqueOrThrowArgs>(args: SelectSubset<T, ImprovementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Improvement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementFindFirstArgs} args - Arguments to find a Improvement
     * @example
     * // Get one Improvement
     * const improvement = await prisma.improvement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImprovementFindFirstArgs>(args?: SelectSubset<T, ImprovementFindFirstArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Improvement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementFindFirstOrThrowArgs} args - Arguments to find a Improvement
     * @example
     * // Get one Improvement
     * const improvement = await prisma.improvement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImprovementFindFirstOrThrowArgs>(args?: SelectSubset<T, ImprovementFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Improvements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Improvements
     * const improvements = await prisma.improvement.findMany()
     * 
     * // Get first 10 Improvements
     * const improvements = await prisma.improvement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const improvementWithIdOnly = await prisma.improvement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ImprovementFindManyArgs>(args?: SelectSubset<T, ImprovementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Improvement.
     * @param {ImprovementCreateArgs} args - Arguments to create a Improvement.
     * @example
     * // Create one Improvement
     * const Improvement = await prisma.improvement.create({
     *   data: {
     *     // ... data to create a Improvement
     *   }
     * })
     * 
     */
    create<T extends ImprovementCreateArgs>(args: SelectSubset<T, ImprovementCreateArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Improvements.
     * @param {ImprovementCreateManyArgs} args - Arguments to create many Improvements.
     * @example
     * // Create many Improvements
     * const improvement = await prisma.improvement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImprovementCreateManyArgs>(args?: SelectSubset<T, ImprovementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Improvements and returns the data saved in the database.
     * @param {ImprovementCreateManyAndReturnArgs} args - Arguments to create many Improvements.
     * @example
     * // Create many Improvements
     * const improvement = await prisma.improvement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Improvements and only return the `id`
     * const improvementWithIdOnly = await prisma.improvement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImprovementCreateManyAndReturnArgs>(args?: SelectSubset<T, ImprovementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Improvement.
     * @param {ImprovementDeleteArgs} args - Arguments to delete one Improvement.
     * @example
     * // Delete one Improvement
     * const Improvement = await prisma.improvement.delete({
     *   where: {
     *     // ... filter to delete one Improvement
     *   }
     * })
     * 
     */
    delete<T extends ImprovementDeleteArgs>(args: SelectSubset<T, ImprovementDeleteArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Improvement.
     * @param {ImprovementUpdateArgs} args - Arguments to update one Improvement.
     * @example
     * // Update one Improvement
     * const improvement = await prisma.improvement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImprovementUpdateArgs>(args: SelectSubset<T, ImprovementUpdateArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Improvements.
     * @param {ImprovementDeleteManyArgs} args - Arguments to filter Improvements to delete.
     * @example
     * // Delete a few Improvements
     * const { count } = await prisma.improvement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImprovementDeleteManyArgs>(args?: SelectSubset<T, ImprovementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Improvements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Improvements
     * const improvement = await prisma.improvement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImprovementUpdateManyArgs>(args: SelectSubset<T, ImprovementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Improvements and returns the data updated in the database.
     * @param {ImprovementUpdateManyAndReturnArgs} args - Arguments to update many Improvements.
     * @example
     * // Update many Improvements
     * const improvement = await prisma.improvement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Improvements and only return the `id`
     * const improvementWithIdOnly = await prisma.improvement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImprovementUpdateManyAndReturnArgs>(args: SelectSubset<T, ImprovementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Improvement.
     * @param {ImprovementUpsertArgs} args - Arguments to update or create a Improvement.
     * @example
     * // Update or create a Improvement
     * const improvement = await prisma.improvement.upsert({
     *   create: {
     *     // ... data to create a Improvement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Improvement we want to update
     *   }
     * })
     */
    upsert<T extends ImprovementUpsertArgs>(args: SelectSubset<T, ImprovementUpsertArgs<ExtArgs>>): Prisma__ImprovementClient<$Result.GetResult<Prisma.$ImprovementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Improvements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementCountArgs} args - Arguments to filter Improvements to count.
     * @example
     * // Count the number of Improvements
     * const count = await prisma.improvement.count({
     *   where: {
     *     // ... the filter for the Improvements we want to count
     *   }
     * })
    **/
    count<T extends ImprovementCountArgs>(
      args?: Subset<T, ImprovementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImprovementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Improvement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImprovementAggregateArgs>(args: Subset<T, ImprovementAggregateArgs>): Prisma.PrismaPromise<GetImprovementAggregateType<T>>

    /**
     * Group by Improvement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImprovementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImprovementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImprovementGroupByArgs['orderBy'] }
        : { orderBy?: ImprovementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImprovementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImprovementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Improvement model
   */
  readonly fields: ImprovementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Improvement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImprovementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Improvement model
   */
  interface ImprovementFieldRefs {
    readonly id: FieldRef<"Improvement", 'Int'>
    readonly description: FieldRef<"Improvement", 'String'>
    readonly createdAt: FieldRef<"Improvement", 'DateTime'>
    readonly updatedAt: FieldRef<"Improvement", 'DateTime'>
    readonly projectId: FieldRef<"Improvement", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Improvement findUnique
   */
  export type ImprovementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * Filter, which Improvement to fetch.
     */
    where: ImprovementWhereUniqueInput
  }

  /**
   * Improvement findUniqueOrThrow
   */
  export type ImprovementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * Filter, which Improvement to fetch.
     */
    where: ImprovementWhereUniqueInput
  }

  /**
   * Improvement findFirst
   */
  export type ImprovementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * Filter, which Improvement to fetch.
     */
    where?: ImprovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Improvements to fetch.
     */
    orderBy?: ImprovementOrderByWithRelationInput | ImprovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Improvements.
     */
    cursor?: ImprovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Improvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Improvements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Improvements.
     */
    distinct?: ImprovementScalarFieldEnum | ImprovementScalarFieldEnum[]
  }

  /**
   * Improvement findFirstOrThrow
   */
  export type ImprovementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * Filter, which Improvement to fetch.
     */
    where?: ImprovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Improvements to fetch.
     */
    orderBy?: ImprovementOrderByWithRelationInput | ImprovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Improvements.
     */
    cursor?: ImprovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Improvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Improvements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Improvements.
     */
    distinct?: ImprovementScalarFieldEnum | ImprovementScalarFieldEnum[]
  }

  /**
   * Improvement findMany
   */
  export type ImprovementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * Filter, which Improvements to fetch.
     */
    where?: ImprovementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Improvements to fetch.
     */
    orderBy?: ImprovementOrderByWithRelationInput | ImprovementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Improvements.
     */
    cursor?: ImprovementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Improvements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Improvements.
     */
    skip?: number
    distinct?: ImprovementScalarFieldEnum | ImprovementScalarFieldEnum[]
  }

  /**
   * Improvement create
   */
  export type ImprovementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * The data needed to create a Improvement.
     */
    data: XOR<ImprovementCreateInput, ImprovementUncheckedCreateInput>
  }

  /**
   * Improvement createMany
   */
  export type ImprovementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Improvements.
     */
    data: ImprovementCreateManyInput | ImprovementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Improvement createManyAndReturn
   */
  export type ImprovementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * The data used to create many Improvements.
     */
    data: ImprovementCreateManyInput | ImprovementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Improvement update
   */
  export type ImprovementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * The data needed to update a Improvement.
     */
    data: XOR<ImprovementUpdateInput, ImprovementUncheckedUpdateInput>
    /**
     * Choose, which Improvement to update.
     */
    where: ImprovementWhereUniqueInput
  }

  /**
   * Improvement updateMany
   */
  export type ImprovementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Improvements.
     */
    data: XOR<ImprovementUpdateManyMutationInput, ImprovementUncheckedUpdateManyInput>
    /**
     * Filter which Improvements to update
     */
    where?: ImprovementWhereInput
    /**
     * Limit how many Improvements to update.
     */
    limit?: number
  }

  /**
   * Improvement updateManyAndReturn
   */
  export type ImprovementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * The data used to update Improvements.
     */
    data: XOR<ImprovementUpdateManyMutationInput, ImprovementUncheckedUpdateManyInput>
    /**
     * Filter which Improvements to update
     */
    where?: ImprovementWhereInput
    /**
     * Limit how many Improvements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Improvement upsert
   */
  export type ImprovementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * The filter to search for the Improvement to update in case it exists.
     */
    where: ImprovementWhereUniqueInput
    /**
     * In case the Improvement found by the `where` argument doesn't exist, create a new Improvement with this data.
     */
    create: XOR<ImprovementCreateInput, ImprovementUncheckedCreateInput>
    /**
     * In case the Improvement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImprovementUpdateInput, ImprovementUncheckedUpdateInput>
  }

  /**
   * Improvement delete
   */
  export type ImprovementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
    /**
     * Filter which Improvement to delete.
     */
    where: ImprovementWhereUniqueInput
  }

  /**
   * Improvement deleteMany
   */
  export type ImprovementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Improvements to delete
     */
    where?: ImprovementWhereInput
    /**
     * Limit how many Improvements to delete.
     */
    limit?: number
  }

  /**
   * Improvement without action
   */
  export type ImprovementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Improvement
     */
    select?: ImprovementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Improvement
     */
    omit?: ImprovementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImprovementInclude<ExtArgs> | null
  }


  /**
   * Model NextStep
   */

  export type AggregateNextStep = {
    _count: NextStepCountAggregateOutputType | null
    _avg: NextStepAvgAggregateOutputType | null
    _sum: NextStepSumAggregateOutputType | null
    _min: NextStepMinAggregateOutputType | null
    _max: NextStepMaxAggregateOutputType | null
  }

  export type NextStepAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type NextStepSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type NextStepMinAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type NextStepMaxAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type NextStepCountAggregateOutputType = {
    id: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type NextStepAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type NextStepSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type NextStepMinAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type NextStepMaxAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type NextStepCountAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type NextStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NextStep to aggregate.
     */
    where?: NextStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NextSteps to fetch.
     */
    orderBy?: NextStepOrderByWithRelationInput | NextStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NextStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NextSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NextSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NextSteps
    **/
    _count?: true | NextStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NextStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NextStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NextStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NextStepMaxAggregateInputType
  }

  export type GetNextStepAggregateType<T extends NextStepAggregateArgs> = {
        [P in keyof T & keyof AggregateNextStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNextStep[P]>
      : GetScalarType<T[P], AggregateNextStep[P]>
  }




  export type NextStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NextStepWhereInput
    orderBy?: NextStepOrderByWithAggregationInput | NextStepOrderByWithAggregationInput[]
    by: NextStepScalarFieldEnum[] | NextStepScalarFieldEnum
    having?: NextStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NextStepCountAggregateInputType | true
    _avg?: NextStepAvgAggregateInputType
    _sum?: NextStepSumAggregateInputType
    _min?: NextStepMinAggregateInputType
    _max?: NextStepMaxAggregateInputType
  }

  export type NextStepGroupByOutputType = {
    id: number
    description: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: NextStepCountAggregateOutputType | null
    _avg: NextStepAvgAggregateOutputType | null
    _sum: NextStepSumAggregateOutputType | null
    _min: NextStepMinAggregateOutputType | null
    _max: NextStepMaxAggregateOutputType | null
  }

  type GetNextStepGroupByPayload<T extends NextStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NextStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NextStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NextStepGroupByOutputType[P]>
            : GetScalarType<T[P], NextStepGroupByOutputType[P]>
        }
      >
    >


  export type NextStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nextStep"]>

  export type NextStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nextStep"]>

  export type NextStepSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nextStep"]>

  export type NextStepSelectScalar = {
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type NextStepOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["nextStep"]>
  export type NextStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type NextStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type NextStepIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $NextStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NextStep"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["nextStep"]>
    composites: {}
  }

  type NextStepGetPayload<S extends boolean | null | undefined | NextStepDefaultArgs> = $Result.GetResult<Prisma.$NextStepPayload, S>

  type NextStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NextStepFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NextStepCountAggregateInputType | true
    }

  export interface NextStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NextStep'], meta: { name: 'NextStep' } }
    /**
     * Find zero or one NextStep that matches the filter.
     * @param {NextStepFindUniqueArgs} args - Arguments to find a NextStep
     * @example
     * // Get one NextStep
     * const nextStep = await prisma.nextStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NextStepFindUniqueArgs>(args: SelectSubset<T, NextStepFindUniqueArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NextStep that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NextStepFindUniqueOrThrowArgs} args - Arguments to find a NextStep
     * @example
     * // Get one NextStep
     * const nextStep = await prisma.nextStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NextStepFindUniqueOrThrowArgs>(args: SelectSubset<T, NextStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NextStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepFindFirstArgs} args - Arguments to find a NextStep
     * @example
     * // Get one NextStep
     * const nextStep = await prisma.nextStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NextStepFindFirstArgs>(args?: SelectSubset<T, NextStepFindFirstArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NextStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepFindFirstOrThrowArgs} args - Arguments to find a NextStep
     * @example
     * // Get one NextStep
     * const nextStep = await prisma.nextStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NextStepFindFirstOrThrowArgs>(args?: SelectSubset<T, NextStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NextSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NextSteps
     * const nextSteps = await prisma.nextStep.findMany()
     * 
     * // Get first 10 NextSteps
     * const nextSteps = await prisma.nextStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nextStepWithIdOnly = await prisma.nextStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NextStepFindManyArgs>(args?: SelectSubset<T, NextStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NextStep.
     * @param {NextStepCreateArgs} args - Arguments to create a NextStep.
     * @example
     * // Create one NextStep
     * const NextStep = await prisma.nextStep.create({
     *   data: {
     *     // ... data to create a NextStep
     *   }
     * })
     * 
     */
    create<T extends NextStepCreateArgs>(args: SelectSubset<T, NextStepCreateArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NextSteps.
     * @param {NextStepCreateManyArgs} args - Arguments to create many NextSteps.
     * @example
     * // Create many NextSteps
     * const nextStep = await prisma.nextStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NextStepCreateManyArgs>(args?: SelectSubset<T, NextStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NextSteps and returns the data saved in the database.
     * @param {NextStepCreateManyAndReturnArgs} args - Arguments to create many NextSteps.
     * @example
     * // Create many NextSteps
     * const nextStep = await prisma.nextStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NextSteps and only return the `id`
     * const nextStepWithIdOnly = await prisma.nextStep.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NextStepCreateManyAndReturnArgs>(args?: SelectSubset<T, NextStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NextStep.
     * @param {NextStepDeleteArgs} args - Arguments to delete one NextStep.
     * @example
     * // Delete one NextStep
     * const NextStep = await prisma.nextStep.delete({
     *   where: {
     *     // ... filter to delete one NextStep
     *   }
     * })
     * 
     */
    delete<T extends NextStepDeleteArgs>(args: SelectSubset<T, NextStepDeleteArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NextStep.
     * @param {NextStepUpdateArgs} args - Arguments to update one NextStep.
     * @example
     * // Update one NextStep
     * const nextStep = await prisma.nextStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NextStepUpdateArgs>(args: SelectSubset<T, NextStepUpdateArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NextSteps.
     * @param {NextStepDeleteManyArgs} args - Arguments to filter NextSteps to delete.
     * @example
     * // Delete a few NextSteps
     * const { count } = await prisma.nextStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NextStepDeleteManyArgs>(args?: SelectSubset<T, NextStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NextSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NextSteps
     * const nextStep = await prisma.nextStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NextStepUpdateManyArgs>(args: SelectSubset<T, NextStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NextSteps and returns the data updated in the database.
     * @param {NextStepUpdateManyAndReturnArgs} args - Arguments to update many NextSteps.
     * @example
     * // Update many NextSteps
     * const nextStep = await prisma.nextStep.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NextSteps and only return the `id`
     * const nextStepWithIdOnly = await prisma.nextStep.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NextStepUpdateManyAndReturnArgs>(args: SelectSubset<T, NextStepUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NextStep.
     * @param {NextStepUpsertArgs} args - Arguments to update or create a NextStep.
     * @example
     * // Update or create a NextStep
     * const nextStep = await prisma.nextStep.upsert({
     *   create: {
     *     // ... data to create a NextStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NextStep we want to update
     *   }
     * })
     */
    upsert<T extends NextStepUpsertArgs>(args: SelectSubset<T, NextStepUpsertArgs<ExtArgs>>): Prisma__NextStepClient<$Result.GetResult<Prisma.$NextStepPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NextSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepCountArgs} args - Arguments to filter NextSteps to count.
     * @example
     * // Count the number of NextSteps
     * const count = await prisma.nextStep.count({
     *   where: {
     *     // ... the filter for the NextSteps we want to count
     *   }
     * })
    **/
    count<T extends NextStepCountArgs>(
      args?: Subset<T, NextStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NextStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NextStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NextStepAggregateArgs>(args: Subset<T, NextStepAggregateArgs>): Prisma.PrismaPromise<GetNextStepAggregateType<T>>

    /**
     * Group by NextStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NextStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NextStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NextStepGroupByArgs['orderBy'] }
        : { orderBy?: NextStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NextStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNextStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NextStep model
   */
  readonly fields: NextStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NextStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NextStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NextStep model
   */
  interface NextStepFieldRefs {
    readonly id: FieldRef<"NextStep", 'Int'>
    readonly description: FieldRef<"NextStep", 'String'>
    readonly createdAt: FieldRef<"NextStep", 'DateTime'>
    readonly updatedAt: FieldRef<"NextStep", 'DateTime'>
    readonly projectId: FieldRef<"NextStep", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * NextStep findUnique
   */
  export type NextStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * Filter, which NextStep to fetch.
     */
    where: NextStepWhereUniqueInput
  }

  /**
   * NextStep findUniqueOrThrow
   */
  export type NextStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * Filter, which NextStep to fetch.
     */
    where: NextStepWhereUniqueInput
  }

  /**
   * NextStep findFirst
   */
  export type NextStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * Filter, which NextStep to fetch.
     */
    where?: NextStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NextSteps to fetch.
     */
    orderBy?: NextStepOrderByWithRelationInput | NextStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NextSteps.
     */
    cursor?: NextStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NextSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NextSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NextSteps.
     */
    distinct?: NextStepScalarFieldEnum | NextStepScalarFieldEnum[]
  }

  /**
   * NextStep findFirstOrThrow
   */
  export type NextStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * Filter, which NextStep to fetch.
     */
    where?: NextStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NextSteps to fetch.
     */
    orderBy?: NextStepOrderByWithRelationInput | NextStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NextSteps.
     */
    cursor?: NextStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NextSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NextSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NextSteps.
     */
    distinct?: NextStepScalarFieldEnum | NextStepScalarFieldEnum[]
  }

  /**
   * NextStep findMany
   */
  export type NextStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * Filter, which NextSteps to fetch.
     */
    where?: NextStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NextSteps to fetch.
     */
    orderBy?: NextStepOrderByWithRelationInput | NextStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NextSteps.
     */
    cursor?: NextStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NextSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NextSteps.
     */
    skip?: number
    distinct?: NextStepScalarFieldEnum | NextStepScalarFieldEnum[]
  }

  /**
   * NextStep create
   */
  export type NextStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * The data needed to create a NextStep.
     */
    data: XOR<NextStepCreateInput, NextStepUncheckedCreateInput>
  }

  /**
   * NextStep createMany
   */
  export type NextStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NextSteps.
     */
    data: NextStepCreateManyInput | NextStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NextStep createManyAndReturn
   */
  export type NextStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * The data used to create many NextSteps.
     */
    data: NextStepCreateManyInput | NextStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NextStep update
   */
  export type NextStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * The data needed to update a NextStep.
     */
    data: XOR<NextStepUpdateInput, NextStepUncheckedUpdateInput>
    /**
     * Choose, which NextStep to update.
     */
    where: NextStepWhereUniqueInput
  }

  /**
   * NextStep updateMany
   */
  export type NextStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NextSteps.
     */
    data: XOR<NextStepUpdateManyMutationInput, NextStepUncheckedUpdateManyInput>
    /**
     * Filter which NextSteps to update
     */
    where?: NextStepWhereInput
    /**
     * Limit how many NextSteps to update.
     */
    limit?: number
  }

  /**
   * NextStep updateManyAndReturn
   */
  export type NextStepUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * The data used to update NextSteps.
     */
    data: XOR<NextStepUpdateManyMutationInput, NextStepUncheckedUpdateManyInput>
    /**
     * Filter which NextSteps to update
     */
    where?: NextStepWhereInput
    /**
     * Limit how many NextSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NextStep upsert
   */
  export type NextStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * The filter to search for the NextStep to update in case it exists.
     */
    where: NextStepWhereUniqueInput
    /**
     * In case the NextStep found by the `where` argument doesn't exist, create a new NextStep with this data.
     */
    create: XOR<NextStepCreateInput, NextStepUncheckedCreateInput>
    /**
     * In case the NextStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NextStepUpdateInput, NextStepUncheckedUpdateInput>
  }

  /**
   * NextStep delete
   */
  export type NextStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
    /**
     * Filter which NextStep to delete.
     */
    where: NextStepWhereUniqueInput
  }

  /**
   * NextStep deleteMany
   */
  export type NextStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NextSteps to delete
     */
    where?: NextStepWhereInput
    /**
     * Limit how many NextSteps to delete.
     */
    limit?: number
  }

  /**
   * NextStep without action
   */
  export type NextStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NextStep
     */
    select?: NextStepSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NextStep
     */
    omit?: NextStepOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NextStepInclude<ExtArgs> | null
  }


  /**
   * Model FutureTool
   */

  export type AggregateFutureTool = {
    _count: FutureToolCountAggregateOutputType | null
    _avg: FutureToolAvgAggregateOutputType | null
    _sum: FutureToolSumAggregateOutputType | null
    _min: FutureToolMinAggregateOutputType | null
    _max: FutureToolMaxAggregateOutputType | null
  }

  export type FutureToolAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type FutureToolSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type FutureToolMinAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type FutureToolMaxAggregateOutputType = {
    id: number | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type FutureToolCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type FutureToolAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type FutureToolSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type FutureToolMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type FutureToolMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type FutureToolCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type FutureToolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FutureTool to aggregate.
     */
    where?: FutureToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutureTools to fetch.
     */
    orderBy?: FutureToolOrderByWithRelationInput | FutureToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FutureToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutureTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutureTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FutureTools
    **/
    _count?: true | FutureToolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FutureToolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FutureToolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FutureToolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FutureToolMaxAggregateInputType
  }

  export type GetFutureToolAggregateType<T extends FutureToolAggregateArgs> = {
        [P in keyof T & keyof AggregateFutureTool]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFutureTool[P]>
      : GetScalarType<T[P], AggregateFutureTool[P]>
  }




  export type FutureToolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FutureToolWhereInput
    orderBy?: FutureToolOrderByWithAggregationInput | FutureToolOrderByWithAggregationInput[]
    by: FutureToolScalarFieldEnum[] | FutureToolScalarFieldEnum
    having?: FutureToolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FutureToolCountAggregateInputType | true
    _avg?: FutureToolAvgAggregateInputType
    _sum?: FutureToolSumAggregateInputType
    _min?: FutureToolMinAggregateInputType
    _max?: FutureToolMaxAggregateInputType
  }

  export type FutureToolGroupByOutputType = {
    id: number
    name: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: FutureToolCountAggregateOutputType | null
    _avg: FutureToolAvgAggregateOutputType | null
    _sum: FutureToolSumAggregateOutputType | null
    _min: FutureToolMinAggregateOutputType | null
    _max: FutureToolMaxAggregateOutputType | null
  }

  type GetFutureToolGroupByPayload<T extends FutureToolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FutureToolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FutureToolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FutureToolGroupByOutputType[P]>
            : GetScalarType<T[P], FutureToolGroupByOutputType[P]>
        }
      >
    >


  export type FutureToolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futureTool"]>

  export type FutureToolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futureTool"]>

  export type FutureToolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["futureTool"]>

  export type FutureToolSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type FutureToolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["futureTool"]>
  export type FutureToolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type FutureToolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type FutureToolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $FutureToolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FutureTool"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["futureTool"]>
    composites: {}
  }

  type FutureToolGetPayload<S extends boolean | null | undefined | FutureToolDefaultArgs> = $Result.GetResult<Prisma.$FutureToolPayload, S>

  type FutureToolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FutureToolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FutureToolCountAggregateInputType | true
    }

  export interface FutureToolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FutureTool'], meta: { name: 'FutureTool' } }
    /**
     * Find zero or one FutureTool that matches the filter.
     * @param {FutureToolFindUniqueArgs} args - Arguments to find a FutureTool
     * @example
     * // Get one FutureTool
     * const futureTool = await prisma.futureTool.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FutureToolFindUniqueArgs>(args: SelectSubset<T, FutureToolFindUniqueArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FutureTool that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FutureToolFindUniqueOrThrowArgs} args - Arguments to find a FutureTool
     * @example
     * // Get one FutureTool
     * const futureTool = await prisma.futureTool.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FutureToolFindUniqueOrThrowArgs>(args: SelectSubset<T, FutureToolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FutureTool that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolFindFirstArgs} args - Arguments to find a FutureTool
     * @example
     * // Get one FutureTool
     * const futureTool = await prisma.futureTool.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FutureToolFindFirstArgs>(args?: SelectSubset<T, FutureToolFindFirstArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FutureTool that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolFindFirstOrThrowArgs} args - Arguments to find a FutureTool
     * @example
     * // Get one FutureTool
     * const futureTool = await prisma.futureTool.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FutureToolFindFirstOrThrowArgs>(args?: SelectSubset<T, FutureToolFindFirstOrThrowArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FutureTools that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FutureTools
     * const futureTools = await prisma.futureTool.findMany()
     * 
     * // Get first 10 FutureTools
     * const futureTools = await prisma.futureTool.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const futureToolWithIdOnly = await prisma.futureTool.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FutureToolFindManyArgs>(args?: SelectSubset<T, FutureToolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FutureTool.
     * @param {FutureToolCreateArgs} args - Arguments to create a FutureTool.
     * @example
     * // Create one FutureTool
     * const FutureTool = await prisma.futureTool.create({
     *   data: {
     *     // ... data to create a FutureTool
     *   }
     * })
     * 
     */
    create<T extends FutureToolCreateArgs>(args: SelectSubset<T, FutureToolCreateArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FutureTools.
     * @param {FutureToolCreateManyArgs} args - Arguments to create many FutureTools.
     * @example
     * // Create many FutureTools
     * const futureTool = await prisma.futureTool.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FutureToolCreateManyArgs>(args?: SelectSubset<T, FutureToolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FutureTools and returns the data saved in the database.
     * @param {FutureToolCreateManyAndReturnArgs} args - Arguments to create many FutureTools.
     * @example
     * // Create many FutureTools
     * const futureTool = await prisma.futureTool.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FutureTools and only return the `id`
     * const futureToolWithIdOnly = await prisma.futureTool.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FutureToolCreateManyAndReturnArgs>(args?: SelectSubset<T, FutureToolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FutureTool.
     * @param {FutureToolDeleteArgs} args - Arguments to delete one FutureTool.
     * @example
     * // Delete one FutureTool
     * const FutureTool = await prisma.futureTool.delete({
     *   where: {
     *     // ... filter to delete one FutureTool
     *   }
     * })
     * 
     */
    delete<T extends FutureToolDeleteArgs>(args: SelectSubset<T, FutureToolDeleteArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FutureTool.
     * @param {FutureToolUpdateArgs} args - Arguments to update one FutureTool.
     * @example
     * // Update one FutureTool
     * const futureTool = await prisma.futureTool.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FutureToolUpdateArgs>(args: SelectSubset<T, FutureToolUpdateArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FutureTools.
     * @param {FutureToolDeleteManyArgs} args - Arguments to filter FutureTools to delete.
     * @example
     * // Delete a few FutureTools
     * const { count } = await prisma.futureTool.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FutureToolDeleteManyArgs>(args?: SelectSubset<T, FutureToolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FutureTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FutureTools
     * const futureTool = await prisma.futureTool.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FutureToolUpdateManyArgs>(args: SelectSubset<T, FutureToolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FutureTools and returns the data updated in the database.
     * @param {FutureToolUpdateManyAndReturnArgs} args - Arguments to update many FutureTools.
     * @example
     * // Update many FutureTools
     * const futureTool = await prisma.futureTool.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FutureTools and only return the `id`
     * const futureToolWithIdOnly = await prisma.futureTool.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FutureToolUpdateManyAndReturnArgs>(args: SelectSubset<T, FutureToolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FutureTool.
     * @param {FutureToolUpsertArgs} args - Arguments to update or create a FutureTool.
     * @example
     * // Update or create a FutureTool
     * const futureTool = await prisma.futureTool.upsert({
     *   create: {
     *     // ... data to create a FutureTool
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FutureTool we want to update
     *   }
     * })
     */
    upsert<T extends FutureToolUpsertArgs>(args: SelectSubset<T, FutureToolUpsertArgs<ExtArgs>>): Prisma__FutureToolClient<$Result.GetResult<Prisma.$FutureToolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FutureTools.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolCountArgs} args - Arguments to filter FutureTools to count.
     * @example
     * // Count the number of FutureTools
     * const count = await prisma.futureTool.count({
     *   where: {
     *     // ... the filter for the FutureTools we want to count
     *   }
     * })
    **/
    count<T extends FutureToolCountArgs>(
      args?: Subset<T, FutureToolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FutureToolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FutureTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FutureToolAggregateArgs>(args: Subset<T, FutureToolAggregateArgs>): Prisma.PrismaPromise<GetFutureToolAggregateType<T>>

    /**
     * Group by FutureTool.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FutureToolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FutureToolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FutureToolGroupByArgs['orderBy'] }
        : { orderBy?: FutureToolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FutureToolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFutureToolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FutureTool model
   */
  readonly fields: FutureToolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FutureTool.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FutureToolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FutureTool model
   */
  interface FutureToolFieldRefs {
    readonly id: FieldRef<"FutureTool", 'Int'>
    readonly name: FieldRef<"FutureTool", 'String'>
    readonly createdAt: FieldRef<"FutureTool", 'DateTime'>
    readonly updatedAt: FieldRef<"FutureTool", 'DateTime'>
    readonly projectId: FieldRef<"FutureTool", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FutureTool findUnique
   */
  export type FutureToolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * Filter, which FutureTool to fetch.
     */
    where: FutureToolWhereUniqueInput
  }

  /**
   * FutureTool findUniqueOrThrow
   */
  export type FutureToolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * Filter, which FutureTool to fetch.
     */
    where: FutureToolWhereUniqueInput
  }

  /**
   * FutureTool findFirst
   */
  export type FutureToolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * Filter, which FutureTool to fetch.
     */
    where?: FutureToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutureTools to fetch.
     */
    orderBy?: FutureToolOrderByWithRelationInput | FutureToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FutureTools.
     */
    cursor?: FutureToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutureTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutureTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FutureTools.
     */
    distinct?: FutureToolScalarFieldEnum | FutureToolScalarFieldEnum[]
  }

  /**
   * FutureTool findFirstOrThrow
   */
  export type FutureToolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * Filter, which FutureTool to fetch.
     */
    where?: FutureToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutureTools to fetch.
     */
    orderBy?: FutureToolOrderByWithRelationInput | FutureToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FutureTools.
     */
    cursor?: FutureToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutureTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutureTools.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FutureTools.
     */
    distinct?: FutureToolScalarFieldEnum | FutureToolScalarFieldEnum[]
  }

  /**
   * FutureTool findMany
   */
  export type FutureToolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * Filter, which FutureTools to fetch.
     */
    where?: FutureToolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FutureTools to fetch.
     */
    orderBy?: FutureToolOrderByWithRelationInput | FutureToolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FutureTools.
     */
    cursor?: FutureToolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FutureTools from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FutureTools.
     */
    skip?: number
    distinct?: FutureToolScalarFieldEnum | FutureToolScalarFieldEnum[]
  }

  /**
   * FutureTool create
   */
  export type FutureToolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * The data needed to create a FutureTool.
     */
    data: XOR<FutureToolCreateInput, FutureToolUncheckedCreateInput>
  }

  /**
   * FutureTool createMany
   */
  export type FutureToolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FutureTools.
     */
    data: FutureToolCreateManyInput | FutureToolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FutureTool createManyAndReturn
   */
  export type FutureToolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * The data used to create many FutureTools.
     */
    data: FutureToolCreateManyInput | FutureToolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FutureTool update
   */
  export type FutureToolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * The data needed to update a FutureTool.
     */
    data: XOR<FutureToolUpdateInput, FutureToolUncheckedUpdateInput>
    /**
     * Choose, which FutureTool to update.
     */
    where: FutureToolWhereUniqueInput
  }

  /**
   * FutureTool updateMany
   */
  export type FutureToolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FutureTools.
     */
    data: XOR<FutureToolUpdateManyMutationInput, FutureToolUncheckedUpdateManyInput>
    /**
     * Filter which FutureTools to update
     */
    where?: FutureToolWhereInput
    /**
     * Limit how many FutureTools to update.
     */
    limit?: number
  }

  /**
   * FutureTool updateManyAndReturn
   */
  export type FutureToolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * The data used to update FutureTools.
     */
    data: XOR<FutureToolUpdateManyMutationInput, FutureToolUncheckedUpdateManyInput>
    /**
     * Filter which FutureTools to update
     */
    where?: FutureToolWhereInput
    /**
     * Limit how many FutureTools to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FutureTool upsert
   */
  export type FutureToolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * The filter to search for the FutureTool to update in case it exists.
     */
    where: FutureToolWhereUniqueInput
    /**
     * In case the FutureTool found by the `where` argument doesn't exist, create a new FutureTool with this data.
     */
    create: XOR<FutureToolCreateInput, FutureToolUncheckedCreateInput>
    /**
     * In case the FutureTool was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FutureToolUpdateInput, FutureToolUncheckedUpdateInput>
  }

  /**
   * FutureTool delete
   */
  export type FutureToolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
    /**
     * Filter which FutureTool to delete.
     */
    where: FutureToolWhereUniqueInput
  }

  /**
   * FutureTool deleteMany
   */
  export type FutureToolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FutureTools to delete
     */
    where?: FutureToolWhereInput
    /**
     * Limit how many FutureTools to delete.
     */
    limit?: number
  }

  /**
   * FutureTool without action
   */
  export type FutureToolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FutureTool
     */
    select?: FutureToolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FutureTool
     */
    omit?: FutureToolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FutureToolInclude<ExtArgs> | null
  }


  /**
   * Model PerformanceMetric
   */

  export type AggregatePerformanceMetric = {
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  export type PerformanceMetricAvgAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PerformanceMetricSumAggregateOutputType = {
    id: number | null
    projectId: number | null
  }

  export type PerformanceMetricMinAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type PerformanceMetricMaxAggregateOutputType = {
    id: number | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
    projectId: number | null
  }

  export type PerformanceMetricCountAggregateOutputType = {
    id: number
    description: number
    createdAt: number
    updatedAt: number
    projectId: number
    _all: number
  }


  export type PerformanceMetricAvgAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PerformanceMetricSumAggregateInputType = {
    id?: true
    projectId?: true
  }

  export type PerformanceMetricMinAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type PerformanceMetricMaxAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
  }

  export type PerformanceMetricCountAggregateInputType = {
    id?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    projectId?: true
    _all?: true
  }

  export type PerformanceMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetric to aggregate.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PerformanceMetrics
    **/
    _count?: true | PerformanceMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PerformanceMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PerformanceMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PerformanceMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type GetPerformanceMetricAggregateType<T extends PerformanceMetricAggregateArgs> = {
        [P in keyof T & keyof AggregatePerformanceMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePerformanceMetric[P]>
      : GetScalarType<T[P], AggregatePerformanceMetric[P]>
  }




  export type PerformanceMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PerformanceMetricWhereInput
    orderBy?: PerformanceMetricOrderByWithAggregationInput | PerformanceMetricOrderByWithAggregationInput[]
    by: PerformanceMetricScalarFieldEnum[] | PerformanceMetricScalarFieldEnum
    having?: PerformanceMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PerformanceMetricCountAggregateInputType | true
    _avg?: PerformanceMetricAvgAggregateInputType
    _sum?: PerformanceMetricSumAggregateInputType
    _min?: PerformanceMetricMinAggregateInputType
    _max?: PerformanceMetricMaxAggregateInputType
  }

  export type PerformanceMetricGroupByOutputType = {
    id: number
    description: string
    createdAt: Date
    updatedAt: Date
    projectId: number
    _count: PerformanceMetricCountAggregateOutputType | null
    _avg: PerformanceMetricAvgAggregateOutputType | null
    _sum: PerformanceMetricSumAggregateOutputType | null
    _min: PerformanceMetricMinAggregateOutputType | null
    _max: PerformanceMetricMaxAggregateOutputType | null
  }

  type GetPerformanceMetricGroupByPayload<T extends PerformanceMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PerformanceMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PerformanceMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
            : GetScalarType<T[P], PerformanceMetricGroupByOutputType[P]>
        }
      >
    >


  export type PerformanceMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["performanceMetric"]>

  export type PerformanceMetricSelectScalar = {
    id?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    projectId?: boolean
  }

  export type PerformanceMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "createdAt" | "updatedAt" | "projectId", ExtArgs["result"]["performanceMetric"]>
  export type PerformanceMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PerformanceMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type PerformanceMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $PerformanceMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PerformanceMetric"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      createdAt: Date
      updatedAt: Date
      projectId: number
    }, ExtArgs["result"]["performanceMetric"]>
    composites: {}
  }

  type PerformanceMetricGetPayload<S extends boolean | null | undefined | PerformanceMetricDefaultArgs> = $Result.GetResult<Prisma.$PerformanceMetricPayload, S>

  type PerformanceMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PerformanceMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PerformanceMetricCountAggregateInputType | true
    }

  export interface PerformanceMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PerformanceMetric'], meta: { name: 'PerformanceMetric' } }
    /**
     * Find zero or one PerformanceMetric that matches the filter.
     * @param {PerformanceMetricFindUniqueArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PerformanceMetricFindUniqueArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PerformanceMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PerformanceMetricFindUniqueOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PerformanceMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, PerformanceMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PerformanceMetricFindFirstArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PerformanceMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindFirstOrThrowArgs} args - Arguments to find a PerformanceMetric
     * @example
     * // Get one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PerformanceMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, PerformanceMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PerformanceMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany()
     * 
     * // Get first 10 PerformanceMetrics
     * const performanceMetrics = await prisma.performanceMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PerformanceMetricFindManyArgs>(args?: SelectSubset<T, PerformanceMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PerformanceMetric.
     * @param {PerformanceMetricCreateArgs} args - Arguments to create a PerformanceMetric.
     * @example
     * // Create one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.create({
     *   data: {
     *     // ... data to create a PerformanceMetric
     *   }
     * })
     * 
     */
    create<T extends PerformanceMetricCreateArgs>(args: SelectSubset<T, PerformanceMetricCreateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PerformanceMetrics.
     * @param {PerformanceMetricCreateManyArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PerformanceMetricCreateManyArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PerformanceMetrics and returns the data saved in the database.
     * @param {PerformanceMetricCreateManyAndReturnArgs} args - Arguments to create many PerformanceMetrics.
     * @example
     * // Create many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PerformanceMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, PerformanceMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PerformanceMetric.
     * @param {PerformanceMetricDeleteArgs} args - Arguments to delete one PerformanceMetric.
     * @example
     * // Delete one PerformanceMetric
     * const PerformanceMetric = await prisma.performanceMetric.delete({
     *   where: {
     *     // ... filter to delete one PerformanceMetric
     *   }
     * })
     * 
     */
    delete<T extends PerformanceMetricDeleteArgs>(args: SelectSubset<T, PerformanceMetricDeleteArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PerformanceMetric.
     * @param {PerformanceMetricUpdateArgs} args - Arguments to update one PerformanceMetric.
     * @example
     * // Update one PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PerformanceMetricUpdateArgs>(args: SelectSubset<T, PerformanceMetricUpdateArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PerformanceMetrics.
     * @param {PerformanceMetricDeleteManyArgs} args - Arguments to filter PerformanceMetrics to delete.
     * @example
     * // Delete a few PerformanceMetrics
     * const { count } = await prisma.performanceMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PerformanceMetricDeleteManyArgs>(args?: SelectSubset<T, PerformanceMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PerformanceMetricUpdateManyArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PerformanceMetrics and returns the data updated in the database.
     * @param {PerformanceMetricUpdateManyAndReturnArgs} args - Arguments to update many PerformanceMetrics.
     * @example
     * // Update many PerformanceMetrics
     * const performanceMetric = await prisma.performanceMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PerformanceMetrics and only return the `id`
     * const performanceMetricWithIdOnly = await prisma.performanceMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PerformanceMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, PerformanceMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PerformanceMetric.
     * @param {PerformanceMetricUpsertArgs} args - Arguments to update or create a PerformanceMetric.
     * @example
     * // Update or create a PerformanceMetric
     * const performanceMetric = await prisma.performanceMetric.upsert({
     *   create: {
     *     // ... data to create a PerformanceMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PerformanceMetric we want to update
     *   }
     * })
     */
    upsert<T extends PerformanceMetricUpsertArgs>(args: SelectSubset<T, PerformanceMetricUpsertArgs<ExtArgs>>): Prisma__PerformanceMetricClient<$Result.GetResult<Prisma.$PerformanceMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PerformanceMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricCountArgs} args - Arguments to filter PerformanceMetrics to count.
     * @example
     * // Count the number of PerformanceMetrics
     * const count = await prisma.performanceMetric.count({
     *   where: {
     *     // ... the filter for the PerformanceMetrics we want to count
     *   }
     * })
    **/
    count<T extends PerformanceMetricCountArgs>(
      args?: Subset<T, PerformanceMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PerformanceMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PerformanceMetricAggregateArgs>(args: Subset<T, PerformanceMetricAggregateArgs>): Prisma.PrismaPromise<GetPerformanceMetricAggregateType<T>>

    /**
     * Group by PerformanceMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PerformanceMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PerformanceMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PerformanceMetricGroupByArgs['orderBy'] }
        : { orderBy?: PerformanceMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PerformanceMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPerformanceMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PerformanceMetric model
   */
  readonly fields: PerformanceMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PerformanceMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PerformanceMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PerformanceMetric model
   */
  interface PerformanceMetricFieldRefs {
    readonly id: FieldRef<"PerformanceMetric", 'Int'>
    readonly description: FieldRef<"PerformanceMetric", 'String'>
    readonly createdAt: FieldRef<"PerformanceMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"PerformanceMetric", 'DateTime'>
    readonly projectId: FieldRef<"PerformanceMetric", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PerformanceMetric findUnique
   */
  export type PerformanceMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findUniqueOrThrow
   */
  export type PerformanceMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric findFirst
   */
  export type PerformanceMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findFirstOrThrow
   */
  export type PerformanceMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetric to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PerformanceMetrics.
     */
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric findMany
   */
  export type PerformanceMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter, which PerformanceMetrics to fetch.
     */
    where?: PerformanceMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PerformanceMetrics to fetch.
     */
    orderBy?: PerformanceMetricOrderByWithRelationInput | PerformanceMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PerformanceMetrics.
     */
    cursor?: PerformanceMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PerformanceMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PerformanceMetrics.
     */
    skip?: number
    distinct?: PerformanceMetricScalarFieldEnum | PerformanceMetricScalarFieldEnum[]
  }

  /**
   * PerformanceMetric create
   */
  export type PerformanceMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a PerformanceMetric.
     */
    data: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
  }

  /**
   * PerformanceMetric createMany
   */
  export type PerformanceMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PerformanceMetric createManyAndReturn
   */
  export type PerformanceMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to create many PerformanceMetrics.
     */
    data: PerformanceMetricCreateManyInput | PerformanceMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceMetric update
   */
  export type PerformanceMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a PerformanceMetric.
     */
    data: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
    /**
     * Choose, which PerformanceMetric to update.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric updateMany
   */
  export type PerformanceMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
  }

  /**
   * PerformanceMetric updateManyAndReturn
   */
  export type PerformanceMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * The data used to update PerformanceMetrics.
     */
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyInput>
    /**
     * Filter which PerformanceMetrics to update
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PerformanceMetric upsert
   */
  export type PerformanceMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the PerformanceMetric to update in case it exists.
     */
    where: PerformanceMetricWhereUniqueInput
    /**
     * In case the PerformanceMetric found by the `where` argument doesn't exist, create a new PerformanceMetric with this data.
     */
    create: XOR<PerformanceMetricCreateInput, PerformanceMetricUncheckedCreateInput>
    /**
     * In case the PerformanceMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PerformanceMetricUpdateInput, PerformanceMetricUncheckedUpdateInput>
  }

  /**
   * PerformanceMetric delete
   */
  export type PerformanceMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
    /**
     * Filter which PerformanceMetric to delete.
     */
    where: PerformanceMetricWhereUniqueInput
  }

  /**
   * PerformanceMetric deleteMany
   */
  export type PerformanceMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PerformanceMetrics to delete
     */
    where?: PerformanceMetricWhereInput
    /**
     * Limit how many PerformanceMetrics to delete.
     */
    limit?: number
  }

  /**
   * PerformanceMetric without action
   */
  export type PerformanceMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PerformanceMetric
     */
    select?: PerformanceMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PerformanceMetric
     */
    omit?: PerformanceMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PerformanceMetricInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
  }


  /**
   * Model BlogPost
   */

  export type AggregateBlogPost = {
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  export type BlogPostAvgAggregateOutputType = {
    id: number | null
    readTime: number | null
    wordCount: number | null
    views: number | null
    categoryId: number | null
    seriesId: number | null
    seriesPart: number | null
  }

  export type BlogPostSumAggregateOutputType = {
    id: number | null
    readTime: number | null
    wordCount: number | null
    views: number | null
    categoryId: number | null
    seriesId: number | null
    seriesPart: number | null
  }

  export type BlogPostMinAggregateOutputType = {
    id: number | null
    slug: string | null
    title: string | null
    subtitle: string | null
    excerpt: string | null
    metaDescription: string | null
    socialImage: string | null
    readTime: number | null
    wordCount: number | null
    views: number | null
    heroImage: string | null
    heroImageAlt: string | null
    heroImageCaption: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: number | null
    seriesId: number | null
    seriesPart: number | null
  }

  export type BlogPostMaxAggregateOutputType = {
    id: number | null
    slug: string | null
    title: string | null
    subtitle: string | null
    excerpt: string | null
    metaDescription: string | null
    socialImage: string | null
    readTime: number | null
    wordCount: number | null
    views: number | null
    heroImage: string | null
    heroImageAlt: string | null
    heroImageCaption: string | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    categoryId: number | null
    seriesId: number | null
    seriesPart: number | null
  }

  export type BlogPostCountAggregateOutputType = {
    id: number
    slug: number
    title: number
    subtitle: number
    excerpt: number
    metaDescription: number
    socialImage: number
    readTime: number
    wordCount: number
    views: number
    heroImage: number
    heroImageAlt: number
    heroImageCaption: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    author: number
    categoryId: number
    seriesId: number
    seriesPart: number
    _all: number
  }


  export type BlogPostAvgAggregateInputType = {
    id?: true
    readTime?: true
    wordCount?: true
    views?: true
    categoryId?: true
    seriesId?: true
    seriesPart?: true
  }

  export type BlogPostSumAggregateInputType = {
    id?: true
    readTime?: true
    wordCount?: true
    views?: true
    categoryId?: true
    seriesId?: true
    seriesPart?: true
  }

  export type BlogPostMinAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    excerpt?: true
    metaDescription?: true
    socialImage?: true
    readTime?: true
    wordCount?: true
    views?: true
    heroImage?: true
    heroImageAlt?: true
    heroImageCaption?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    seriesId?: true
    seriesPart?: true
  }

  export type BlogPostMaxAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    excerpt?: true
    metaDescription?: true
    socialImage?: true
    readTime?: true
    wordCount?: true
    views?: true
    heroImage?: true
    heroImageAlt?: true
    heroImageCaption?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    categoryId?: true
    seriesId?: true
    seriesPart?: true
  }

  export type BlogPostCountAggregateInputType = {
    id?: true
    slug?: true
    title?: true
    subtitle?: true
    excerpt?: true
    metaDescription?: true
    socialImage?: true
    readTime?: true
    wordCount?: true
    views?: true
    heroImage?: true
    heroImageAlt?: true
    heroImageCaption?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    author?: true
    categoryId?: true
    seriesId?: true
    seriesPart?: true
    _all?: true
  }

  export type BlogPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPost to aggregate.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPosts
    **/
    _count?: true | BlogPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostMaxAggregateInputType
  }

  export type GetBlogPostAggregateType<T extends BlogPostAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPost[P]>
      : GetScalarType<T[P], AggregateBlogPost[P]>
  }




  export type BlogPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithAggregationInput | BlogPostOrderByWithAggregationInput[]
    by: BlogPostScalarFieldEnum[] | BlogPostScalarFieldEnum
    having?: BlogPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostCountAggregateInputType | true
    _avg?: BlogPostAvgAggregateInputType
    _sum?: BlogPostSumAggregateInputType
    _min?: BlogPostMinAggregateInputType
    _max?: BlogPostMaxAggregateInputType
  }

  export type BlogPostGroupByOutputType = {
    id: number
    slug: string
    title: string
    subtitle: string | null
    excerpt: string
    metaDescription: string
    socialImage: string | null
    readTime: number
    wordCount: number
    views: number
    heroImage: string | null
    heroImageAlt: string | null
    heroImageCaption: string | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    author: JsonValue
    categoryId: number | null
    seriesId: number | null
    seriesPart: number | null
    _count: BlogPostCountAggregateOutputType | null
    _avg: BlogPostAvgAggregateOutputType | null
    _sum: BlogPostSumAggregateOutputType | null
    _min: BlogPostMinAggregateOutputType | null
    _max: BlogPostMaxAggregateOutputType | null
  }

  type GetBlogPostGroupByPayload<T extends BlogPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    excerpt?: boolean
    metaDescription?: boolean
    socialImage?: boolean
    readTime?: boolean
    wordCount?: boolean
    views?: boolean
    heroImage?: boolean
    heroImageAlt?: boolean
    heroImageCaption?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean
    categoryId?: boolean
    seriesId?: boolean
    seriesPart?: boolean
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    series?: boolean | BlogPost$seriesArgs<ExtArgs>
    contentBlocks?: boolean | BlogPost$contentBlocksArgs<ExtArgs>
    blogPostTags?: boolean | BlogPost$blogPostTagsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    excerpt?: boolean
    metaDescription?: boolean
    socialImage?: boolean
    readTime?: boolean
    wordCount?: boolean
    views?: boolean
    heroImage?: boolean
    heroImageAlt?: boolean
    heroImageCaption?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean
    categoryId?: boolean
    seriesId?: boolean
    seriesPart?: boolean
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    series?: boolean | BlogPost$seriesArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    excerpt?: boolean
    metaDescription?: boolean
    socialImage?: boolean
    readTime?: boolean
    wordCount?: boolean
    views?: boolean
    heroImage?: boolean
    heroImageAlt?: boolean
    heroImageCaption?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean
    categoryId?: boolean
    seriesId?: boolean
    seriesPart?: boolean
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    series?: boolean | BlogPost$seriesArgs<ExtArgs>
  }, ExtArgs["result"]["blogPost"]>

  export type BlogPostSelectScalar = {
    id?: boolean
    slug?: boolean
    title?: boolean
    subtitle?: boolean
    excerpt?: boolean
    metaDescription?: boolean
    socialImage?: boolean
    readTime?: boolean
    wordCount?: boolean
    views?: boolean
    heroImage?: boolean
    heroImageAlt?: boolean
    heroImageCaption?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean
    categoryId?: boolean
    seriesId?: boolean
    seriesPart?: boolean
  }

  export type BlogPostOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "title" | "subtitle" | "excerpt" | "metaDescription" | "socialImage" | "readTime" | "wordCount" | "views" | "heroImage" | "heroImageAlt" | "heroImageCaption" | "publishedAt" | "createdAt" | "updatedAt" | "author" | "categoryId" | "seriesId" | "seriesPart", ExtArgs["result"]["blogPost"]>
  export type BlogPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    series?: boolean | BlogPost$seriesArgs<ExtArgs>
    contentBlocks?: boolean | BlogPost$contentBlocksArgs<ExtArgs>
    blogPostTags?: boolean | BlogPost$blogPostTagsArgs<ExtArgs>
    _count?: boolean | BlogPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    series?: boolean | BlogPost$seriesArgs<ExtArgs>
  }
  export type BlogPostIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | BlogPost$categoryArgs<ExtArgs>
    series?: boolean | BlogPost$seriesArgs<ExtArgs>
  }

  export type $BlogPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPost"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs> | null
      series: Prisma.$SeriesPayload<ExtArgs> | null
      contentBlocks: Prisma.$ContentBlockPayload<ExtArgs>[]
      blogPostTags: Prisma.$BlogPostTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      slug: string
      title: string
      subtitle: string | null
      excerpt: string
      metaDescription: string
      socialImage: string | null
      readTime: number
      wordCount: number
      views: number
      heroImage: string | null
      heroImageAlt: string | null
      heroImageCaption: string | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
      author: Prisma.JsonValue
      categoryId: number | null
      seriesId: number | null
      seriesPart: number | null
    }, ExtArgs["result"]["blogPost"]>
    composites: {}
  }

  type BlogPostGetPayload<S extends boolean | null | undefined | BlogPostDefaultArgs> = $Result.GetResult<Prisma.$BlogPostPayload, S>

  type BlogPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostCountAggregateInputType | true
    }

  export interface BlogPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPost'], meta: { name: 'BlogPost' } }
    /**
     * Find zero or one BlogPost that matches the filter.
     * @param {BlogPostFindUniqueArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostFindUniqueArgs>(args: SelectSubset<T, BlogPostFindUniqueArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPost that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostFindUniqueOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostFindFirstArgs>(args?: SelectSubset<T, BlogPostFindFirstArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindFirstOrThrowArgs} args - Arguments to find a BlogPost
     * @example
     * // Get one BlogPost
     * const blogPost = await prisma.blogPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPosts
     * const blogPosts = await prisma.blogPost.findMany()
     * 
     * // Get first 10 BlogPosts
     * const blogPosts = await prisma.blogPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostFindManyArgs>(args?: SelectSubset<T, BlogPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPost.
     * @param {BlogPostCreateArgs} args - Arguments to create a BlogPost.
     * @example
     * // Create one BlogPost
     * const BlogPost = await prisma.blogPost.create({
     *   data: {
     *     // ... data to create a BlogPost
     *   }
     * })
     * 
     */
    create<T extends BlogPostCreateArgs>(args: SelectSubset<T, BlogPostCreateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPosts.
     * @param {BlogPostCreateManyArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostCreateManyArgs>(args?: SelectSubset<T, BlogPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPosts and returns the data saved in the database.
     * @param {BlogPostCreateManyAndReturnArgs} args - Arguments to create many BlogPosts.
     * @example
     * // Create many BlogPosts
     * const blogPost = await prisma.blogPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPost.
     * @param {BlogPostDeleteArgs} args - Arguments to delete one BlogPost.
     * @example
     * // Delete one BlogPost
     * const BlogPost = await prisma.blogPost.delete({
     *   where: {
     *     // ... filter to delete one BlogPost
     *   }
     * })
     * 
     */
    delete<T extends BlogPostDeleteArgs>(args: SelectSubset<T, BlogPostDeleteArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPost.
     * @param {BlogPostUpdateArgs} args - Arguments to update one BlogPost.
     * @example
     * // Update one BlogPost
     * const blogPost = await prisma.blogPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostUpdateArgs>(args: SelectSubset<T, BlogPostUpdateArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPosts.
     * @param {BlogPostDeleteManyArgs} args - Arguments to filter BlogPosts to delete.
     * @example
     * // Delete a few BlogPosts
     * const { count } = await prisma.blogPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostDeleteManyArgs>(args?: SelectSubset<T, BlogPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostUpdateManyArgs>(args: SelectSubset<T, BlogPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPosts and returns the data updated in the database.
     * @param {BlogPostUpdateManyAndReturnArgs} args - Arguments to update many BlogPosts.
     * @example
     * // Update many BlogPosts
     * const blogPost = await prisma.blogPost.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPosts and only return the `id`
     * const blogPostWithIdOnly = await prisma.blogPost.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPost.
     * @param {BlogPostUpsertArgs} args - Arguments to update or create a BlogPost.
     * @example
     * // Update or create a BlogPost
     * const blogPost = await prisma.blogPost.upsert({
     *   create: {
     *     // ... data to create a BlogPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPost we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostUpsertArgs>(args: SelectSubset<T, BlogPostUpsertArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostCountArgs} args - Arguments to filter BlogPosts to count.
     * @example
     * // Count the number of BlogPosts
     * const count = await prisma.blogPost.count({
     *   where: {
     *     // ... the filter for the BlogPosts we want to count
     *   }
     * })
    **/
    count<T extends BlogPostCountArgs>(
      args?: Subset<T, BlogPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostAggregateArgs>(args: Subset<T, BlogPostAggregateArgs>): Prisma.PrismaPromise<GetBlogPostAggregateType<T>>

    /**
     * Group by BlogPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPost model
   */
  readonly fields: BlogPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends BlogPost$categoryArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$categoryArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    series<T extends BlogPost$seriesArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$seriesArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    contentBlocks<T extends BlogPost$contentBlocksArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$contentBlocksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    blogPostTags<T extends BlogPost$blogPostTagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogPost$blogPostTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPost model
   */
  interface BlogPostFieldRefs {
    readonly id: FieldRef<"BlogPost", 'Int'>
    readonly slug: FieldRef<"BlogPost", 'String'>
    readonly title: FieldRef<"BlogPost", 'String'>
    readonly subtitle: FieldRef<"BlogPost", 'String'>
    readonly excerpt: FieldRef<"BlogPost", 'String'>
    readonly metaDescription: FieldRef<"BlogPost", 'String'>
    readonly socialImage: FieldRef<"BlogPost", 'String'>
    readonly readTime: FieldRef<"BlogPost", 'Int'>
    readonly wordCount: FieldRef<"BlogPost", 'Int'>
    readonly views: FieldRef<"BlogPost", 'Int'>
    readonly heroImage: FieldRef<"BlogPost", 'String'>
    readonly heroImageAlt: FieldRef<"BlogPost", 'String'>
    readonly heroImageCaption: FieldRef<"BlogPost", 'String'>
    readonly publishedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly createdAt: FieldRef<"BlogPost", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogPost", 'DateTime'>
    readonly author: FieldRef<"BlogPost", 'Json'>
    readonly categoryId: FieldRef<"BlogPost", 'Int'>
    readonly seriesId: FieldRef<"BlogPost", 'Int'>
    readonly seriesPart: FieldRef<"BlogPost", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BlogPost findUnique
   */
  export type BlogPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findUniqueOrThrow
   */
  export type BlogPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost findFirst
   */
  export type BlogPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findFirstOrThrow
   */
  export type BlogPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPost to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPosts.
     */
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost findMany
   */
  export type BlogPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter, which BlogPosts to fetch.
     */
    where?: BlogPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPosts to fetch.
     */
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPosts.
     */
    cursor?: BlogPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPosts.
     */
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * BlogPost create
   */
  export type BlogPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPost.
     */
    data: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
  }

  /**
   * BlogPost createMany
   */
  export type BlogPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPost createManyAndReturn
   */
  export type BlogPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPosts.
     */
    data: BlogPostCreateManyInput | BlogPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost update
   */
  export type BlogPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPost.
     */
    data: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
    /**
     * Choose, which BlogPost to update.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost updateMany
   */
  export type BlogPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
  }

  /**
   * BlogPost updateManyAndReturn
   */
  export type BlogPostUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * The data used to update BlogPosts.
     */
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyInput>
    /**
     * Filter which BlogPosts to update
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPost upsert
   */
  export type BlogPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPost to update in case it exists.
     */
    where: BlogPostWhereUniqueInput
    /**
     * In case the BlogPost found by the `where` argument doesn't exist, create a new BlogPost with this data.
     */
    create: XOR<BlogPostCreateInput, BlogPostUncheckedCreateInput>
    /**
     * In case the BlogPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostUpdateInput, BlogPostUncheckedUpdateInput>
  }

  /**
   * BlogPost delete
   */
  export type BlogPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    /**
     * Filter which BlogPost to delete.
     */
    where: BlogPostWhereUniqueInput
  }

  /**
   * BlogPost deleteMany
   */
  export type BlogPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPosts to delete
     */
    where?: BlogPostWhereInput
    /**
     * Limit how many BlogPosts to delete.
     */
    limit?: number
  }

  /**
   * BlogPost.category
   */
  export type BlogPost$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    where?: CategoryWhereInput
  }

  /**
   * BlogPost.series
   */
  export type BlogPost$seriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    where?: SeriesWhereInput
  }

  /**
   * BlogPost.contentBlocks
   */
  export type BlogPost$contentBlocksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    where?: ContentBlockWhereInput
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    cursor?: ContentBlockWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * BlogPost.blogPostTags
   */
  export type BlogPost$blogPostTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    where?: BlogPostTagWhereInput
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    cursor?: BlogPostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPost without action
   */
  export type BlogPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blogPosts?: boolean | Category$blogPostsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>

  export type CategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["category"]>

  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["category"]>
  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | Category$blogPostsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {CategoryCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {CategoryUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoryWithIdOnly = await prisma.category.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPosts<T extends Category$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, Category$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
    readonly slug: FieldRef<"Category", 'String'>
    readonly createdAt: FieldRef<"Category", 'DateTime'>
    readonly updatedAt: FieldRef<"Category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category createManyAndReturn
   */
  export type CategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category updateManyAndReturn
   */
  export type CategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to update.
     */
    limit?: number
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
    /**
     * Limit how many Categories to delete.
     */
    limit?: number
  }

  /**
   * Category.blogPosts
   */
  export type Category$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Category
     */
    omit?: CategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model Series
   */

  export type AggregateSeries = {
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  export type SeriesAvgAggregateOutputType = {
    id: number | null
    totalParts: number | null
  }

  export type SeriesSumAggregateOutputType = {
    id: number | null
    totalParts: number | null
  }

  export type SeriesMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    totalParts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeriesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    description: string | null
    totalParts: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SeriesCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    totalParts: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SeriesAvgAggregateInputType = {
    id?: true
    totalParts?: true
  }

  export type SeriesSumAggregateInputType = {
    id?: true
    totalParts?: true
  }

  export type SeriesMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    totalParts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeriesMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    totalParts?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SeriesCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    totalParts?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SeriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to aggregate.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Series
    **/
    _count?: true | SeriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeriesMaxAggregateInputType
  }

  export type GetSeriesAggregateType<T extends SeriesAggregateArgs> = {
        [P in keyof T & keyof AggregateSeries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeries[P]>
      : GetScalarType<T[P], AggregateSeries[P]>
  }




  export type SeriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SeriesWhereInput
    orderBy?: SeriesOrderByWithAggregationInput | SeriesOrderByWithAggregationInput[]
    by: SeriesScalarFieldEnum[] | SeriesScalarFieldEnum
    having?: SeriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeriesCountAggregateInputType | true
    _avg?: SeriesAvgAggregateInputType
    _sum?: SeriesSumAggregateInputType
    _min?: SeriesMinAggregateInputType
    _max?: SeriesMaxAggregateInputType
  }

  export type SeriesGroupByOutputType = {
    id: number
    name: string
    slug: string
    description: string | null
    totalParts: number
    createdAt: Date
    updatedAt: Date
    _count: SeriesCountAggregateOutputType | null
    _avg: SeriesAvgAggregateOutputType | null
    _sum: SeriesSumAggregateOutputType | null
    _min: SeriesMinAggregateOutputType | null
    _max: SeriesMaxAggregateOutputType | null
  }

  type GetSeriesGroupByPayload<T extends SeriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SeriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeriesGroupByOutputType[P]>
            : GetScalarType<T[P], SeriesGroupByOutputType[P]>
        }
      >
    >


  export type SeriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    totalParts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blogPosts?: boolean | Series$blogPostsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    totalParts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    totalParts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["series"]>

  export type SeriesSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    totalParts?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SeriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "totalParts" | "createdAt" | "updatedAt", ExtArgs["result"]["series"]>
  export type SeriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPosts?: boolean | Series$blogPostsArgs<ExtArgs>
    _count?: boolean | SeriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SeriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SeriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SeriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Series"
    objects: {
      blogPosts: Prisma.$BlogPostPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      description: string | null
      totalParts: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["series"]>
    composites: {}
  }

  type SeriesGetPayload<S extends boolean | null | undefined | SeriesDefaultArgs> = $Result.GetResult<Prisma.$SeriesPayload, S>

  type SeriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SeriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SeriesCountAggregateInputType | true
    }

  export interface SeriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Series'], meta: { name: 'Series' } }
    /**
     * Find zero or one Series that matches the filter.
     * @param {SeriesFindUniqueArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SeriesFindUniqueArgs>(args: SelectSubset<T, SeriesFindUniqueArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Series that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SeriesFindUniqueOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SeriesFindUniqueOrThrowArgs>(args: SelectSubset<T, SeriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SeriesFindFirstArgs>(args?: SelectSubset<T, SeriesFindFirstArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Series that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindFirstOrThrowArgs} args - Arguments to find a Series
     * @example
     * // Get one Series
     * const series = await prisma.series.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SeriesFindFirstOrThrowArgs>(args?: SelectSubset<T, SeriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Series that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Series
     * const series = await prisma.series.findMany()
     * 
     * // Get first 10 Series
     * const series = await prisma.series.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seriesWithIdOnly = await prisma.series.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SeriesFindManyArgs>(args?: SelectSubset<T, SeriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Series.
     * @param {SeriesCreateArgs} args - Arguments to create a Series.
     * @example
     * // Create one Series
     * const Series = await prisma.series.create({
     *   data: {
     *     // ... data to create a Series
     *   }
     * })
     * 
     */
    create<T extends SeriesCreateArgs>(args: SelectSubset<T, SeriesCreateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Series.
     * @param {SeriesCreateManyArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SeriesCreateManyArgs>(args?: SelectSubset<T, SeriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Series and returns the data saved in the database.
     * @param {SeriesCreateManyAndReturnArgs} args - Arguments to create many Series.
     * @example
     * // Create many Series
     * const series = await prisma.series.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SeriesCreateManyAndReturnArgs>(args?: SelectSubset<T, SeriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Series.
     * @param {SeriesDeleteArgs} args - Arguments to delete one Series.
     * @example
     * // Delete one Series
     * const Series = await prisma.series.delete({
     *   where: {
     *     // ... filter to delete one Series
     *   }
     * })
     * 
     */
    delete<T extends SeriesDeleteArgs>(args: SelectSubset<T, SeriesDeleteArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Series.
     * @param {SeriesUpdateArgs} args - Arguments to update one Series.
     * @example
     * // Update one Series
     * const series = await prisma.series.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SeriesUpdateArgs>(args: SelectSubset<T, SeriesUpdateArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Series.
     * @param {SeriesDeleteManyArgs} args - Arguments to filter Series to delete.
     * @example
     * // Delete a few Series
     * const { count } = await prisma.series.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SeriesDeleteManyArgs>(args?: SelectSubset<T, SeriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SeriesUpdateManyArgs>(args: SelectSubset<T, SeriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Series and returns the data updated in the database.
     * @param {SeriesUpdateManyAndReturnArgs} args - Arguments to update many Series.
     * @example
     * // Update many Series
     * const series = await prisma.series.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Series and only return the `id`
     * const seriesWithIdOnly = await prisma.series.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SeriesUpdateManyAndReturnArgs>(args: SelectSubset<T, SeriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Series.
     * @param {SeriesUpsertArgs} args - Arguments to update or create a Series.
     * @example
     * // Update or create a Series
     * const series = await prisma.series.upsert({
     *   create: {
     *     // ... data to create a Series
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Series we want to update
     *   }
     * })
     */
    upsert<T extends SeriesUpsertArgs>(args: SelectSubset<T, SeriesUpsertArgs<ExtArgs>>): Prisma__SeriesClient<$Result.GetResult<Prisma.$SeriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesCountArgs} args - Arguments to filter Series to count.
     * @example
     * // Count the number of Series
     * const count = await prisma.series.count({
     *   where: {
     *     // ... the filter for the Series we want to count
     *   }
     * })
    **/
    count<T extends SeriesCountArgs>(
      args?: Subset<T, SeriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeriesAggregateArgs>(args: Subset<T, SeriesAggregateArgs>): Prisma.PrismaPromise<GetSeriesAggregateType<T>>

    /**
     * Group by Series.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeriesGroupByArgs['orderBy'] }
        : { orderBy?: SeriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Series model
   */
  readonly fields: SeriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Series.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SeriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPosts<T extends Series$blogPostsArgs<ExtArgs> = {}>(args?: Subset<T, Series$blogPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Series model
   */
  interface SeriesFieldRefs {
    readonly id: FieldRef<"Series", 'Int'>
    readonly name: FieldRef<"Series", 'String'>
    readonly slug: FieldRef<"Series", 'String'>
    readonly description: FieldRef<"Series", 'String'>
    readonly totalParts: FieldRef<"Series", 'Int'>
    readonly createdAt: FieldRef<"Series", 'DateTime'>
    readonly updatedAt: FieldRef<"Series", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Series findUnique
   */
  export type SeriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findUniqueOrThrow
   */
  export type SeriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series findFirst
   */
  export type SeriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findFirstOrThrow
   */
  export type SeriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Series.
     */
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series findMany
   */
  export type SeriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter, which Series to fetch.
     */
    where?: SeriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Series to fetch.
     */
    orderBy?: SeriesOrderByWithRelationInput | SeriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Series.
     */
    cursor?: SeriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Series from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Series.
     */
    skip?: number
    distinct?: SeriesScalarFieldEnum | SeriesScalarFieldEnum[]
  }

  /**
   * Series create
   */
  export type SeriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Series.
     */
    data: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
  }

  /**
   * Series createMany
   */
  export type SeriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Series createManyAndReturn
   */
  export type SeriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to create many Series.
     */
    data: SeriesCreateManyInput | SeriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Series update
   */
  export type SeriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Series.
     */
    data: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
    /**
     * Choose, which Series to update.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series updateMany
   */
  export type SeriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
  }

  /**
   * Series updateManyAndReturn
   */
  export type SeriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * The data used to update Series.
     */
    data: XOR<SeriesUpdateManyMutationInput, SeriesUncheckedUpdateManyInput>
    /**
     * Filter which Series to update
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to update.
     */
    limit?: number
  }

  /**
   * Series upsert
   */
  export type SeriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Series to update in case it exists.
     */
    where: SeriesWhereUniqueInput
    /**
     * In case the Series found by the `where` argument doesn't exist, create a new Series with this data.
     */
    create: XOR<SeriesCreateInput, SeriesUncheckedCreateInput>
    /**
     * In case the Series was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SeriesUpdateInput, SeriesUncheckedUpdateInput>
  }

  /**
   * Series delete
   */
  export type SeriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
    /**
     * Filter which Series to delete.
     */
    where: SeriesWhereUniqueInput
  }

  /**
   * Series deleteMany
   */
  export type SeriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Series to delete
     */
    where?: SeriesWhereInput
    /**
     * Limit how many Series to delete.
     */
    limit?: number
  }

  /**
   * Series.blogPosts
   */
  export type Series$blogPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPost
     */
    select?: BlogPostSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPost
     */
    omit?: BlogPostOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostInclude<ExtArgs> | null
    where?: BlogPostWhereInput
    orderBy?: BlogPostOrderByWithRelationInput | BlogPostOrderByWithRelationInput[]
    cursor?: BlogPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostScalarFieldEnum | BlogPostScalarFieldEnum[]
  }

  /**
   * Series without action
   */
  export type SeriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Series
     */
    select?: SeriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Series
     */
    omit?: SeriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SeriesInclude<ExtArgs> | null
  }


  /**
   * Model ContentBlock
   */

  export type AggregateContentBlock = {
    _count: ContentBlockCountAggregateOutputType | null
    _avg: ContentBlockAvgAggregateOutputType | null
    _sum: ContentBlockSumAggregateOutputType | null
    _min: ContentBlockMinAggregateOutputType | null
    _max: ContentBlockMaxAggregateOutputType | null
  }

  export type ContentBlockAvgAggregateOutputType = {
    id: number | null
    order: number | null
    level: number | null
    blogPostId: number | null
  }

  export type ContentBlockSumAggregateOutputType = {
    id: number | null
    order: number | null
    level: number | null
    blogPostId: number | null
  }

  export type ContentBlockMinAggregateOutputType = {
    id: number | null
    type: $Enums.ContentBlockType | null
    order: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    level: number | null
    language: string | null
    codeTitle: string | null
    imageUrl: string | null
    imageAlt: string | null
    imageCaption: string | null
    imageAlignment: string | null
    calloutVariant: $Enums.CalloutVariant | null
    calloutTitle: string | null
    quoteAuthor: string | null
    listStyle: $Enums.ListStyle | null
    videoType: $Enums.VideoType | null
    videoId: string | null
    videoTitle: string | null
    paragraphStyle: string | null
    blogPostId: number | null
  }

  export type ContentBlockMaxAggregateOutputType = {
    id: number | null
    type: $Enums.ContentBlockType | null
    order: number | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
    level: number | null
    language: string | null
    codeTitle: string | null
    imageUrl: string | null
    imageAlt: string | null
    imageCaption: string | null
    imageAlignment: string | null
    calloutVariant: $Enums.CalloutVariant | null
    calloutTitle: string | null
    quoteAuthor: string | null
    listStyle: $Enums.ListStyle | null
    videoType: $Enums.VideoType | null
    videoId: string | null
    videoTitle: string | null
    paragraphStyle: string | null
    blogPostId: number | null
  }

  export type ContentBlockCountAggregateOutputType = {
    id: number
    type: number
    order: number
    content: number
    createdAt: number
    updatedAt: number
    level: number
    language: number
    codeTitle: number
    imageUrl: number
    imageAlt: number
    imageCaption: number
    imageAlignment: number
    calloutVariant: number
    calloutTitle: number
    quoteAuthor: number
    listStyle: number
    listItems: number
    videoType: number
    videoId: number
    videoTitle: number
    paragraphStyle: number
    blogPostId: number
    _all: number
  }


  export type ContentBlockAvgAggregateInputType = {
    id?: true
    order?: true
    level?: true
    blogPostId?: true
  }

  export type ContentBlockSumAggregateInputType = {
    id?: true
    order?: true
    level?: true
    blogPostId?: true
  }

  export type ContentBlockMinAggregateInputType = {
    id?: true
    type?: true
    order?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    level?: true
    language?: true
    codeTitle?: true
    imageUrl?: true
    imageAlt?: true
    imageCaption?: true
    imageAlignment?: true
    calloutVariant?: true
    calloutTitle?: true
    quoteAuthor?: true
    listStyle?: true
    videoType?: true
    videoId?: true
    videoTitle?: true
    paragraphStyle?: true
    blogPostId?: true
  }

  export type ContentBlockMaxAggregateInputType = {
    id?: true
    type?: true
    order?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    level?: true
    language?: true
    codeTitle?: true
    imageUrl?: true
    imageAlt?: true
    imageCaption?: true
    imageAlignment?: true
    calloutVariant?: true
    calloutTitle?: true
    quoteAuthor?: true
    listStyle?: true
    videoType?: true
    videoId?: true
    videoTitle?: true
    paragraphStyle?: true
    blogPostId?: true
  }

  export type ContentBlockCountAggregateInputType = {
    id?: true
    type?: true
    order?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    level?: true
    language?: true
    codeTitle?: true
    imageUrl?: true
    imageAlt?: true
    imageCaption?: true
    imageAlignment?: true
    calloutVariant?: true
    calloutTitle?: true
    quoteAuthor?: true
    listStyle?: true
    listItems?: true
    videoType?: true
    videoId?: true
    videoTitle?: true
    paragraphStyle?: true
    blogPostId?: true
    _all?: true
  }

  export type ContentBlockAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentBlock to aggregate.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentBlocks
    **/
    _count?: true | ContentBlockCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentBlockAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentBlockSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentBlockMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentBlockMaxAggregateInputType
  }

  export type GetContentBlockAggregateType<T extends ContentBlockAggregateArgs> = {
        [P in keyof T & keyof AggregateContentBlock]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentBlock[P]>
      : GetScalarType<T[P], AggregateContentBlock[P]>
  }




  export type ContentBlockGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentBlockWhereInput
    orderBy?: ContentBlockOrderByWithAggregationInput | ContentBlockOrderByWithAggregationInput[]
    by: ContentBlockScalarFieldEnum[] | ContentBlockScalarFieldEnum
    having?: ContentBlockScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentBlockCountAggregateInputType | true
    _avg?: ContentBlockAvgAggregateInputType
    _sum?: ContentBlockSumAggregateInputType
    _min?: ContentBlockMinAggregateInputType
    _max?: ContentBlockMaxAggregateInputType
  }

  export type ContentBlockGroupByOutputType = {
    id: number
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt: Date
    updatedAt: Date
    level: number | null
    language: string | null
    codeTitle: string | null
    imageUrl: string | null
    imageAlt: string | null
    imageCaption: string | null
    imageAlignment: string | null
    calloutVariant: $Enums.CalloutVariant | null
    calloutTitle: string | null
    quoteAuthor: string | null
    listStyle: $Enums.ListStyle | null
    listItems: JsonValue | null
    videoType: $Enums.VideoType | null
    videoId: string | null
    videoTitle: string | null
    paragraphStyle: string | null
    blogPostId: number
    _count: ContentBlockCountAggregateOutputType | null
    _avg: ContentBlockAvgAggregateOutputType | null
    _sum: ContentBlockSumAggregateOutputType | null
    _min: ContentBlockMinAggregateOutputType | null
    _max: ContentBlockMaxAggregateOutputType | null
  }

  type GetContentBlockGroupByPayload<T extends ContentBlockGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentBlockGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentBlockGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentBlockGroupByOutputType[P]>
            : GetScalarType<T[P], ContentBlockGroupByOutputType[P]>
        }
      >
    >


  export type ContentBlockSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    language?: boolean
    codeTitle?: boolean
    imageUrl?: boolean
    imageAlt?: boolean
    imageCaption?: boolean
    imageAlignment?: boolean
    calloutVariant?: boolean
    calloutTitle?: boolean
    quoteAuthor?: boolean
    listStyle?: boolean
    listItems?: boolean
    videoType?: boolean
    videoId?: boolean
    videoTitle?: boolean
    paragraphStyle?: boolean
    blogPostId?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentBlock"]>

  export type ContentBlockSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    language?: boolean
    codeTitle?: boolean
    imageUrl?: boolean
    imageAlt?: boolean
    imageCaption?: boolean
    imageAlignment?: boolean
    calloutVariant?: boolean
    calloutTitle?: boolean
    quoteAuthor?: boolean
    listStyle?: boolean
    listItems?: boolean
    videoType?: boolean
    videoId?: boolean
    videoTitle?: boolean
    paragraphStyle?: boolean
    blogPostId?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentBlock"]>

  export type ContentBlockSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    language?: boolean
    codeTitle?: boolean
    imageUrl?: boolean
    imageAlt?: boolean
    imageCaption?: boolean
    imageAlignment?: boolean
    calloutVariant?: boolean
    calloutTitle?: boolean
    quoteAuthor?: boolean
    listStyle?: boolean
    listItems?: boolean
    videoType?: boolean
    videoId?: boolean
    videoTitle?: boolean
    paragraphStyle?: boolean
    blogPostId?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentBlock"]>

  export type ContentBlockSelectScalar = {
    id?: boolean
    type?: boolean
    order?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    level?: boolean
    language?: boolean
    codeTitle?: boolean
    imageUrl?: boolean
    imageAlt?: boolean
    imageCaption?: boolean
    imageAlignment?: boolean
    calloutVariant?: boolean
    calloutTitle?: boolean
    quoteAuthor?: boolean
    listStyle?: boolean
    listItems?: boolean
    videoType?: boolean
    videoId?: boolean
    videoTitle?: boolean
    paragraphStyle?: boolean
    blogPostId?: boolean
  }

  export type ContentBlockOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "order" | "content" | "createdAt" | "updatedAt" | "level" | "language" | "codeTitle" | "imageUrl" | "imageAlt" | "imageCaption" | "imageAlignment" | "calloutVariant" | "calloutTitle" | "quoteAuthor" | "listStyle" | "listItems" | "videoType" | "videoId" | "videoTitle" | "paragraphStyle" | "blogPostId", ExtArgs["result"]["contentBlock"]>
  export type ContentBlockInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type ContentBlockIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }
  export type ContentBlockIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
  }

  export type $ContentBlockPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentBlock"
    objects: {
      blogPost: Prisma.$BlogPostPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: $Enums.ContentBlockType
      order: number
      content: string
      createdAt: Date
      updatedAt: Date
      level: number | null
      language: string | null
      codeTitle: string | null
      imageUrl: string | null
      imageAlt: string | null
      imageCaption: string | null
      imageAlignment: string | null
      calloutVariant: $Enums.CalloutVariant | null
      calloutTitle: string | null
      quoteAuthor: string | null
      listStyle: $Enums.ListStyle | null
      listItems: Prisma.JsonValue | null
      videoType: $Enums.VideoType | null
      videoId: string | null
      videoTitle: string | null
      paragraphStyle: string | null
      blogPostId: number
    }, ExtArgs["result"]["contentBlock"]>
    composites: {}
  }

  type ContentBlockGetPayload<S extends boolean | null | undefined | ContentBlockDefaultArgs> = $Result.GetResult<Prisma.$ContentBlockPayload, S>

  type ContentBlockCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentBlockFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentBlockCountAggregateInputType | true
    }

  export interface ContentBlockDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentBlock'], meta: { name: 'ContentBlock' } }
    /**
     * Find zero or one ContentBlock that matches the filter.
     * @param {ContentBlockFindUniqueArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentBlockFindUniqueArgs>(args: SelectSubset<T, ContentBlockFindUniqueArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentBlock that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentBlockFindUniqueOrThrowArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentBlockFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentBlockFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentBlock that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockFindFirstArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentBlockFindFirstArgs>(args?: SelectSubset<T, ContentBlockFindFirstArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentBlock that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockFindFirstOrThrowArgs} args - Arguments to find a ContentBlock
     * @example
     * // Get one ContentBlock
     * const contentBlock = await prisma.contentBlock.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentBlockFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentBlockFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentBlocks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentBlocks
     * const contentBlocks = await prisma.contentBlock.findMany()
     * 
     * // Get first 10 ContentBlocks
     * const contentBlocks = await prisma.contentBlock.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentBlockWithIdOnly = await prisma.contentBlock.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentBlockFindManyArgs>(args?: SelectSubset<T, ContentBlockFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentBlock.
     * @param {ContentBlockCreateArgs} args - Arguments to create a ContentBlock.
     * @example
     * // Create one ContentBlock
     * const ContentBlock = await prisma.contentBlock.create({
     *   data: {
     *     // ... data to create a ContentBlock
     *   }
     * })
     * 
     */
    create<T extends ContentBlockCreateArgs>(args: SelectSubset<T, ContentBlockCreateArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentBlocks.
     * @param {ContentBlockCreateManyArgs} args - Arguments to create many ContentBlocks.
     * @example
     * // Create many ContentBlocks
     * const contentBlock = await prisma.contentBlock.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentBlockCreateManyArgs>(args?: SelectSubset<T, ContentBlockCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentBlocks and returns the data saved in the database.
     * @param {ContentBlockCreateManyAndReturnArgs} args - Arguments to create many ContentBlocks.
     * @example
     * // Create many ContentBlocks
     * const contentBlock = await prisma.contentBlock.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentBlocks and only return the `id`
     * const contentBlockWithIdOnly = await prisma.contentBlock.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentBlockCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentBlockCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentBlock.
     * @param {ContentBlockDeleteArgs} args - Arguments to delete one ContentBlock.
     * @example
     * // Delete one ContentBlock
     * const ContentBlock = await prisma.contentBlock.delete({
     *   where: {
     *     // ... filter to delete one ContentBlock
     *   }
     * })
     * 
     */
    delete<T extends ContentBlockDeleteArgs>(args: SelectSubset<T, ContentBlockDeleteArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentBlock.
     * @param {ContentBlockUpdateArgs} args - Arguments to update one ContentBlock.
     * @example
     * // Update one ContentBlock
     * const contentBlock = await prisma.contentBlock.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentBlockUpdateArgs>(args: SelectSubset<T, ContentBlockUpdateArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentBlocks.
     * @param {ContentBlockDeleteManyArgs} args - Arguments to filter ContentBlocks to delete.
     * @example
     * // Delete a few ContentBlocks
     * const { count } = await prisma.contentBlock.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentBlockDeleteManyArgs>(args?: SelectSubset<T, ContentBlockDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentBlocks
     * const contentBlock = await prisma.contentBlock.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentBlockUpdateManyArgs>(args: SelectSubset<T, ContentBlockUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentBlocks and returns the data updated in the database.
     * @param {ContentBlockUpdateManyAndReturnArgs} args - Arguments to update many ContentBlocks.
     * @example
     * // Update many ContentBlocks
     * const contentBlock = await prisma.contentBlock.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentBlocks and only return the `id`
     * const contentBlockWithIdOnly = await prisma.contentBlock.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentBlockUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentBlockUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentBlock.
     * @param {ContentBlockUpsertArgs} args - Arguments to update or create a ContentBlock.
     * @example
     * // Update or create a ContentBlock
     * const contentBlock = await prisma.contentBlock.upsert({
     *   create: {
     *     // ... data to create a ContentBlock
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentBlock we want to update
     *   }
     * })
     */
    upsert<T extends ContentBlockUpsertArgs>(args: SelectSubset<T, ContentBlockUpsertArgs<ExtArgs>>): Prisma__ContentBlockClient<$Result.GetResult<Prisma.$ContentBlockPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentBlocks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockCountArgs} args - Arguments to filter ContentBlocks to count.
     * @example
     * // Count the number of ContentBlocks
     * const count = await prisma.contentBlock.count({
     *   where: {
     *     // ... the filter for the ContentBlocks we want to count
     *   }
     * })
    **/
    count<T extends ContentBlockCountArgs>(
      args?: Subset<T, ContentBlockCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentBlockCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentBlockAggregateArgs>(args: Subset<T, ContentBlockAggregateArgs>): Prisma.PrismaPromise<GetContentBlockAggregateType<T>>

    /**
     * Group by ContentBlock.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentBlockGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentBlockGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentBlockGroupByArgs['orderBy'] }
        : { orderBy?: ContentBlockGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentBlockGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentBlockGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentBlock model
   */
  readonly fields: ContentBlockFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentBlock.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentBlockClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPost<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentBlock model
   */
  interface ContentBlockFieldRefs {
    readonly id: FieldRef<"ContentBlock", 'Int'>
    readonly type: FieldRef<"ContentBlock", 'ContentBlockType'>
    readonly order: FieldRef<"ContentBlock", 'Float'>
    readonly content: FieldRef<"ContentBlock", 'String'>
    readonly createdAt: FieldRef<"ContentBlock", 'DateTime'>
    readonly updatedAt: FieldRef<"ContentBlock", 'DateTime'>
    readonly level: FieldRef<"ContentBlock", 'Int'>
    readonly language: FieldRef<"ContentBlock", 'String'>
    readonly codeTitle: FieldRef<"ContentBlock", 'String'>
    readonly imageUrl: FieldRef<"ContentBlock", 'String'>
    readonly imageAlt: FieldRef<"ContentBlock", 'String'>
    readonly imageCaption: FieldRef<"ContentBlock", 'String'>
    readonly imageAlignment: FieldRef<"ContentBlock", 'String'>
    readonly calloutVariant: FieldRef<"ContentBlock", 'CalloutVariant'>
    readonly calloutTitle: FieldRef<"ContentBlock", 'String'>
    readonly quoteAuthor: FieldRef<"ContentBlock", 'String'>
    readonly listStyle: FieldRef<"ContentBlock", 'ListStyle'>
    readonly listItems: FieldRef<"ContentBlock", 'Json'>
    readonly videoType: FieldRef<"ContentBlock", 'VideoType'>
    readonly videoId: FieldRef<"ContentBlock", 'String'>
    readonly videoTitle: FieldRef<"ContentBlock", 'String'>
    readonly paragraphStyle: FieldRef<"ContentBlock", 'String'>
    readonly blogPostId: FieldRef<"ContentBlock", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentBlock findUnique
   */
  export type ContentBlockFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock findUniqueOrThrow
   */
  export type ContentBlockFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock findFirst
   */
  export type ContentBlockFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentBlocks.
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentBlocks.
     */
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * ContentBlock findFirstOrThrow
   */
  export type ContentBlockFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlock to fetch.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentBlocks.
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentBlocks.
     */
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * ContentBlock findMany
   */
  export type ContentBlockFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter, which ContentBlocks to fetch.
     */
    where?: ContentBlockWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentBlocks to fetch.
     */
    orderBy?: ContentBlockOrderByWithRelationInput | ContentBlockOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentBlocks.
     */
    cursor?: ContentBlockWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentBlocks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentBlocks.
     */
    skip?: number
    distinct?: ContentBlockScalarFieldEnum | ContentBlockScalarFieldEnum[]
  }

  /**
   * ContentBlock create
   */
  export type ContentBlockCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentBlock.
     */
    data: XOR<ContentBlockCreateInput, ContentBlockUncheckedCreateInput>
  }

  /**
   * ContentBlock createMany
   */
  export type ContentBlockCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentBlocks.
     */
    data: ContentBlockCreateManyInput | ContentBlockCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContentBlock createManyAndReturn
   */
  export type ContentBlockCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * The data used to create many ContentBlocks.
     */
    data: ContentBlockCreateManyInput | ContentBlockCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentBlock update
   */
  export type ContentBlockUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentBlock.
     */
    data: XOR<ContentBlockUpdateInput, ContentBlockUncheckedUpdateInput>
    /**
     * Choose, which ContentBlock to update.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock updateMany
   */
  export type ContentBlockUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentBlocks.
     */
    data: XOR<ContentBlockUpdateManyMutationInput, ContentBlockUncheckedUpdateManyInput>
    /**
     * Filter which ContentBlocks to update
     */
    where?: ContentBlockWhereInput
    /**
     * Limit how many ContentBlocks to update.
     */
    limit?: number
  }

  /**
   * ContentBlock updateManyAndReturn
   */
  export type ContentBlockUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * The data used to update ContentBlocks.
     */
    data: XOR<ContentBlockUpdateManyMutationInput, ContentBlockUncheckedUpdateManyInput>
    /**
     * Filter which ContentBlocks to update
     */
    where?: ContentBlockWhereInput
    /**
     * Limit how many ContentBlocks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentBlock upsert
   */
  export type ContentBlockUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentBlock to update in case it exists.
     */
    where: ContentBlockWhereUniqueInput
    /**
     * In case the ContentBlock found by the `where` argument doesn't exist, create a new ContentBlock with this data.
     */
    create: XOR<ContentBlockCreateInput, ContentBlockUncheckedCreateInput>
    /**
     * In case the ContentBlock was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentBlockUpdateInput, ContentBlockUncheckedUpdateInput>
  }

  /**
   * ContentBlock delete
   */
  export type ContentBlockDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
    /**
     * Filter which ContentBlock to delete.
     */
    where: ContentBlockWhereUniqueInput
  }

  /**
   * ContentBlock deleteMany
   */
  export type ContentBlockDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentBlocks to delete
     */
    where?: ContentBlockWhereInput
    /**
     * Limit how many ContentBlocks to delete.
     */
    limit?: number
  }

  /**
   * ContentBlock without action
   */
  export type ContentBlockDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentBlock
     */
    select?: ContentBlockSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentBlock
     */
    omit?: ContentBlockOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentBlockInclude<ExtArgs> | null
  }


  /**
   * Model BlogTag
   */

  export type AggregateBlogTag = {
    _count: BlogTagCountAggregateOutputType | null
    _avg: BlogTagAvgAggregateOutputType | null
    _sum: BlogTagSumAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  export type BlogTagAvgAggregateOutputType = {
    id: number | null
  }

  export type BlogTagSumAggregateOutputType = {
    id: number | null
  }

  export type BlogTagMinAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogTagMaxAggregateOutputType = {
    id: number | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BlogTagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BlogTagAvgAggregateInputType = {
    id?: true
  }

  export type BlogTagSumAggregateInputType = {
    id?: true
  }

  export type BlogTagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogTagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BlogTagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BlogTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTag to aggregate.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogTags
    **/
    _count?: true | BlogTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogTagMaxAggregateInputType
  }

  export type GetBlogTagAggregateType<T extends BlogTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogTag[P]>
      : GetScalarType<T[P], AggregateBlogTag[P]>
  }




  export type BlogTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogTagWhereInput
    orderBy?: BlogTagOrderByWithAggregationInput | BlogTagOrderByWithAggregationInput[]
    by: BlogTagScalarFieldEnum[] | BlogTagScalarFieldEnum
    having?: BlogTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogTagCountAggregateInputType | true
    _avg?: BlogTagAvgAggregateInputType
    _sum?: BlogTagSumAggregateInputType
    _min?: BlogTagMinAggregateInputType
    _max?: BlogTagMaxAggregateInputType
  }

  export type BlogTagGroupByOutputType = {
    id: number
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: BlogTagCountAggregateOutputType | null
    _avg: BlogTagAvgAggregateOutputType | null
    _sum: BlogTagSumAggregateOutputType | null
    _min: BlogTagMinAggregateOutputType | null
    _max: BlogTagMaxAggregateOutputType | null
  }

  type GetBlogTagGroupByPayload<T extends BlogTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    blogPostTags?: boolean | BlogTag$blogPostTagsArgs<ExtArgs>
    _count?: boolean | BlogTagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["blogTag"]>

  export type BlogTagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BlogTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["blogTag"]>
  export type BlogTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPostTags?: boolean | BlogTag$blogPostTagsArgs<ExtArgs>
    _count?: boolean | BlogTagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BlogTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BlogTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BlogTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogTag"
    objects: {
      blogPostTags: Prisma.$BlogPostTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["blogTag"]>
    composites: {}
  }

  type BlogTagGetPayload<S extends boolean | null | undefined | BlogTagDefaultArgs> = $Result.GetResult<Prisma.$BlogTagPayload, S>

  type BlogTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogTagCountAggregateInputType | true
    }

  export interface BlogTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogTag'], meta: { name: 'BlogTag' } }
    /**
     * Find zero or one BlogTag that matches the filter.
     * @param {BlogTagFindUniqueArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogTagFindUniqueArgs>(args: SelectSubset<T, BlogTagFindUniqueArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogTagFindUniqueOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogTagFindFirstArgs>(args?: SelectSubset<T, BlogTagFindFirstArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindFirstOrThrowArgs} args - Arguments to find a BlogTag
     * @example
     * // Get one BlogTag
     * const blogTag = await prisma.blogTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogTags
     * const blogTags = await prisma.blogTag.findMany()
     * 
     * // Get first 10 BlogTags
     * const blogTags = await prisma.blogTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogTagFindManyArgs>(args?: SelectSubset<T, BlogTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogTag.
     * @param {BlogTagCreateArgs} args - Arguments to create a BlogTag.
     * @example
     * // Create one BlogTag
     * const BlogTag = await prisma.blogTag.create({
     *   data: {
     *     // ... data to create a BlogTag
     *   }
     * })
     * 
     */
    create<T extends BlogTagCreateArgs>(args: SelectSubset<T, BlogTagCreateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogTags.
     * @param {BlogTagCreateManyArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogTagCreateManyArgs>(args?: SelectSubset<T, BlogTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogTags and returns the data saved in the database.
     * @param {BlogTagCreateManyAndReturnArgs} args - Arguments to create many BlogTags.
     * @example
     * // Create many BlogTags
     * const blogTag = await prisma.blogTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogTag.
     * @param {BlogTagDeleteArgs} args - Arguments to delete one BlogTag.
     * @example
     * // Delete one BlogTag
     * const BlogTag = await prisma.blogTag.delete({
     *   where: {
     *     // ... filter to delete one BlogTag
     *   }
     * })
     * 
     */
    delete<T extends BlogTagDeleteArgs>(args: SelectSubset<T, BlogTagDeleteArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogTag.
     * @param {BlogTagUpdateArgs} args - Arguments to update one BlogTag.
     * @example
     * // Update one BlogTag
     * const blogTag = await prisma.blogTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogTagUpdateArgs>(args: SelectSubset<T, BlogTagUpdateArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogTags.
     * @param {BlogTagDeleteManyArgs} args - Arguments to filter BlogTags to delete.
     * @example
     * // Delete a few BlogTags
     * const { count } = await prisma.blogTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogTagDeleteManyArgs>(args?: SelectSubset<T, BlogTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogTagUpdateManyArgs>(args: SelectSubset<T, BlogTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogTags and returns the data updated in the database.
     * @param {BlogTagUpdateManyAndReturnArgs} args - Arguments to update many BlogTags.
     * @example
     * // Update many BlogTags
     * const blogTag = await prisma.blogTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogTags and only return the `id`
     * const blogTagWithIdOnly = await prisma.blogTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogTagUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogTag.
     * @param {BlogTagUpsertArgs} args - Arguments to update or create a BlogTag.
     * @example
     * // Update or create a BlogTag
     * const blogTag = await prisma.blogTag.upsert({
     *   create: {
     *     // ... data to create a BlogTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogTag we want to update
     *   }
     * })
     */
    upsert<T extends BlogTagUpsertArgs>(args: SelectSubset<T, BlogTagUpsertArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagCountArgs} args - Arguments to filter BlogTags to count.
     * @example
     * // Count the number of BlogTags
     * const count = await prisma.blogTag.count({
     *   where: {
     *     // ... the filter for the BlogTags we want to count
     *   }
     * })
    **/
    count<T extends BlogTagCountArgs>(
      args?: Subset<T, BlogTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogTagAggregateArgs>(args: Subset<T, BlogTagAggregateArgs>): Prisma.PrismaPromise<GetBlogTagAggregateType<T>>

    /**
     * Group by BlogTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogTag model
   */
  readonly fields: BlogTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPostTags<T extends BlogTag$blogPostTagsArgs<ExtArgs> = {}>(args?: Subset<T, BlogTag$blogPostTagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogTag model
   */
  interface BlogTagFieldRefs {
    readonly id: FieldRef<"BlogTag", 'Int'>
    readonly name: FieldRef<"BlogTag", 'String'>
    readonly slug: FieldRef<"BlogTag", 'String'>
    readonly createdAt: FieldRef<"BlogTag", 'DateTime'>
    readonly updatedAt: FieldRef<"BlogTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlogTag findUnique
   */
  export type BlogTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findUniqueOrThrow
   */
  export type BlogTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag findFirst
   */
  export type BlogTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findFirstOrThrow
   */
  export type BlogTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTag to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogTags.
     */
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag findMany
   */
  export type BlogTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogTags to fetch.
     */
    where?: BlogTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogTags to fetch.
     */
    orderBy?: BlogTagOrderByWithRelationInput | BlogTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogTags.
     */
    cursor?: BlogTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogTags.
     */
    skip?: number
    distinct?: BlogTagScalarFieldEnum | BlogTagScalarFieldEnum[]
  }

  /**
   * BlogTag create
   */
  export type BlogTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogTag.
     */
    data: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
  }

  /**
   * BlogTag createMany
   */
  export type BlogTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag createManyAndReturn
   */
  export type BlogTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to create many BlogTags.
     */
    data: BlogTagCreateManyInput | BlogTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogTag update
   */
  export type BlogTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogTag.
     */
    data: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
    /**
     * Choose, which BlogTag to update.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag updateMany
   */
  export type BlogTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag updateManyAndReturn
   */
  export type BlogTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * The data used to update BlogTags.
     */
    data: XOR<BlogTagUpdateManyMutationInput, BlogTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogTags to update
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to update.
     */
    limit?: number
  }

  /**
   * BlogTag upsert
   */
  export type BlogTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogTag to update in case it exists.
     */
    where: BlogTagWhereUniqueInput
    /**
     * In case the BlogTag found by the `where` argument doesn't exist, create a new BlogTag with this data.
     */
    create: XOR<BlogTagCreateInput, BlogTagUncheckedCreateInput>
    /**
     * In case the BlogTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogTagUpdateInput, BlogTagUncheckedUpdateInput>
  }

  /**
   * BlogTag delete
   */
  export type BlogTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
    /**
     * Filter which BlogTag to delete.
     */
    where: BlogTagWhereUniqueInput
  }

  /**
   * BlogTag deleteMany
   */
  export type BlogTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogTags to delete
     */
    where?: BlogTagWhereInput
    /**
     * Limit how many BlogTags to delete.
     */
    limit?: number
  }

  /**
   * BlogTag.blogPostTags
   */
  export type BlogTag$blogPostTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    where?: BlogPostTagWhereInput
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    cursor?: BlogPostTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogTag without action
   */
  export type BlogTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogTag
     */
    select?: BlogTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogTag
     */
    omit?: BlogTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogTagInclude<ExtArgs> | null
  }


  /**
   * Model BlogPostTag
   */

  export type AggregateBlogPostTag = {
    _count: BlogPostTagCountAggregateOutputType | null
    _avg: BlogPostTagAvgAggregateOutputType | null
    _sum: BlogPostTagSumAggregateOutputType | null
    _min: BlogPostTagMinAggregateOutputType | null
    _max: BlogPostTagMaxAggregateOutputType | null
  }

  export type BlogPostTagAvgAggregateOutputType = {
    id: number | null
    blogPostId: number | null
    blogTagId: number | null
  }

  export type BlogPostTagSumAggregateOutputType = {
    id: number | null
    blogPostId: number | null
    blogTagId: number | null
  }

  export type BlogPostTagMinAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blogPostId: number | null
    blogTagId: number | null
  }

  export type BlogPostTagMaxAggregateOutputType = {
    id: number | null
    createdAt: Date | null
    blogPostId: number | null
    blogTagId: number | null
  }

  export type BlogPostTagCountAggregateOutputType = {
    id: number
    createdAt: number
    blogPostId: number
    blogTagId: number
    _all: number
  }


  export type BlogPostTagAvgAggregateInputType = {
    id?: true
    blogPostId?: true
    blogTagId?: true
  }

  export type BlogPostTagSumAggregateInputType = {
    id?: true
    blogPostId?: true
    blogTagId?: true
  }

  export type BlogPostTagMinAggregateInputType = {
    id?: true
    createdAt?: true
    blogPostId?: true
    blogTagId?: true
  }

  export type BlogPostTagMaxAggregateInputType = {
    id?: true
    createdAt?: true
    blogPostId?: true
    blogTagId?: true
  }

  export type BlogPostTagCountAggregateInputType = {
    id?: true
    createdAt?: true
    blogPostId?: true
    blogTagId?: true
    _all?: true
  }

  export type BlogPostTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostTag to aggregate.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlogPostTags
    **/
    _count?: true | BlogPostTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogPostTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogPostTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogPostTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogPostTagMaxAggregateInputType
  }

  export type GetBlogPostTagAggregateType<T extends BlogPostTagAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogPostTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogPostTag[P]>
      : GetScalarType<T[P], AggregateBlogPostTag[P]>
  }




  export type BlogPostTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlogPostTagWhereInput
    orderBy?: BlogPostTagOrderByWithAggregationInput | BlogPostTagOrderByWithAggregationInput[]
    by: BlogPostTagScalarFieldEnum[] | BlogPostTagScalarFieldEnum
    having?: BlogPostTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogPostTagCountAggregateInputType | true
    _avg?: BlogPostTagAvgAggregateInputType
    _sum?: BlogPostTagSumAggregateInputType
    _min?: BlogPostTagMinAggregateInputType
    _max?: BlogPostTagMaxAggregateInputType
  }

  export type BlogPostTagGroupByOutputType = {
    id: number
    createdAt: Date
    blogPostId: number
    blogTagId: number
    _count: BlogPostTagCountAggregateOutputType | null
    _avg: BlogPostTagAvgAggregateOutputType | null
    _sum: BlogPostTagSumAggregateOutputType | null
    _min: BlogPostTagMinAggregateOutputType | null
    _max: BlogPostTagMaxAggregateOutputType | null
  }

  type GetBlogPostTagGroupByPayload<T extends BlogPostTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogPostTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogPostTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogPostTagGroupByOutputType[P]>
            : GetScalarType<T[P], BlogPostTagGroupByOutputType[P]>
        }
      >
    >


  export type BlogPostTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blogPostId?: boolean
    blogTagId?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    blogTag?: boolean | BlogTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostTag"]>

  export type BlogPostTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blogPostId?: boolean
    blogTagId?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    blogTag?: boolean | BlogTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostTag"]>

  export type BlogPostTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    blogPostId?: boolean
    blogTagId?: boolean
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    blogTag?: boolean | BlogTagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogPostTag"]>

  export type BlogPostTagSelectScalar = {
    id?: boolean
    createdAt?: boolean
    blogPostId?: boolean
    blogTagId?: boolean
  }

  export type BlogPostTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "blogPostId" | "blogTagId", ExtArgs["result"]["blogPostTag"]>
  export type BlogPostTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    blogTag?: boolean | BlogTagDefaultArgs<ExtArgs>
  }
  export type BlogPostTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    blogTag?: boolean | BlogTagDefaultArgs<ExtArgs>
  }
  export type BlogPostTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogPost?: boolean | BlogPostDefaultArgs<ExtArgs>
    blogTag?: boolean | BlogTagDefaultArgs<ExtArgs>
  }

  export type $BlogPostTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlogPostTag"
    objects: {
      blogPost: Prisma.$BlogPostPayload<ExtArgs>
      blogTag: Prisma.$BlogTagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      createdAt: Date
      blogPostId: number
      blogTagId: number
    }, ExtArgs["result"]["blogPostTag"]>
    composites: {}
  }

  type BlogPostTagGetPayload<S extends boolean | null | undefined | BlogPostTagDefaultArgs> = $Result.GetResult<Prisma.$BlogPostTagPayload, S>

  type BlogPostTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlogPostTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogPostTagCountAggregateInputType | true
    }

  export interface BlogPostTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlogPostTag'], meta: { name: 'BlogPostTag' } }
    /**
     * Find zero or one BlogPostTag that matches the filter.
     * @param {BlogPostTagFindUniqueArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlogPostTagFindUniqueArgs>(args: SelectSubset<T, BlogPostTagFindUniqueArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlogPostTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlogPostTagFindUniqueOrThrowArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlogPostTagFindUniqueOrThrowArgs>(args: SelectSubset<T, BlogPostTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPostTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagFindFirstArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlogPostTagFindFirstArgs>(args?: SelectSubset<T, BlogPostTagFindFirstArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlogPostTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagFindFirstOrThrowArgs} args - Arguments to find a BlogPostTag
     * @example
     * // Get one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlogPostTagFindFirstOrThrowArgs>(args?: SelectSubset<T, BlogPostTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlogPostTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlogPostTags
     * const blogPostTags = await prisma.blogPostTag.findMany()
     * 
     * // Get first 10 BlogPostTags
     * const blogPostTags = await prisma.blogPostTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogPostTagWithIdOnly = await prisma.blogPostTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlogPostTagFindManyArgs>(args?: SelectSubset<T, BlogPostTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlogPostTag.
     * @param {BlogPostTagCreateArgs} args - Arguments to create a BlogPostTag.
     * @example
     * // Create one BlogPostTag
     * const BlogPostTag = await prisma.blogPostTag.create({
     *   data: {
     *     // ... data to create a BlogPostTag
     *   }
     * })
     * 
     */
    create<T extends BlogPostTagCreateArgs>(args: SelectSubset<T, BlogPostTagCreateArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlogPostTags.
     * @param {BlogPostTagCreateManyArgs} args - Arguments to create many BlogPostTags.
     * @example
     * // Create many BlogPostTags
     * const blogPostTag = await prisma.blogPostTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlogPostTagCreateManyArgs>(args?: SelectSubset<T, BlogPostTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlogPostTags and returns the data saved in the database.
     * @param {BlogPostTagCreateManyAndReturnArgs} args - Arguments to create many BlogPostTags.
     * @example
     * // Create many BlogPostTags
     * const blogPostTag = await prisma.blogPostTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlogPostTags and only return the `id`
     * const blogPostTagWithIdOnly = await prisma.blogPostTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlogPostTagCreateManyAndReturnArgs>(args?: SelectSubset<T, BlogPostTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlogPostTag.
     * @param {BlogPostTagDeleteArgs} args - Arguments to delete one BlogPostTag.
     * @example
     * // Delete one BlogPostTag
     * const BlogPostTag = await prisma.blogPostTag.delete({
     *   where: {
     *     // ... filter to delete one BlogPostTag
     *   }
     * })
     * 
     */
    delete<T extends BlogPostTagDeleteArgs>(args: SelectSubset<T, BlogPostTagDeleteArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlogPostTag.
     * @param {BlogPostTagUpdateArgs} args - Arguments to update one BlogPostTag.
     * @example
     * // Update one BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlogPostTagUpdateArgs>(args: SelectSubset<T, BlogPostTagUpdateArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlogPostTags.
     * @param {BlogPostTagDeleteManyArgs} args - Arguments to filter BlogPostTags to delete.
     * @example
     * // Delete a few BlogPostTags
     * const { count } = await prisma.blogPostTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlogPostTagDeleteManyArgs>(args?: SelectSubset<T, BlogPostTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlogPostTags
     * const blogPostTag = await prisma.blogPostTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlogPostTagUpdateManyArgs>(args: SelectSubset<T, BlogPostTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlogPostTags and returns the data updated in the database.
     * @param {BlogPostTagUpdateManyAndReturnArgs} args - Arguments to update many BlogPostTags.
     * @example
     * // Update many BlogPostTags
     * const blogPostTag = await prisma.blogPostTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlogPostTags and only return the `id`
     * const blogPostTagWithIdOnly = await prisma.blogPostTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlogPostTagUpdateManyAndReturnArgs>(args: SelectSubset<T, BlogPostTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlogPostTag.
     * @param {BlogPostTagUpsertArgs} args - Arguments to update or create a BlogPostTag.
     * @example
     * // Update or create a BlogPostTag
     * const blogPostTag = await prisma.blogPostTag.upsert({
     *   create: {
     *     // ... data to create a BlogPostTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlogPostTag we want to update
     *   }
     * })
     */
    upsert<T extends BlogPostTagUpsertArgs>(args: SelectSubset<T, BlogPostTagUpsertArgs<ExtArgs>>): Prisma__BlogPostTagClient<$Result.GetResult<Prisma.$BlogPostTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlogPostTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagCountArgs} args - Arguments to filter BlogPostTags to count.
     * @example
     * // Count the number of BlogPostTags
     * const count = await prisma.blogPostTag.count({
     *   where: {
     *     // ... the filter for the BlogPostTags we want to count
     *   }
     * })
    **/
    count<T extends BlogPostTagCountArgs>(
      args?: Subset<T, BlogPostTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogPostTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlogPostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogPostTagAggregateArgs>(args: Subset<T, BlogPostTagAggregateArgs>): Prisma.PrismaPromise<GetBlogPostTagAggregateType<T>>

    /**
     * Group by BlogPostTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogPostTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlogPostTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlogPostTagGroupByArgs['orderBy'] }
        : { orderBy?: BlogPostTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlogPostTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogPostTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlogPostTag model
   */
  readonly fields: BlogPostTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlogPostTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlogPostTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogPost<T extends BlogPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogPostDefaultArgs<ExtArgs>>): Prisma__BlogPostClient<$Result.GetResult<Prisma.$BlogPostPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    blogTag<T extends BlogTagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BlogTagDefaultArgs<ExtArgs>>): Prisma__BlogTagClient<$Result.GetResult<Prisma.$BlogTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlogPostTag model
   */
  interface BlogPostTagFieldRefs {
    readonly id: FieldRef<"BlogPostTag", 'Int'>
    readonly createdAt: FieldRef<"BlogPostTag", 'DateTime'>
    readonly blogPostId: FieldRef<"BlogPostTag", 'Int'>
    readonly blogTagId: FieldRef<"BlogPostTag", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * BlogPostTag findUnique
   */
  export type BlogPostTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag findUniqueOrThrow
   */
  export type BlogPostTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag findFirst
   */
  export type BlogPostTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostTags.
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostTags.
     */
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPostTag findFirstOrThrow
   */
  export type BlogPostTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTag to fetch.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlogPostTags.
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlogPostTags.
     */
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPostTag findMany
   */
  export type BlogPostTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter, which BlogPostTags to fetch.
     */
    where?: BlogPostTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlogPostTags to fetch.
     */
    orderBy?: BlogPostTagOrderByWithRelationInput | BlogPostTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlogPostTags.
     */
    cursor?: BlogPostTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlogPostTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlogPostTags.
     */
    skip?: number
    distinct?: BlogPostTagScalarFieldEnum | BlogPostTagScalarFieldEnum[]
  }

  /**
   * BlogPostTag create
   */
  export type BlogPostTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * The data needed to create a BlogPostTag.
     */
    data: XOR<BlogPostTagCreateInput, BlogPostTagUncheckedCreateInput>
  }

  /**
   * BlogPostTag createMany
   */
  export type BlogPostTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlogPostTags.
     */
    data: BlogPostTagCreateManyInput | BlogPostTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlogPostTag createManyAndReturn
   */
  export type BlogPostTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * The data used to create many BlogPostTags.
     */
    data: BlogPostTagCreateManyInput | BlogPostTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPostTag update
   */
  export type BlogPostTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * The data needed to update a BlogPostTag.
     */
    data: XOR<BlogPostTagUpdateInput, BlogPostTagUncheckedUpdateInput>
    /**
     * Choose, which BlogPostTag to update.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag updateMany
   */
  export type BlogPostTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlogPostTags.
     */
    data: XOR<BlogPostTagUpdateManyMutationInput, BlogPostTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostTags to update
     */
    where?: BlogPostTagWhereInput
    /**
     * Limit how many BlogPostTags to update.
     */
    limit?: number
  }

  /**
   * BlogPostTag updateManyAndReturn
   */
  export type BlogPostTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * The data used to update BlogPostTags.
     */
    data: XOR<BlogPostTagUpdateManyMutationInput, BlogPostTagUncheckedUpdateManyInput>
    /**
     * Filter which BlogPostTags to update
     */
    where?: BlogPostTagWhereInput
    /**
     * Limit how many BlogPostTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BlogPostTag upsert
   */
  export type BlogPostTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * The filter to search for the BlogPostTag to update in case it exists.
     */
    where: BlogPostTagWhereUniqueInput
    /**
     * In case the BlogPostTag found by the `where` argument doesn't exist, create a new BlogPostTag with this data.
     */
    create: XOR<BlogPostTagCreateInput, BlogPostTagUncheckedCreateInput>
    /**
     * In case the BlogPostTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlogPostTagUpdateInput, BlogPostTagUncheckedUpdateInput>
  }

  /**
   * BlogPostTag delete
   */
  export type BlogPostTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
    /**
     * Filter which BlogPostTag to delete.
     */
    where: BlogPostTagWhereUniqueInput
  }

  /**
   * BlogPostTag deleteMany
   */
  export type BlogPostTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlogPostTags to delete
     */
    where?: BlogPostTagWhereInput
    /**
     * Limit how many BlogPostTags to delete.
     */
    limit?: number
  }

  /**
   * BlogPostTag without action
   */
  export type BlogPostTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlogPostTag
     */
    select?: BlogPostTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlogPostTag
     */
    omit?: BlogPostTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BlogPostTagInclude<ExtArgs> | null
  }


  /**
   * Model ContactSubmission
   */

  export type AggregateContactSubmission = {
    _count: ContactSubmissionCountAggregateOutputType | null
    _avg: ContactSubmissionAvgAggregateOutputType | null
    _sum: ContactSubmissionSumAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  export type ContactSubmissionAvgAggregateOutputType = {
    id: number | null
  }

  export type ContactSubmissionSumAggregateOutputType = {
    id: number | null
  }

  export type ContactSubmissionMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type ContactSubmissionMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    subject: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type ContactSubmissionCountAggregateOutputType = {
    id: number
    name: number
    email: number
    subject: number
    message: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type ContactSubmissionAvgAggregateInputType = {
    id?: true
  }

  export type ContactSubmissionSumAggregateInputType = {
    id?: true
  }

  export type ContactSubmissionMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type ContactSubmissionMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type ContactSubmissionCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    subject?: true
    message?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type ContactSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmission to aggregate.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContactSubmissions
    **/
    _count?: true | ContactSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContactSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContactSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type GetContactSubmissionAggregateType<T extends ContactSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateContactSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactSubmission[P]>
      : GetScalarType<T[P], AggregateContactSubmission[P]>
  }




  export type ContactSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactSubmissionWhereInput
    orderBy?: ContactSubmissionOrderByWithAggregationInput | ContactSubmissionOrderByWithAggregationInput[]
    by: ContactSubmissionScalarFieldEnum[] | ContactSubmissionScalarFieldEnum
    having?: ContactSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactSubmissionCountAggregateInputType | true
    _avg?: ContactSubmissionAvgAggregateInputType
    _sum?: ContactSubmissionSumAggregateInputType
    _min?: ContactSubmissionMinAggregateInputType
    _max?: ContactSubmissionMaxAggregateInputType
  }

  export type ContactSubmissionGroupByOutputType = {
    id: number
    name: string
    email: string
    subject: string | null
    message: string
    isRead: boolean
    createdAt: Date
    _count: ContactSubmissionCountAggregateOutputType | null
    _avg: ContactSubmissionAvgAggregateOutputType | null
    _sum: ContactSubmissionSumAggregateOutputType | null
    _min: ContactSubmissionMinAggregateOutputType | null
    _max: ContactSubmissionMaxAggregateOutputType | null
  }

  type GetContactSubmissionGroupByPayload<T extends ContactSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], ContactSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type ContactSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactSubmission"]>

  export type ContactSubmissionSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    subject?: boolean
    message?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type ContactSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "subject" | "message" | "isRead" | "createdAt", ExtArgs["result"]["contactSubmission"]>

  export type $ContactSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContactSubmission"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      subject: string | null
      message: string
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["contactSubmission"]>
    composites: {}
  }

  type ContactSubmissionGetPayload<S extends boolean | null | undefined | ContactSubmissionDefaultArgs> = $Result.GetResult<Prisma.$ContactSubmissionPayload, S>

  type ContactSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactSubmissionCountAggregateInputType | true
    }

  export interface ContactSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContactSubmission'], meta: { name: 'ContactSubmission' } }
    /**
     * Find zero or one ContactSubmission that matches the filter.
     * @param {ContactSubmissionFindUniqueArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactSubmissionFindUniqueArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContactSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactSubmissionFindUniqueOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactSubmissionFindFirstArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContactSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindFirstOrThrowArgs} args - Arguments to find a ContactSubmission
     * @example
     * // Get one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContactSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany()
     * 
     * // Get first 10 ContactSubmissions
     * const contactSubmissions = await prisma.contactSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactSubmissionFindManyArgs>(args?: SelectSubset<T, ContactSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContactSubmission.
     * @param {ContactSubmissionCreateArgs} args - Arguments to create a ContactSubmission.
     * @example
     * // Create one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.create({
     *   data: {
     *     // ... data to create a ContactSubmission
     *   }
     * })
     * 
     */
    create<T extends ContactSubmissionCreateArgs>(args: SelectSubset<T, ContactSubmissionCreateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContactSubmissions.
     * @param {ContactSubmissionCreateManyArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactSubmissionCreateManyArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContactSubmissions and returns the data saved in the database.
     * @param {ContactSubmissionCreateManyAndReturnArgs} args - Arguments to create many ContactSubmissions.
     * @example
     * // Create many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContactSubmission.
     * @param {ContactSubmissionDeleteArgs} args - Arguments to delete one ContactSubmission.
     * @example
     * // Delete one ContactSubmission
     * const ContactSubmission = await prisma.contactSubmission.delete({
     *   where: {
     *     // ... filter to delete one ContactSubmission
     *   }
     * })
     * 
     */
    delete<T extends ContactSubmissionDeleteArgs>(args: SelectSubset<T, ContactSubmissionDeleteArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContactSubmission.
     * @param {ContactSubmissionUpdateArgs} args - Arguments to update one ContactSubmission.
     * @example
     * // Update one ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactSubmissionUpdateArgs>(args: SelectSubset<T, ContactSubmissionUpdateArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContactSubmissions.
     * @param {ContactSubmissionDeleteManyArgs} args - Arguments to filter ContactSubmissions to delete.
     * @example
     * // Delete a few ContactSubmissions
     * const { count } = await prisma.contactSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactSubmissionDeleteManyArgs>(args?: SelectSubset<T, ContactSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactSubmissionUpdateManyArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContactSubmissions and returns the data updated in the database.
     * @param {ContactSubmissionUpdateManyAndReturnArgs} args - Arguments to update many ContactSubmissions.
     * @example
     * // Update many ContactSubmissions
     * const contactSubmission = await prisma.contactSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContactSubmissions and only return the `id`
     * const contactSubmissionWithIdOnly = await prisma.contactSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContactSubmission.
     * @param {ContactSubmissionUpsertArgs} args - Arguments to update or create a ContactSubmission.
     * @example
     * // Update or create a ContactSubmission
     * const contactSubmission = await prisma.contactSubmission.upsert({
     *   create: {
     *     // ... data to create a ContactSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactSubmission we want to update
     *   }
     * })
     */
    upsert<T extends ContactSubmissionUpsertArgs>(args: SelectSubset<T, ContactSubmissionUpsertArgs<ExtArgs>>): Prisma__ContactSubmissionClient<$Result.GetResult<Prisma.$ContactSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContactSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionCountArgs} args - Arguments to filter ContactSubmissions to count.
     * @example
     * // Count the number of ContactSubmissions
     * const count = await prisma.contactSubmission.count({
     *   where: {
     *     // ... the filter for the ContactSubmissions we want to count
     *   }
     * })
    **/
    count<T extends ContactSubmissionCountArgs>(
      args?: Subset<T, ContactSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactSubmissionAggregateArgs>(args: Subset<T, ContactSubmissionAggregateArgs>): Prisma.PrismaPromise<GetContactSubmissionAggregateType<T>>

    /**
     * Group by ContactSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: ContactSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContactSubmission model
   */
  readonly fields: ContactSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContactSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContactSubmission model
   */
  interface ContactSubmissionFieldRefs {
    readonly id: FieldRef<"ContactSubmission", 'Int'>
    readonly name: FieldRef<"ContactSubmission", 'String'>
    readonly email: FieldRef<"ContactSubmission", 'String'>
    readonly subject: FieldRef<"ContactSubmission", 'String'>
    readonly message: FieldRef<"ContactSubmission", 'String'>
    readonly isRead: FieldRef<"ContactSubmission", 'Boolean'>
    readonly createdAt: FieldRef<"ContactSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ContactSubmission findUnique
   */
  export type ContactSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findUniqueOrThrow
   */
  export type ContactSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission findFirst
   */
  export type ContactSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findFirstOrThrow
   */
  export type ContactSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmission to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContactSubmissions.
     */
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission findMany
   */
  export type ContactSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter, which ContactSubmissions to fetch.
     */
    where?: ContactSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContactSubmissions to fetch.
     */
    orderBy?: ContactSubmissionOrderByWithRelationInput | ContactSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContactSubmissions.
     */
    cursor?: ContactSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContactSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContactSubmissions.
     */
    skip?: number
    distinct?: ContactSubmissionScalarFieldEnum | ContactSubmissionScalarFieldEnum[]
  }

  /**
   * ContactSubmission create
   */
  export type ContactSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to create a ContactSubmission.
     */
    data: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
  }

  /**
   * ContactSubmission createMany
   */
  export type ContactSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission createManyAndReturn
   */
  export type ContactSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many ContactSubmissions.
     */
    data: ContactSubmissionCreateManyInput | ContactSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContactSubmission update
   */
  export type ContactSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data needed to update a ContactSubmission.
     */
    data: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
    /**
     * Choose, which ContactSubmission to update.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission updateMany
   */
  export type ContactSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission updateManyAndReturn
   */
  export type ContactSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update ContactSubmissions.
     */
    data: XOR<ContactSubmissionUpdateManyMutationInput, ContactSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which ContactSubmissions to update
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to update.
     */
    limit?: number
  }

  /**
   * ContactSubmission upsert
   */
  export type ContactSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * The filter to search for the ContactSubmission to update in case it exists.
     */
    where: ContactSubmissionWhereUniqueInput
    /**
     * In case the ContactSubmission found by the `where` argument doesn't exist, create a new ContactSubmission with this data.
     */
    create: XOR<ContactSubmissionCreateInput, ContactSubmissionUncheckedCreateInput>
    /**
     * In case the ContactSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactSubmissionUpdateInput, ContactSubmissionUncheckedUpdateInput>
  }

  /**
   * ContactSubmission delete
   */
  export type ContactSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
    /**
     * Filter which ContactSubmission to delete.
     */
    where: ContactSubmissionWhereUniqueInput
  }

  /**
   * ContactSubmission deleteMany
   */
  export type ContactSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContactSubmissions to delete
     */
    where?: ContactSubmissionWhereInput
    /**
     * Limit how many ContactSubmissions to delete.
     */
    limit?: number
  }

  /**
   * ContactSubmission without action
   */
  export type ContactSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactSubmission
     */
    select?: ContactSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContactSubmission
     */
    omit?: ContactSubmissionOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    title: 'title',
    subtitle: 'subtitle',
    slug: 'slug',
    status: 'status',
    heroImage: 'heroImage',
    liveDemo: 'liveDemo',
    github: 'github',
    caseStudy: 'caseStudy',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectOverviewScalarFieldEnum: {
    id: 'id',
    problem: 'problem',
    solution: 'solution',
    role: 'role',
    impact: 'impact',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ProjectOverviewScalarFieldEnum = (typeof ProjectOverviewScalarFieldEnum)[keyof typeof ProjectOverviewScalarFieldEnum]


  export const ProjectMetricsScalarFieldEnum: {
    id: 'id',
    launchDate: 'launchDate',
    duration: 'duration',
    teamSize: 'teamSize',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ProjectMetricsScalarFieldEnum = (typeof ProjectMetricsScalarFieldEnum)[keyof typeof ProjectMetricsScalarFieldEnum]


  export const TechnicalDetailsScalarFieldEnum: {
    id: 'id',
    database: 'database',
    api: 'api',
    components: 'components',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type TechnicalDetailsScalarFieldEnum = (typeof TechnicalDetailsScalarFieldEnum)[keyof typeof TechnicalDetailsScalarFieldEnum]


  export const ScreenshotScalarFieldEnum: {
    id: 'id',
    url: 'url',
    description: 'description',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ScreenshotScalarFieldEnum = (typeof ScreenshotScalarFieldEnum)[keyof typeof ScreenshotScalarFieldEnum]


  export const TechnologyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    reason: 'reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type TechnologyScalarFieldEnum = (typeof TechnologyScalarFieldEnum)[keyof typeof TechnologyScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ProjectTagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    projectId: 'projectId',
    tagId: 'tagId'
  };

  export type ProjectTagScalarFieldEnum = (typeof ProjectTagScalarFieldEnum)[keyof typeof ProjectTagScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const BusinessOutcomeScalarFieldEnum: {
    id: 'id',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type BusinessOutcomeScalarFieldEnum = (typeof BusinessOutcomeScalarFieldEnum)[keyof typeof BusinessOutcomeScalarFieldEnum]


  export const ImprovementScalarFieldEnum: {
    id: 'id',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type ImprovementScalarFieldEnum = (typeof ImprovementScalarFieldEnum)[keyof typeof ImprovementScalarFieldEnum]


  export const NextStepScalarFieldEnum: {
    id: 'id',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type NextStepScalarFieldEnum = (typeof NextStepScalarFieldEnum)[keyof typeof NextStepScalarFieldEnum]


  export const FutureToolScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type FutureToolScalarFieldEnum = (typeof FutureToolScalarFieldEnum)[keyof typeof FutureToolScalarFieldEnum]


  export const PerformanceMetricScalarFieldEnum: {
    id: 'id',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    projectId: 'projectId'
  };

  export type PerformanceMetricScalarFieldEnum = (typeof PerformanceMetricScalarFieldEnum)[keyof typeof PerformanceMetricScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const BlogPostScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    title: 'title',
    subtitle: 'subtitle',
    excerpt: 'excerpt',
    metaDescription: 'metaDescription',
    socialImage: 'socialImage',
    readTime: 'readTime',
    wordCount: 'wordCount',
    views: 'views',
    heroImage: 'heroImage',
    heroImageAlt: 'heroImageAlt',
    heroImageCaption: 'heroImageCaption',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    author: 'author',
    categoryId: 'categoryId',
    seriesId: 'seriesId',
    seriesPart: 'seriesPart'
  };

  export type BlogPostScalarFieldEnum = (typeof BlogPostScalarFieldEnum)[keyof typeof BlogPostScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const SeriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    totalParts: 'totalParts',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SeriesScalarFieldEnum = (typeof SeriesScalarFieldEnum)[keyof typeof SeriesScalarFieldEnum]


  export const ContentBlockScalarFieldEnum: {
    id: 'id',
    type: 'type',
    order: 'order',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    level: 'level',
    language: 'language',
    codeTitle: 'codeTitle',
    imageUrl: 'imageUrl',
    imageAlt: 'imageAlt',
    imageCaption: 'imageCaption',
    imageAlignment: 'imageAlignment',
    calloutVariant: 'calloutVariant',
    calloutTitle: 'calloutTitle',
    quoteAuthor: 'quoteAuthor',
    listStyle: 'listStyle',
    listItems: 'listItems',
    videoType: 'videoType',
    videoId: 'videoId',
    videoTitle: 'videoTitle',
    paragraphStyle: 'paragraphStyle',
    blogPostId: 'blogPostId'
  };

  export type ContentBlockScalarFieldEnum = (typeof ContentBlockScalarFieldEnum)[keyof typeof ContentBlockScalarFieldEnum]


  export const BlogTagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BlogTagScalarFieldEnum = (typeof BlogTagScalarFieldEnum)[keyof typeof BlogTagScalarFieldEnum]


  export const BlogPostTagScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    blogPostId: 'blogPostId',
    blogTagId: 'blogTagId'
  };

  export type BlogPostTagScalarFieldEnum = (typeof BlogPostTagScalarFieldEnum)[keyof typeof BlogPostTagScalarFieldEnum]


  export const ContactSubmissionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    subject: 'subject',
    message: 'message',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type ContactSubmissionScalarFieldEnum = (typeof ContactSubmissionScalarFieldEnum)[keyof typeof ContactSubmissionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ContentBlockType'
   */
  export type EnumContentBlockTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentBlockType'>
    


  /**
   * Reference to a field of type 'ContentBlockType[]'
   */
  export type ListEnumContentBlockTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentBlockType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'CalloutVariant'
   */
  export type EnumCalloutVariantFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalloutVariant'>
    


  /**
   * Reference to a field of type 'CalloutVariant[]'
   */
  export type ListEnumCalloutVariantFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CalloutVariant[]'>
    


  /**
   * Reference to a field of type 'ListStyle'
   */
  export type EnumListStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListStyle'>
    


  /**
   * Reference to a field of type 'ListStyle[]'
   */
  export type ListEnumListStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ListStyle[]'>
    


  /**
   * Reference to a field of type 'VideoType'
   */
  export type EnumVideoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoType'>
    


  /**
   * Reference to a field of type 'VideoType[]'
   */
  export type ListEnumVideoTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VideoType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    
  /**
   * Deep Input Types
   */


  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: IntFilter<"Project"> | number
    title?: StringFilter<"Project"> | string
    subtitle?: StringFilter<"Project"> | string
    slug?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    heroImage?: StringFilter<"Project"> | string
    liveDemo?: StringNullableFilter<"Project"> | string | null
    github?: StringNullableFilter<"Project"> | string | null
    caseStudy?: StringNullableFilter<"Project"> | string | null
    publishedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    overview?: XOR<ProjectOverviewNullableScalarRelationFilter, ProjectOverviewWhereInput> | null
    metrics?: XOR<ProjectMetricsNullableScalarRelationFilter, ProjectMetricsWhereInput> | null
    technicalDetails?: XOR<TechnicalDetailsNullableScalarRelationFilter, TechnicalDetailsWhereInput> | null
    screenshots?: ScreenshotListRelationFilter
    technologies?: TechnologyListRelationFilter
    projectTags?: ProjectTagListRelationFilter
    lessons?: LessonListRelationFilter
    businessOutcomes?: BusinessOutcomeListRelationFilter
    improvements?: ImprovementListRelationFilter
    nextSteps?: NextStepListRelationFilter
    futureTools?: FutureToolListRelationFilter
    performanceMetrics?: PerformanceMetricListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    heroImage?: SortOrder
    liveDemo?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    caseStudy?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    overview?: ProjectOverviewOrderByWithRelationInput
    metrics?: ProjectMetricsOrderByWithRelationInput
    technicalDetails?: TechnicalDetailsOrderByWithRelationInput
    screenshots?: ScreenshotOrderByRelationAggregateInput
    technologies?: TechnologyOrderByRelationAggregateInput
    projectTags?: ProjectTagOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    businessOutcomes?: BusinessOutcomeOrderByRelationAggregateInput
    improvements?: ImprovementOrderByRelationAggregateInput
    nextSteps?: NextStepOrderByRelationAggregateInput
    futureTools?: FutureToolOrderByRelationAggregateInput
    performanceMetrics?: PerformanceMetricOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    title?: StringFilter<"Project"> | string
    subtitle?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    heroImage?: StringFilter<"Project"> | string
    liveDemo?: StringNullableFilter<"Project"> | string | null
    github?: StringNullableFilter<"Project"> | string | null
    caseStudy?: StringNullableFilter<"Project"> | string | null
    publishedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    overview?: XOR<ProjectOverviewNullableScalarRelationFilter, ProjectOverviewWhereInput> | null
    metrics?: XOR<ProjectMetricsNullableScalarRelationFilter, ProjectMetricsWhereInput> | null
    technicalDetails?: XOR<TechnicalDetailsNullableScalarRelationFilter, TechnicalDetailsWhereInput> | null
    screenshots?: ScreenshotListRelationFilter
    technologies?: TechnologyListRelationFilter
    projectTags?: ProjectTagListRelationFilter
    lessons?: LessonListRelationFilter
    businessOutcomes?: BusinessOutcomeListRelationFilter
    improvements?: ImprovementListRelationFilter
    nextSteps?: NextStepListRelationFilter
    futureTools?: FutureToolListRelationFilter
    performanceMetrics?: PerformanceMetricListRelationFilter
  }, "id" | "slug">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    heroImage?: SortOrder
    liveDemo?: SortOrderInput | SortOrder
    github?: SortOrderInput | SortOrder
    caseStudy?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Project"> | number
    title?: StringWithAggregatesFilter<"Project"> | string
    subtitle?: StringWithAggregatesFilter<"Project"> | string
    slug?: StringWithAggregatesFilter<"Project"> | string
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    heroImage?: StringWithAggregatesFilter<"Project"> | string
    liveDemo?: StringNullableWithAggregatesFilter<"Project"> | string | null
    github?: StringNullableWithAggregatesFilter<"Project"> | string | null
    caseStudy?: StringNullableWithAggregatesFilter<"Project"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectOverviewWhereInput = {
    AND?: ProjectOverviewWhereInput | ProjectOverviewWhereInput[]
    OR?: ProjectOverviewWhereInput[]
    NOT?: ProjectOverviewWhereInput | ProjectOverviewWhereInput[]
    id?: IntFilter<"ProjectOverview"> | number
    problem?: StringFilter<"ProjectOverview"> | string
    solution?: StringFilter<"ProjectOverview"> | string
    role?: StringFilter<"ProjectOverview"> | string
    impact?: StringFilter<"ProjectOverview"> | string
    createdAt?: DateTimeFilter<"ProjectOverview"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectOverview"> | Date | string
    projectId?: IntFilter<"ProjectOverview"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectOverviewOrderByWithRelationInput = {
    id?: SortOrder
    problem?: SortOrder
    solution?: SortOrder
    role?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectOverviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: ProjectOverviewWhereInput | ProjectOverviewWhereInput[]
    OR?: ProjectOverviewWhereInput[]
    NOT?: ProjectOverviewWhereInput | ProjectOverviewWhereInput[]
    problem?: StringFilter<"ProjectOverview"> | string
    solution?: StringFilter<"ProjectOverview"> | string
    role?: StringFilter<"ProjectOverview"> | string
    impact?: StringFilter<"ProjectOverview"> | string
    createdAt?: DateTimeFilter<"ProjectOverview"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectOverview"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type ProjectOverviewOrderByWithAggregationInput = {
    id?: SortOrder
    problem?: SortOrder
    solution?: SortOrder
    role?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ProjectOverviewCountOrderByAggregateInput
    _avg?: ProjectOverviewAvgOrderByAggregateInput
    _max?: ProjectOverviewMaxOrderByAggregateInput
    _min?: ProjectOverviewMinOrderByAggregateInput
    _sum?: ProjectOverviewSumOrderByAggregateInput
  }

  export type ProjectOverviewScalarWhereWithAggregatesInput = {
    AND?: ProjectOverviewScalarWhereWithAggregatesInput | ProjectOverviewScalarWhereWithAggregatesInput[]
    OR?: ProjectOverviewScalarWhereWithAggregatesInput[]
    NOT?: ProjectOverviewScalarWhereWithAggregatesInput | ProjectOverviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectOverview"> | number
    problem?: StringWithAggregatesFilter<"ProjectOverview"> | string
    solution?: StringWithAggregatesFilter<"ProjectOverview"> | string
    role?: StringWithAggregatesFilter<"ProjectOverview"> | string
    impact?: StringWithAggregatesFilter<"ProjectOverview"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectOverview"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectOverview"> | Date | string
    projectId?: IntWithAggregatesFilter<"ProjectOverview"> | number
  }

  export type ProjectMetricsWhereInput = {
    AND?: ProjectMetricsWhereInput | ProjectMetricsWhereInput[]
    OR?: ProjectMetricsWhereInput[]
    NOT?: ProjectMetricsWhereInput | ProjectMetricsWhereInput[]
    id?: IntFilter<"ProjectMetrics"> | number
    launchDate?: StringFilter<"ProjectMetrics"> | string
    duration?: StringFilter<"ProjectMetrics"> | string
    teamSize?: StringFilter<"ProjectMetrics"> | string
    createdAt?: DateTimeFilter<"ProjectMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMetrics"> | Date | string
    projectId?: IntFilter<"ProjectMetrics"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ProjectMetricsOrderByWithRelationInput = {
    id?: SortOrder
    launchDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ProjectMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: ProjectMetricsWhereInput | ProjectMetricsWhereInput[]
    OR?: ProjectMetricsWhereInput[]
    NOT?: ProjectMetricsWhereInput | ProjectMetricsWhereInput[]
    launchDate?: StringFilter<"ProjectMetrics"> | string
    duration?: StringFilter<"ProjectMetrics"> | string
    teamSize?: StringFilter<"ProjectMetrics"> | string
    createdAt?: DateTimeFilter<"ProjectMetrics"> | Date | string
    updatedAt?: DateTimeFilter<"ProjectMetrics"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type ProjectMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    launchDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ProjectMetricsCountOrderByAggregateInput
    _avg?: ProjectMetricsAvgOrderByAggregateInput
    _max?: ProjectMetricsMaxOrderByAggregateInput
    _min?: ProjectMetricsMinOrderByAggregateInput
    _sum?: ProjectMetricsSumOrderByAggregateInput
  }

  export type ProjectMetricsScalarWhereWithAggregatesInput = {
    AND?: ProjectMetricsScalarWhereWithAggregatesInput | ProjectMetricsScalarWhereWithAggregatesInput[]
    OR?: ProjectMetricsScalarWhereWithAggregatesInput[]
    NOT?: ProjectMetricsScalarWhereWithAggregatesInput | ProjectMetricsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectMetrics"> | number
    launchDate?: StringWithAggregatesFilter<"ProjectMetrics"> | string
    duration?: StringWithAggregatesFilter<"ProjectMetrics"> | string
    teamSize?: StringWithAggregatesFilter<"ProjectMetrics"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ProjectMetrics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProjectMetrics"> | Date | string
    projectId?: IntWithAggregatesFilter<"ProjectMetrics"> | number
  }

  export type TechnicalDetailsWhereInput = {
    AND?: TechnicalDetailsWhereInput | TechnicalDetailsWhereInput[]
    OR?: TechnicalDetailsWhereInput[]
    NOT?: TechnicalDetailsWhereInput | TechnicalDetailsWhereInput[]
    id?: IntFilter<"TechnicalDetails"> | number
    database?: StringFilter<"TechnicalDetails"> | string
    api?: StringFilter<"TechnicalDetails"> | string
    components?: StringFilter<"TechnicalDetails"> | string
    createdAt?: DateTimeFilter<"TechnicalDetails"> | Date | string
    updatedAt?: DateTimeFilter<"TechnicalDetails"> | Date | string
    projectId?: IntFilter<"TechnicalDetails"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TechnicalDetailsOrderByWithRelationInput = {
    id?: SortOrder
    database?: SortOrder
    api?: SortOrder
    components?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type TechnicalDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId?: number
    AND?: TechnicalDetailsWhereInput | TechnicalDetailsWhereInput[]
    OR?: TechnicalDetailsWhereInput[]
    NOT?: TechnicalDetailsWhereInput | TechnicalDetailsWhereInput[]
    database?: StringFilter<"TechnicalDetails"> | string
    api?: StringFilter<"TechnicalDetails"> | string
    components?: StringFilter<"TechnicalDetails"> | string
    createdAt?: DateTimeFilter<"TechnicalDetails"> | Date | string
    updatedAt?: DateTimeFilter<"TechnicalDetails"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id" | "projectId">

  export type TechnicalDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    database?: SortOrder
    api?: SortOrder
    components?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: TechnicalDetailsCountOrderByAggregateInput
    _avg?: TechnicalDetailsAvgOrderByAggregateInput
    _max?: TechnicalDetailsMaxOrderByAggregateInput
    _min?: TechnicalDetailsMinOrderByAggregateInput
    _sum?: TechnicalDetailsSumOrderByAggregateInput
  }

  export type TechnicalDetailsScalarWhereWithAggregatesInput = {
    AND?: TechnicalDetailsScalarWhereWithAggregatesInput | TechnicalDetailsScalarWhereWithAggregatesInput[]
    OR?: TechnicalDetailsScalarWhereWithAggregatesInput[]
    NOT?: TechnicalDetailsScalarWhereWithAggregatesInput | TechnicalDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TechnicalDetails"> | number
    database?: StringWithAggregatesFilter<"TechnicalDetails"> | string
    api?: StringWithAggregatesFilter<"TechnicalDetails"> | string
    components?: StringWithAggregatesFilter<"TechnicalDetails"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TechnicalDetails"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TechnicalDetails"> | Date | string
    projectId?: IntWithAggregatesFilter<"TechnicalDetails"> | number
  }

  export type ScreenshotWhereInput = {
    AND?: ScreenshotWhereInput | ScreenshotWhereInput[]
    OR?: ScreenshotWhereInput[]
    NOT?: ScreenshotWhereInput | ScreenshotWhereInput[]
    id?: IntFilter<"Screenshot"> | number
    url?: StringFilter<"Screenshot"> | string
    description?: StringFilter<"Screenshot"> | string
    order?: IntFilter<"Screenshot"> | number
    createdAt?: DateTimeFilter<"Screenshot"> | Date | string
    updatedAt?: DateTimeFilter<"Screenshot"> | Date | string
    projectId?: IntFilter<"Screenshot"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ScreenshotOrderByWithRelationInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ScreenshotWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScreenshotWhereInput | ScreenshotWhereInput[]
    OR?: ScreenshotWhereInput[]
    NOT?: ScreenshotWhereInput | ScreenshotWhereInput[]
    url?: StringFilter<"Screenshot"> | string
    description?: StringFilter<"Screenshot"> | string
    order?: IntFilter<"Screenshot"> | number
    createdAt?: DateTimeFilter<"Screenshot"> | Date | string
    updatedAt?: DateTimeFilter<"Screenshot"> | Date | string
    projectId?: IntFilter<"Screenshot"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ScreenshotOrderByWithAggregationInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ScreenshotCountOrderByAggregateInput
    _avg?: ScreenshotAvgOrderByAggregateInput
    _max?: ScreenshotMaxOrderByAggregateInput
    _min?: ScreenshotMinOrderByAggregateInput
    _sum?: ScreenshotSumOrderByAggregateInput
  }

  export type ScreenshotScalarWhereWithAggregatesInput = {
    AND?: ScreenshotScalarWhereWithAggregatesInput | ScreenshotScalarWhereWithAggregatesInput[]
    OR?: ScreenshotScalarWhereWithAggregatesInput[]
    NOT?: ScreenshotScalarWhereWithAggregatesInput | ScreenshotScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Screenshot"> | number
    url?: StringWithAggregatesFilter<"Screenshot"> | string
    description?: StringWithAggregatesFilter<"Screenshot"> | string
    order?: IntWithAggregatesFilter<"Screenshot"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Screenshot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Screenshot"> | Date | string
    projectId?: IntWithAggregatesFilter<"Screenshot"> | number
  }

  export type TechnologyWhereInput = {
    AND?: TechnologyWhereInput | TechnologyWhereInput[]
    OR?: TechnologyWhereInput[]
    NOT?: TechnologyWhereInput | TechnologyWhereInput[]
    id?: IntFilter<"Technology"> | number
    name?: StringFilter<"Technology"> | string
    reason?: StringFilter<"Technology"> | string
    createdAt?: DateTimeFilter<"Technology"> | Date | string
    updatedAt?: DateTimeFilter<"Technology"> | Date | string
    projectId?: IntFilter<"Technology"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type TechnologyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type TechnologyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TechnologyWhereInput | TechnologyWhereInput[]
    OR?: TechnologyWhereInput[]
    NOT?: TechnologyWhereInput | TechnologyWhereInput[]
    name?: StringFilter<"Technology"> | string
    reason?: StringFilter<"Technology"> | string
    createdAt?: DateTimeFilter<"Technology"> | Date | string
    updatedAt?: DateTimeFilter<"Technology"> | Date | string
    projectId?: IntFilter<"Technology"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type TechnologyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: TechnologyCountOrderByAggregateInput
    _avg?: TechnologyAvgOrderByAggregateInput
    _max?: TechnologyMaxOrderByAggregateInput
    _min?: TechnologyMinOrderByAggregateInput
    _sum?: TechnologySumOrderByAggregateInput
  }

  export type TechnologyScalarWhereWithAggregatesInput = {
    AND?: TechnologyScalarWhereWithAggregatesInput | TechnologyScalarWhereWithAggregatesInput[]
    OR?: TechnologyScalarWhereWithAggregatesInput[]
    NOT?: TechnologyScalarWhereWithAggregatesInput | TechnologyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Technology"> | number
    name?: StringWithAggregatesFilter<"Technology"> | string
    reason?: StringWithAggregatesFilter<"Technology"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Technology"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Technology"> | Date | string
    projectId?: IntWithAggregatesFilter<"Technology"> | number
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: IntFilter<"Tag"> | number
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    projectTags?: ProjectTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectTags?: ProjectTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    projectTags?: ProjectTagListRelationFilter
  }, "id" | "name" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _avg?: TagAvgOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
    _sum?: TagSumOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tag"> | number
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ProjectTagWhereInput = {
    AND?: ProjectTagWhereInput | ProjectTagWhereInput[]
    OR?: ProjectTagWhereInput[]
    NOT?: ProjectTagWhereInput | ProjectTagWhereInput[]
    id?: IntFilter<"ProjectTag"> | number
    createdAt?: DateTimeFilter<"ProjectTag"> | Date | string
    projectId?: IntFilter<"ProjectTag"> | number
    tagId?: IntFilter<"ProjectTag"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ProjectTagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
    project?: ProjectOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ProjectTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    projectId_tagId?: ProjectTagProjectIdTagIdCompoundUniqueInput
    AND?: ProjectTagWhereInput | ProjectTagWhereInput[]
    OR?: ProjectTagWhereInput[]
    NOT?: ProjectTagWhereInput | ProjectTagWhereInput[]
    createdAt?: DateTimeFilter<"ProjectTag"> | Date | string
    projectId?: IntFilter<"ProjectTag"> | number
    tagId?: IntFilter<"ProjectTag"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "id" | "projectId_tagId">

  export type ProjectTagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
    _count?: ProjectTagCountOrderByAggregateInput
    _avg?: ProjectTagAvgOrderByAggregateInput
    _max?: ProjectTagMaxOrderByAggregateInput
    _min?: ProjectTagMinOrderByAggregateInput
    _sum?: ProjectTagSumOrderByAggregateInput
  }

  export type ProjectTagScalarWhereWithAggregatesInput = {
    AND?: ProjectTagScalarWhereWithAggregatesInput | ProjectTagScalarWhereWithAggregatesInput[]
    OR?: ProjectTagScalarWhereWithAggregatesInput[]
    NOT?: ProjectTagScalarWhereWithAggregatesInput | ProjectTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProjectTag"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProjectTag"> | Date | string
    projectId?: IntWithAggregatesFilter<"ProjectTag"> | number
    tagId?: IntWithAggregatesFilter<"ProjectTag"> | number
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: IntFilter<"Lesson"> | number
    description?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    projectId?: IntFilter<"Lesson"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    description?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    projectId?: IntFilter<"Lesson"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Lesson"> | number
    description?: StringWithAggregatesFilter<"Lesson"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    projectId?: IntWithAggregatesFilter<"Lesson"> | number
  }

  export type BusinessOutcomeWhereInput = {
    AND?: BusinessOutcomeWhereInput | BusinessOutcomeWhereInput[]
    OR?: BusinessOutcomeWhereInput[]
    NOT?: BusinessOutcomeWhereInput | BusinessOutcomeWhereInput[]
    id?: IntFilter<"BusinessOutcome"> | number
    description?: StringFilter<"BusinessOutcome"> | string
    createdAt?: DateTimeFilter<"BusinessOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessOutcome"> | Date | string
    projectId?: IntFilter<"BusinessOutcome"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type BusinessOutcomeOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type BusinessOutcomeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BusinessOutcomeWhereInput | BusinessOutcomeWhereInput[]
    OR?: BusinessOutcomeWhereInput[]
    NOT?: BusinessOutcomeWhereInput | BusinessOutcomeWhereInput[]
    description?: StringFilter<"BusinessOutcome"> | string
    createdAt?: DateTimeFilter<"BusinessOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessOutcome"> | Date | string
    projectId?: IntFilter<"BusinessOutcome"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type BusinessOutcomeOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: BusinessOutcomeCountOrderByAggregateInput
    _avg?: BusinessOutcomeAvgOrderByAggregateInput
    _max?: BusinessOutcomeMaxOrderByAggregateInput
    _min?: BusinessOutcomeMinOrderByAggregateInput
    _sum?: BusinessOutcomeSumOrderByAggregateInput
  }

  export type BusinessOutcomeScalarWhereWithAggregatesInput = {
    AND?: BusinessOutcomeScalarWhereWithAggregatesInput | BusinessOutcomeScalarWhereWithAggregatesInput[]
    OR?: BusinessOutcomeScalarWhereWithAggregatesInput[]
    NOT?: BusinessOutcomeScalarWhereWithAggregatesInput | BusinessOutcomeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BusinessOutcome"> | number
    description?: StringWithAggregatesFilter<"BusinessOutcome"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BusinessOutcome"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BusinessOutcome"> | Date | string
    projectId?: IntWithAggregatesFilter<"BusinessOutcome"> | number
  }

  export type ImprovementWhereInput = {
    AND?: ImprovementWhereInput | ImprovementWhereInput[]
    OR?: ImprovementWhereInput[]
    NOT?: ImprovementWhereInput | ImprovementWhereInput[]
    id?: IntFilter<"Improvement"> | number
    description?: StringFilter<"Improvement"> | string
    createdAt?: DateTimeFilter<"Improvement"> | Date | string
    updatedAt?: DateTimeFilter<"Improvement"> | Date | string
    projectId?: IntFilter<"Improvement"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type ImprovementOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type ImprovementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ImprovementWhereInput | ImprovementWhereInput[]
    OR?: ImprovementWhereInput[]
    NOT?: ImprovementWhereInput | ImprovementWhereInput[]
    description?: StringFilter<"Improvement"> | string
    createdAt?: DateTimeFilter<"Improvement"> | Date | string
    updatedAt?: DateTimeFilter<"Improvement"> | Date | string
    projectId?: IntFilter<"Improvement"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type ImprovementOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: ImprovementCountOrderByAggregateInput
    _avg?: ImprovementAvgOrderByAggregateInput
    _max?: ImprovementMaxOrderByAggregateInput
    _min?: ImprovementMinOrderByAggregateInput
    _sum?: ImprovementSumOrderByAggregateInput
  }

  export type ImprovementScalarWhereWithAggregatesInput = {
    AND?: ImprovementScalarWhereWithAggregatesInput | ImprovementScalarWhereWithAggregatesInput[]
    OR?: ImprovementScalarWhereWithAggregatesInput[]
    NOT?: ImprovementScalarWhereWithAggregatesInput | ImprovementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Improvement"> | number
    description?: StringWithAggregatesFilter<"Improvement"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Improvement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Improvement"> | Date | string
    projectId?: IntWithAggregatesFilter<"Improvement"> | number
  }

  export type NextStepWhereInput = {
    AND?: NextStepWhereInput | NextStepWhereInput[]
    OR?: NextStepWhereInput[]
    NOT?: NextStepWhereInput | NextStepWhereInput[]
    id?: IntFilter<"NextStep"> | number
    description?: StringFilter<"NextStep"> | string
    createdAt?: DateTimeFilter<"NextStep"> | Date | string
    updatedAt?: DateTimeFilter<"NextStep"> | Date | string
    projectId?: IntFilter<"NextStep"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type NextStepOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type NextStepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NextStepWhereInput | NextStepWhereInput[]
    OR?: NextStepWhereInput[]
    NOT?: NextStepWhereInput | NextStepWhereInput[]
    description?: StringFilter<"NextStep"> | string
    createdAt?: DateTimeFilter<"NextStep"> | Date | string
    updatedAt?: DateTimeFilter<"NextStep"> | Date | string
    projectId?: IntFilter<"NextStep"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type NextStepOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: NextStepCountOrderByAggregateInput
    _avg?: NextStepAvgOrderByAggregateInput
    _max?: NextStepMaxOrderByAggregateInput
    _min?: NextStepMinOrderByAggregateInput
    _sum?: NextStepSumOrderByAggregateInput
  }

  export type NextStepScalarWhereWithAggregatesInput = {
    AND?: NextStepScalarWhereWithAggregatesInput | NextStepScalarWhereWithAggregatesInput[]
    OR?: NextStepScalarWhereWithAggregatesInput[]
    NOT?: NextStepScalarWhereWithAggregatesInput | NextStepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NextStep"> | number
    description?: StringWithAggregatesFilter<"NextStep"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NextStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NextStep"> | Date | string
    projectId?: IntWithAggregatesFilter<"NextStep"> | number
  }

  export type FutureToolWhereInput = {
    AND?: FutureToolWhereInput | FutureToolWhereInput[]
    OR?: FutureToolWhereInput[]
    NOT?: FutureToolWhereInput | FutureToolWhereInput[]
    id?: IntFilter<"FutureTool"> | number
    name?: StringFilter<"FutureTool"> | string
    createdAt?: DateTimeFilter<"FutureTool"> | Date | string
    updatedAt?: DateTimeFilter<"FutureTool"> | Date | string
    projectId?: IntFilter<"FutureTool"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type FutureToolOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type FutureToolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FutureToolWhereInput | FutureToolWhereInput[]
    OR?: FutureToolWhereInput[]
    NOT?: FutureToolWhereInput | FutureToolWhereInput[]
    name?: StringFilter<"FutureTool"> | string
    createdAt?: DateTimeFilter<"FutureTool"> | Date | string
    updatedAt?: DateTimeFilter<"FutureTool"> | Date | string
    projectId?: IntFilter<"FutureTool"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type FutureToolOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: FutureToolCountOrderByAggregateInput
    _avg?: FutureToolAvgOrderByAggregateInput
    _max?: FutureToolMaxOrderByAggregateInput
    _min?: FutureToolMinOrderByAggregateInput
    _sum?: FutureToolSumOrderByAggregateInput
  }

  export type FutureToolScalarWhereWithAggregatesInput = {
    AND?: FutureToolScalarWhereWithAggregatesInput | FutureToolScalarWhereWithAggregatesInput[]
    OR?: FutureToolScalarWhereWithAggregatesInput[]
    NOT?: FutureToolScalarWhereWithAggregatesInput | FutureToolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FutureTool"> | number
    name?: StringWithAggregatesFilter<"FutureTool"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FutureTool"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FutureTool"> | Date | string
    projectId?: IntWithAggregatesFilter<"FutureTool"> | number
  }

  export type PerformanceMetricWhereInput = {
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    id?: IntFilter<"PerformanceMetric"> | number
    description?: StringFilter<"PerformanceMetric"> | string
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    projectId?: IntFilter<"PerformanceMetric"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type PerformanceMetricOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    project?: ProjectOrderByWithRelationInput
  }

  export type PerformanceMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    OR?: PerformanceMetricWhereInput[]
    NOT?: PerformanceMetricWhereInput | PerformanceMetricWhereInput[]
    description?: StringFilter<"PerformanceMetric"> | string
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    projectId?: IntFilter<"PerformanceMetric"> | number
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type PerformanceMetricOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
    _count?: PerformanceMetricCountOrderByAggregateInput
    _avg?: PerformanceMetricAvgOrderByAggregateInput
    _max?: PerformanceMetricMaxOrderByAggregateInput
    _min?: PerformanceMetricMinOrderByAggregateInput
    _sum?: PerformanceMetricSumOrderByAggregateInput
  }

  export type PerformanceMetricScalarWhereWithAggregatesInput = {
    AND?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    OR?: PerformanceMetricScalarWhereWithAggregatesInput[]
    NOT?: PerformanceMetricScalarWhereWithAggregatesInput | PerformanceMetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PerformanceMetric"> | number
    description?: StringWithAggregatesFilter<"PerformanceMetric"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PerformanceMetric"> | Date | string
    projectId?: IntWithAggregatesFilter<"PerformanceMetric"> | number
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type BlogPostWhereInput = {
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    id?: IntFilter<"BlogPost"> | number
    slug?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    subtitle?: StringNullableFilter<"BlogPost"> | string | null
    excerpt?: StringFilter<"BlogPost"> | string
    metaDescription?: StringFilter<"BlogPost"> | string
    socialImage?: StringNullableFilter<"BlogPost"> | string | null
    readTime?: IntFilter<"BlogPost"> | number
    wordCount?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    heroImage?: StringNullableFilter<"BlogPost"> | string | null
    heroImageAlt?: StringNullableFilter<"BlogPost"> | string | null
    heroImageCaption?: StringNullableFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: JsonFilter<"BlogPost">
    categoryId?: IntNullableFilter<"BlogPost"> | number | null
    seriesId?: IntNullableFilter<"BlogPost"> | number | null
    seriesPart?: IntNullableFilter<"BlogPost"> | number | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null
    contentBlocks?: ContentBlockListRelationFilter
    blogPostTags?: BlogPostTagListRelationFilter
  }

  export type BlogPostOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    excerpt?: SortOrder
    metaDescription?: SortOrder
    socialImage?: SortOrderInput | SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    heroImage?: SortOrderInput | SortOrder
    heroImageAlt?: SortOrderInput | SortOrder
    heroImageCaption?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    seriesId?: SortOrderInput | SortOrder
    seriesPart?: SortOrderInput | SortOrder
    category?: CategoryOrderByWithRelationInput
    series?: SeriesOrderByWithRelationInput
    contentBlocks?: ContentBlockOrderByRelationAggregateInput
    blogPostTags?: BlogPostTagOrderByRelationAggregateInput
  }

  export type BlogPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    slug?: string
    AND?: BlogPostWhereInput | BlogPostWhereInput[]
    OR?: BlogPostWhereInput[]
    NOT?: BlogPostWhereInput | BlogPostWhereInput[]
    title?: StringFilter<"BlogPost"> | string
    subtitle?: StringNullableFilter<"BlogPost"> | string | null
    excerpt?: StringFilter<"BlogPost"> | string
    metaDescription?: StringFilter<"BlogPost"> | string
    socialImage?: StringNullableFilter<"BlogPost"> | string | null
    readTime?: IntFilter<"BlogPost"> | number
    wordCount?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    heroImage?: StringNullableFilter<"BlogPost"> | string | null
    heroImageAlt?: StringNullableFilter<"BlogPost"> | string | null
    heroImageCaption?: StringNullableFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: JsonFilter<"BlogPost">
    categoryId?: IntNullableFilter<"BlogPost"> | number | null
    seriesId?: IntNullableFilter<"BlogPost"> | number | null
    seriesPart?: IntNullableFilter<"BlogPost"> | number | null
    category?: XOR<CategoryNullableScalarRelationFilter, CategoryWhereInput> | null
    series?: XOR<SeriesNullableScalarRelationFilter, SeriesWhereInput> | null
    contentBlocks?: ContentBlockListRelationFilter
    blogPostTags?: BlogPostTagListRelationFilter
  }, "id" | "slug">

  export type BlogPostOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrderInput | SortOrder
    excerpt?: SortOrder
    metaDescription?: SortOrder
    socialImage?: SortOrderInput | SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    heroImage?: SortOrderInput | SortOrder
    heroImageAlt?: SortOrderInput | SortOrder
    heroImageCaption?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    seriesId?: SortOrderInput | SortOrder
    seriesPart?: SortOrderInput | SortOrder
    _count?: BlogPostCountOrderByAggregateInput
    _avg?: BlogPostAvgOrderByAggregateInput
    _max?: BlogPostMaxOrderByAggregateInput
    _min?: BlogPostMinOrderByAggregateInput
    _sum?: BlogPostSumOrderByAggregateInput
  }

  export type BlogPostScalarWhereWithAggregatesInput = {
    AND?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    OR?: BlogPostScalarWhereWithAggregatesInput[]
    NOT?: BlogPostScalarWhereWithAggregatesInput | BlogPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogPost"> | number
    slug?: StringWithAggregatesFilter<"BlogPost"> | string
    title?: StringWithAggregatesFilter<"BlogPost"> | string
    subtitle?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    excerpt?: StringWithAggregatesFilter<"BlogPost"> | string
    metaDescription?: StringWithAggregatesFilter<"BlogPost"> | string
    socialImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    readTime?: IntWithAggregatesFilter<"BlogPost"> | number
    wordCount?: IntWithAggregatesFilter<"BlogPost"> | number
    views?: IntWithAggregatesFilter<"BlogPost"> | number
    heroImage?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    heroImageAlt?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    heroImageCaption?: StringNullableWithAggregatesFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogPost"> | Date | string
    author?: JsonWithAggregatesFilter<"BlogPost">
    categoryId?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
    seriesId?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
    seriesPart?: IntNullableWithAggregatesFilter<"BlogPost"> | number | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    slug?: StringFilter<"Category"> | string
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    blogPosts?: BlogPostListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blogPosts?: BlogPostOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    createdAt?: DateTimeFilter<"Category"> | Date | string
    updatedAt?: DateTimeFilter<"Category"> | Date | string
    blogPosts?: BlogPostListRelationFilter
  }, "id" | "name" | "slug">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
    slug?: StringWithAggregatesFilter<"Category"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Category"> | Date | string
  }

  export type SeriesWhereInput = {
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    id?: IntFilter<"Series"> | number
    name?: StringFilter<"Series"> | string
    slug?: StringFilter<"Series"> | string
    description?: StringNullableFilter<"Series"> | string | null
    totalParts?: IntFilter<"Series"> | number
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
    blogPosts?: BlogPostListRelationFilter
  }

  export type SeriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    totalParts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blogPosts?: BlogPostOrderByRelationAggregateInput
  }

  export type SeriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: SeriesWhereInput | SeriesWhereInput[]
    OR?: SeriesWhereInput[]
    NOT?: SeriesWhereInput | SeriesWhereInput[]
    description?: StringNullableFilter<"Series"> | string | null
    totalParts?: IntFilter<"Series"> | number
    createdAt?: DateTimeFilter<"Series"> | Date | string
    updatedAt?: DateTimeFilter<"Series"> | Date | string
    blogPosts?: BlogPostListRelationFilter
  }, "id" | "name" | "slug">

  export type SeriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    totalParts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SeriesCountOrderByAggregateInput
    _avg?: SeriesAvgOrderByAggregateInput
    _max?: SeriesMaxOrderByAggregateInput
    _min?: SeriesMinOrderByAggregateInput
    _sum?: SeriesSumOrderByAggregateInput
  }

  export type SeriesScalarWhereWithAggregatesInput = {
    AND?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    OR?: SeriesScalarWhereWithAggregatesInput[]
    NOT?: SeriesScalarWhereWithAggregatesInput | SeriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Series"> | number
    name?: StringWithAggregatesFilter<"Series"> | string
    slug?: StringWithAggregatesFilter<"Series"> | string
    description?: StringNullableWithAggregatesFilter<"Series"> | string | null
    totalParts?: IntWithAggregatesFilter<"Series"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Series"> | Date | string
  }

  export type ContentBlockWhereInput = {
    AND?: ContentBlockWhereInput | ContentBlockWhereInput[]
    OR?: ContentBlockWhereInput[]
    NOT?: ContentBlockWhereInput | ContentBlockWhereInput[]
    id?: IntFilter<"ContentBlock"> | number
    type?: EnumContentBlockTypeFilter<"ContentBlock"> | $Enums.ContentBlockType
    order?: FloatFilter<"ContentBlock"> | number
    content?: StringFilter<"ContentBlock"> | string
    createdAt?: DateTimeFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ContentBlock"> | Date | string
    level?: IntNullableFilter<"ContentBlock"> | number | null
    language?: StringNullableFilter<"ContentBlock"> | string | null
    codeTitle?: StringNullableFilter<"ContentBlock"> | string | null
    imageUrl?: StringNullableFilter<"ContentBlock"> | string | null
    imageAlt?: StringNullableFilter<"ContentBlock"> | string | null
    imageCaption?: StringNullableFilter<"ContentBlock"> | string | null
    imageAlignment?: StringNullableFilter<"ContentBlock"> | string | null
    calloutVariant?: EnumCalloutVariantNullableFilter<"ContentBlock"> | $Enums.CalloutVariant | null
    calloutTitle?: StringNullableFilter<"ContentBlock"> | string | null
    quoteAuthor?: StringNullableFilter<"ContentBlock"> | string | null
    listStyle?: EnumListStyleNullableFilter<"ContentBlock"> | $Enums.ListStyle | null
    listItems?: JsonNullableFilter<"ContentBlock">
    videoType?: EnumVideoTypeNullableFilter<"ContentBlock"> | $Enums.VideoType | null
    videoId?: StringNullableFilter<"ContentBlock"> | string | null
    videoTitle?: StringNullableFilter<"ContentBlock"> | string | null
    paragraphStyle?: StringNullableFilter<"ContentBlock"> | string | null
    blogPostId?: IntFilter<"ContentBlock"> | number
    blogPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }

  export type ContentBlockOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    codeTitle?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    imageAlt?: SortOrderInput | SortOrder
    imageCaption?: SortOrderInput | SortOrder
    imageAlignment?: SortOrderInput | SortOrder
    calloutVariant?: SortOrderInput | SortOrder
    calloutTitle?: SortOrderInput | SortOrder
    quoteAuthor?: SortOrderInput | SortOrder
    listStyle?: SortOrderInput | SortOrder
    listItems?: SortOrderInput | SortOrder
    videoType?: SortOrderInput | SortOrder
    videoId?: SortOrderInput | SortOrder
    videoTitle?: SortOrderInput | SortOrder
    paragraphStyle?: SortOrderInput | SortOrder
    blogPostId?: SortOrder
    blogPost?: BlogPostOrderByWithRelationInput
  }

  export type ContentBlockWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContentBlockWhereInput | ContentBlockWhereInput[]
    OR?: ContentBlockWhereInput[]
    NOT?: ContentBlockWhereInput | ContentBlockWhereInput[]
    type?: EnumContentBlockTypeFilter<"ContentBlock"> | $Enums.ContentBlockType
    order?: FloatFilter<"ContentBlock"> | number
    content?: StringFilter<"ContentBlock"> | string
    createdAt?: DateTimeFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ContentBlock"> | Date | string
    level?: IntNullableFilter<"ContentBlock"> | number | null
    language?: StringNullableFilter<"ContentBlock"> | string | null
    codeTitle?: StringNullableFilter<"ContentBlock"> | string | null
    imageUrl?: StringNullableFilter<"ContentBlock"> | string | null
    imageAlt?: StringNullableFilter<"ContentBlock"> | string | null
    imageCaption?: StringNullableFilter<"ContentBlock"> | string | null
    imageAlignment?: StringNullableFilter<"ContentBlock"> | string | null
    calloutVariant?: EnumCalloutVariantNullableFilter<"ContentBlock"> | $Enums.CalloutVariant | null
    calloutTitle?: StringNullableFilter<"ContentBlock"> | string | null
    quoteAuthor?: StringNullableFilter<"ContentBlock"> | string | null
    listStyle?: EnumListStyleNullableFilter<"ContentBlock"> | $Enums.ListStyle | null
    listItems?: JsonNullableFilter<"ContentBlock">
    videoType?: EnumVideoTypeNullableFilter<"ContentBlock"> | $Enums.VideoType | null
    videoId?: StringNullableFilter<"ContentBlock"> | string | null
    videoTitle?: StringNullableFilter<"ContentBlock"> | string | null
    paragraphStyle?: StringNullableFilter<"ContentBlock"> | string | null
    blogPostId?: IntFilter<"ContentBlock"> | number
    blogPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
  }, "id">

  export type ContentBlockOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrderInput | SortOrder
    language?: SortOrderInput | SortOrder
    codeTitle?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    imageAlt?: SortOrderInput | SortOrder
    imageCaption?: SortOrderInput | SortOrder
    imageAlignment?: SortOrderInput | SortOrder
    calloutVariant?: SortOrderInput | SortOrder
    calloutTitle?: SortOrderInput | SortOrder
    quoteAuthor?: SortOrderInput | SortOrder
    listStyle?: SortOrderInput | SortOrder
    listItems?: SortOrderInput | SortOrder
    videoType?: SortOrderInput | SortOrder
    videoId?: SortOrderInput | SortOrder
    videoTitle?: SortOrderInput | SortOrder
    paragraphStyle?: SortOrderInput | SortOrder
    blogPostId?: SortOrder
    _count?: ContentBlockCountOrderByAggregateInput
    _avg?: ContentBlockAvgOrderByAggregateInput
    _max?: ContentBlockMaxOrderByAggregateInput
    _min?: ContentBlockMinOrderByAggregateInput
    _sum?: ContentBlockSumOrderByAggregateInput
  }

  export type ContentBlockScalarWhereWithAggregatesInput = {
    AND?: ContentBlockScalarWhereWithAggregatesInput | ContentBlockScalarWhereWithAggregatesInput[]
    OR?: ContentBlockScalarWhereWithAggregatesInput[]
    NOT?: ContentBlockScalarWhereWithAggregatesInput | ContentBlockScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContentBlock"> | number
    type?: EnumContentBlockTypeWithAggregatesFilter<"ContentBlock"> | $Enums.ContentBlockType
    order?: FloatWithAggregatesFilter<"ContentBlock"> | number
    content?: StringWithAggregatesFilter<"ContentBlock"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ContentBlock"> | Date | string
    level?: IntNullableWithAggregatesFilter<"ContentBlock"> | number | null
    language?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    codeTitle?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    imageAlt?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    imageCaption?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    imageAlignment?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    calloutVariant?: EnumCalloutVariantNullableWithAggregatesFilter<"ContentBlock"> | $Enums.CalloutVariant | null
    calloutTitle?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    quoteAuthor?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    listStyle?: EnumListStyleNullableWithAggregatesFilter<"ContentBlock"> | $Enums.ListStyle | null
    listItems?: JsonNullableWithAggregatesFilter<"ContentBlock">
    videoType?: EnumVideoTypeNullableWithAggregatesFilter<"ContentBlock"> | $Enums.VideoType | null
    videoId?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    videoTitle?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    paragraphStyle?: StringNullableWithAggregatesFilter<"ContentBlock"> | string | null
    blogPostId?: IntWithAggregatesFilter<"ContentBlock"> | number
  }

  export type BlogTagWhereInput = {
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    id?: IntFilter<"BlogTag"> | number
    name?: StringFilter<"BlogTag"> | string
    slug?: StringFilter<"BlogTag"> | string
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTag"> | Date | string
    blogPostTags?: BlogPostTagListRelationFilter
  }

  export type BlogTagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    blogPostTags?: BlogPostTagOrderByRelationAggregateInput
  }

  export type BlogTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name?: string
    slug?: string
    AND?: BlogTagWhereInput | BlogTagWhereInput[]
    OR?: BlogTagWhereInput[]
    NOT?: BlogTagWhereInput | BlogTagWhereInput[]
    createdAt?: DateTimeFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeFilter<"BlogTag"> | Date | string
    blogPostTags?: BlogPostTagListRelationFilter
  }, "id" | "name" | "slug">

  export type BlogTagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BlogTagCountOrderByAggregateInput
    _avg?: BlogTagAvgOrderByAggregateInput
    _max?: BlogTagMaxOrderByAggregateInput
    _min?: BlogTagMinOrderByAggregateInput
    _sum?: BlogTagSumOrderByAggregateInput
  }

  export type BlogTagScalarWhereWithAggregatesInput = {
    AND?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    OR?: BlogTagScalarWhereWithAggregatesInput[]
    NOT?: BlogTagScalarWhereWithAggregatesInput | BlogTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogTag"> | number
    name?: StringWithAggregatesFilter<"BlogTag"> | string
    slug?: StringWithAggregatesFilter<"BlogTag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlogTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BlogTag"> | Date | string
  }

  export type BlogPostTagWhereInput = {
    AND?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    OR?: BlogPostTagWhereInput[]
    NOT?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    id?: IntFilter<"BlogPostTag"> | number
    createdAt?: DateTimeFilter<"BlogPostTag"> | Date | string
    blogPostId?: IntFilter<"BlogPostTag"> | number
    blogTagId?: IntFilter<"BlogPostTag"> | number
    blogPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    blogTag?: XOR<BlogTagScalarRelationFilter, BlogTagWhereInput>
  }

  export type BlogPostTagOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
    blogPost?: BlogPostOrderByWithRelationInput
    blogTag?: BlogTagOrderByWithRelationInput
  }

  export type BlogPostTagWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    blogPostId_blogTagId?: BlogPostTagBlogPostIdBlogTagIdCompoundUniqueInput
    AND?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    OR?: BlogPostTagWhereInput[]
    NOT?: BlogPostTagWhereInput | BlogPostTagWhereInput[]
    createdAt?: DateTimeFilter<"BlogPostTag"> | Date | string
    blogPostId?: IntFilter<"BlogPostTag"> | number
    blogTagId?: IntFilter<"BlogPostTag"> | number
    blogPost?: XOR<BlogPostScalarRelationFilter, BlogPostWhereInput>
    blogTag?: XOR<BlogTagScalarRelationFilter, BlogTagWhereInput>
  }, "id" | "blogPostId_blogTagId">

  export type BlogPostTagOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
    _count?: BlogPostTagCountOrderByAggregateInput
    _avg?: BlogPostTagAvgOrderByAggregateInput
    _max?: BlogPostTagMaxOrderByAggregateInput
    _min?: BlogPostTagMinOrderByAggregateInput
    _sum?: BlogPostTagSumOrderByAggregateInput
  }

  export type BlogPostTagScalarWhereWithAggregatesInput = {
    AND?: BlogPostTagScalarWhereWithAggregatesInput | BlogPostTagScalarWhereWithAggregatesInput[]
    OR?: BlogPostTagScalarWhereWithAggregatesInput[]
    NOT?: BlogPostTagScalarWhereWithAggregatesInput | BlogPostTagScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlogPostTag"> | number
    createdAt?: DateTimeWithAggregatesFilter<"BlogPostTag"> | Date | string
    blogPostId?: IntWithAggregatesFilter<"BlogPostTag"> | number
    blogTagId?: IntWithAggregatesFilter<"BlogPostTag"> | number
  }

  export type ContactSubmissionWhereInput = {
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    id?: IntFilter<"ContactSubmission"> | number
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    subject?: StringNullableFilter<"ContactSubmission"> | string | null
    message?: StringFilter<"ContactSubmission"> | string
    isRead?: BoolFilter<"ContactSubmission"> | boolean
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }

  export type ContactSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    OR?: ContactSubmissionWhereInput[]
    NOT?: ContactSubmissionWhereInput | ContactSubmissionWhereInput[]
    name?: StringFilter<"ContactSubmission"> | string
    email?: StringFilter<"ContactSubmission"> | string
    subject?: StringNullableFilter<"ContactSubmission"> | string | null
    message?: StringFilter<"ContactSubmission"> | string
    isRead?: BoolFilter<"ContactSubmission"> | boolean
    createdAt?: DateTimeFilter<"ContactSubmission"> | Date | string
  }, "id">

  export type ContactSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrderInput | SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: ContactSubmissionCountOrderByAggregateInput
    _avg?: ContactSubmissionAvgOrderByAggregateInput
    _max?: ContactSubmissionMaxOrderByAggregateInput
    _min?: ContactSubmissionMinOrderByAggregateInput
    _sum?: ContactSubmissionSumOrderByAggregateInput
  }

  export type ContactSubmissionScalarWhereWithAggregatesInput = {
    AND?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    OR?: ContactSubmissionScalarWhereWithAggregatesInput[]
    NOT?: ContactSubmissionScalarWhereWithAggregatesInput | ContactSubmissionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ContactSubmission"> | number
    name?: StringWithAggregatesFilter<"ContactSubmission"> | string
    email?: StringWithAggregatesFilter<"ContactSubmission"> | string
    subject?: StringNullableWithAggregatesFilter<"ContactSubmission"> | string | null
    message?: StringWithAggregatesFilter<"ContactSubmission"> | string
    isRead?: BoolWithAggregatesFilter<"ContactSubmission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ContactSubmission"> | Date | string
  }

  export type ProjectCreateInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOverviewCreateInput = {
    problem: string
    solution: string
    role: string
    impact: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutOverviewInput
  }

  export type ProjectOverviewUncheckedCreateInput = {
    id?: number
    problem: string
    solution: string
    role: string
    impact: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ProjectOverviewUpdateInput = {
    problem?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutOverviewNestedInput
  }

  export type ProjectOverviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    problem?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectOverviewCreateManyInput = {
    id?: number
    problem: string
    solution: string
    role: string
    impact: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ProjectOverviewUpdateManyMutationInput = {
    problem?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOverviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    problem?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMetricsCreateInput = {
    launchDate: string
    duration: string
    teamSize: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutMetricsInput
  }

  export type ProjectMetricsUncheckedCreateInput = {
    id?: number
    launchDate: string
    duration: string
    teamSize: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ProjectMetricsUpdateInput = {
    launchDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type ProjectMetricsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    launchDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectMetricsCreateManyInput = {
    id?: number
    launchDate: string
    duration: string
    teamSize: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ProjectMetricsUpdateManyMutationInput = {
    launchDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    launchDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnicalDetailsCreateInput = {
    database: string
    api: string
    components: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTechnicalDetailsInput
  }

  export type TechnicalDetailsUncheckedCreateInput = {
    id?: number
    database: string
    api: string
    components: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type TechnicalDetailsUpdateInput = {
    database?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
    components?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTechnicalDetailsNestedInput
  }

  export type TechnicalDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    database?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
    components?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnicalDetailsCreateManyInput = {
    id?: number
    database: string
    api: string
    components: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type TechnicalDetailsUpdateManyMutationInput = {
    database?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
    components?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicalDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    database?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
    components?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ScreenshotCreateInput = {
    url: string
    description: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutScreenshotsInput
  }

  export type ScreenshotUncheckedCreateInput = {
    id?: number
    url: string
    description: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ScreenshotUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutScreenshotsNestedInput
  }

  export type ScreenshotUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ScreenshotCreateManyInput = {
    id?: number
    url: string
    description: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ScreenshotUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenshotUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnologyCreateInput = {
    name: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTechnologiesInput
  }

  export type TechnologyUncheckedCreateInput = {
    id?: number
    name: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type TechnologyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTechnologiesNestedInput
  }

  export type TechnologyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type TechnologyCreateManyInput = {
    id?: number
    name: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type TechnologyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnologyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type TagCreateInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectTags?: ProjectTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagCreateInput = {
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectTagsInput
    tag: TagCreateNestedOneWithoutProjectTagsInput
  }

  export type ProjectTagUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
    tagId: number
  }

  export type ProjectTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutProjectTagsNestedInput
  }

  export type ProjectTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagCreateManyInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
    tagId: number
  }

  export type ProjectTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonCreateInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutLessonsInput
  }

  export type LessonUncheckedCreateInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type LessonUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonCreateManyInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type LessonUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessOutcomeCreateInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutBusinessOutcomesInput
  }

  export type BusinessOutcomeUncheckedCreateInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type BusinessOutcomeUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutBusinessOutcomesNestedInput
  }

  export type BusinessOutcomeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type BusinessOutcomeCreateManyInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type BusinessOutcomeUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessOutcomeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ImprovementCreateInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutImprovementsInput
  }

  export type ImprovementUncheckedCreateInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ImprovementUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutImprovementsNestedInput
  }

  export type ImprovementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ImprovementCreateManyInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type ImprovementUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImprovementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type NextStepCreateInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutNextStepsInput
  }

  export type NextStepUncheckedCreateInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type NextStepUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutNextStepsNestedInput
  }

  export type NextStepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type NextStepCreateManyInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type NextStepUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NextStepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type FutureToolCreateInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutFutureToolsInput
  }

  export type FutureToolUncheckedCreateInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type FutureToolUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutFutureToolsNestedInput
  }

  export type FutureToolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type FutureToolCreateManyInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type FutureToolUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FutureToolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricCreateInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutPerformanceMetricsInput
  }

  export type PerformanceMetricUncheckedCreateInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type PerformanceMetricUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutPerformanceMetricsNestedInput
  }

  export type PerformanceMetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type PerformanceMetricCreateManyInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    projectId: number
  }

  export type PerformanceMetricUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostCreateInput = {
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesPart?: number | null
    category?: CategoryCreateNestedOneWithoutBlogPostsInput
    series?: SeriesCreateNestedOneWithoutBlogPostsInput
    contentBlocks?: ContentBlockCreateNestedManyWithoutBlogPostInput
    blogPostTags?: BlogPostTagCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    categoryId?: number | null
    seriesId?: number | null
    seriesPart?: number | null
    contentBlocks?: ContentBlockUncheckedCreateNestedManyWithoutBlogPostInput
    blogPostTags?: BlogPostTagUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUpdateInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutBlogPostsNestedInput
    series?: SeriesUpdateOneWithoutBlogPostsNestedInput
    contentBlocks?: ContentBlockUpdateManyWithoutBlogPostNestedInput
    blogPostTags?: BlogPostTagUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    contentBlocks?: ContentBlockUncheckedUpdateManyWithoutBlogPostNestedInput
    blogPostTags?: BlogPostTagUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostCreateManyInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    categoryId?: number | null
    seriesId?: number | null
    seriesPart?: number | null
  }

  export type BlogPostUpdateManyMutationInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CategoryCreateInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blogPosts?: BlogPostCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPosts?: BlogPostUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPosts?: BlogPostUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesCreateInput = {
    name: string
    slug: string
    description?: string | null
    totalParts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    blogPosts?: BlogPostCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    totalParts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    blogPosts?: BlogPostUncheckedCreateNestedManyWithoutSeriesInput
  }

  export type SeriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalParts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPosts?: BlogPostUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalParts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPosts?: BlogPostUncheckedUpdateManyWithoutSeriesNestedInput
  }

  export type SeriesCreateManyInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    totalParts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalParts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalParts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockCreateInput = {
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: number | null
    language?: string | null
    codeTitle?: string | null
    imageUrl?: string | null
    imageAlt?: string | null
    imageCaption?: string | null
    imageAlignment?: string | null
    calloutVariant?: $Enums.CalloutVariant | null
    calloutTitle?: string | null
    quoteAuthor?: string | null
    listStyle?: $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: $Enums.VideoType | null
    videoId?: string | null
    videoTitle?: string | null
    paragraphStyle?: string | null
    blogPost: BlogPostCreateNestedOneWithoutContentBlocksInput
  }

  export type ContentBlockUncheckedCreateInput = {
    id?: number
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: number | null
    language?: string | null
    codeTitle?: string | null
    imageUrl?: string | null
    imageAlt?: string | null
    imageCaption?: string | null
    imageAlignment?: string | null
    calloutVariant?: $Enums.CalloutVariant | null
    calloutTitle?: string | null
    quoteAuthor?: string | null
    listStyle?: $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: $Enums.VideoType | null
    videoId?: string | null
    videoTitle?: string | null
    paragraphStyle?: string | null
    blogPostId: number
  }

  export type ContentBlockUpdateInput = {
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
    blogPost?: BlogPostUpdateOneRequiredWithoutContentBlocksNestedInput
  }

  export type ContentBlockUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentBlockCreateManyInput = {
    id?: number
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: number | null
    language?: string | null
    codeTitle?: string | null
    imageUrl?: string | null
    imageAlt?: string | null
    imageCaption?: string | null
    imageAlignment?: string | null
    calloutVariant?: $Enums.CalloutVariant | null
    calloutTitle?: string | null
    quoteAuthor?: string | null
    listStyle?: $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: $Enums.VideoType | null
    videoId?: string | null
    videoTitle?: string | null
    paragraphStyle?: string | null
    blogPostId: number
  }

  export type ContentBlockUpdateManyMutationInput = {
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentBlockUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
    blogPostId?: IntFieldUpdateOperationsInput | number
  }

  export type BlogTagCreateInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blogPostTags?: BlogPostTagCreateNestedManyWithoutBlogTagInput
  }

  export type BlogTagUncheckedCreateInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    blogPostTags?: BlogPostTagUncheckedCreateNestedManyWithoutBlogTagInput
  }

  export type BlogTagUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPostTags?: BlogPostTagUpdateManyWithoutBlogTagNestedInput
  }

  export type BlogTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPostTags?: BlogPostTagUncheckedUpdateManyWithoutBlogTagNestedInput
  }

  export type BlogTagCreateManyInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTagUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostTagCreateInput = {
    createdAt?: Date | string
    blogPost: BlogPostCreateNestedOneWithoutBlogPostTagsInput
    blogTag: BlogTagCreateNestedOneWithoutBlogPostTagsInput
  }

  export type BlogPostTagUncheckedCreateInput = {
    id?: number
    createdAt?: Date | string
    blogPostId: number
    blogTagId: number
  }

  export type BlogPostTagUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPost?: BlogPostUpdateOneRequiredWithoutBlogPostTagsNestedInput
    blogTag?: BlogTagUpdateOneRequiredWithoutBlogPostTagsNestedInput
  }

  export type BlogPostTagUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPostId?: IntFieldUpdateOperationsInput | number
    blogTagId?: IntFieldUpdateOperationsInput | number
  }

  export type BlogPostTagCreateManyInput = {
    id?: number
    createdAt?: Date | string
    blogPostId: number
    blogTagId: number
  }

  export type BlogPostTagUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogPostTagUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPostId?: IntFieldUpdateOperationsInput | number
    blogTagId?: IntFieldUpdateOperationsInput | number
  }

  export type ContactSubmissionCreateInput = {
    name: string
    email: string
    subject?: string | null
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ContactSubmissionUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    subject?: string | null
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ContactSubmissionUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionCreateManyInput = {
    id?: number
    name: string
    email: string
    subject?: string | null
    message: string
    isRead?: boolean
    createdAt?: Date | string
  }

  export type ContactSubmissionUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactSubmissionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectOverviewNullableScalarRelationFilter = {
    is?: ProjectOverviewWhereInput | null
    isNot?: ProjectOverviewWhereInput | null
  }

  export type ProjectMetricsNullableScalarRelationFilter = {
    is?: ProjectMetricsWhereInput | null
    isNot?: ProjectMetricsWhereInput | null
  }

  export type TechnicalDetailsNullableScalarRelationFilter = {
    is?: TechnicalDetailsWhereInput | null
    isNot?: TechnicalDetailsWhereInput | null
  }

  export type ScreenshotListRelationFilter = {
    every?: ScreenshotWhereInput
    some?: ScreenshotWhereInput
    none?: ScreenshotWhereInput
  }

  export type TechnologyListRelationFilter = {
    every?: TechnologyWhereInput
    some?: TechnologyWhereInput
    none?: TechnologyWhereInput
  }

  export type ProjectTagListRelationFilter = {
    every?: ProjectTagWhereInput
    some?: ProjectTagWhereInput
    none?: ProjectTagWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type BusinessOutcomeListRelationFilter = {
    every?: BusinessOutcomeWhereInput
    some?: BusinessOutcomeWhereInput
    none?: BusinessOutcomeWhereInput
  }

  export type ImprovementListRelationFilter = {
    every?: ImprovementWhereInput
    some?: ImprovementWhereInput
    none?: ImprovementWhereInput
  }

  export type NextStepListRelationFilter = {
    every?: NextStepWhereInput
    some?: NextStepWhereInput
    none?: NextStepWhereInput
  }

  export type FutureToolListRelationFilter = {
    every?: FutureToolWhereInput
    some?: FutureToolWhereInput
    none?: FutureToolWhereInput
  }

  export type PerformanceMetricListRelationFilter = {
    every?: PerformanceMetricWhereInput
    some?: PerformanceMetricWhereInput
    none?: PerformanceMetricWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ScreenshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TechnologyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BusinessOutcomeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImprovementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NextStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FutureToolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PerformanceMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    heroImage?: SortOrder
    liveDemo?: SortOrder
    github?: SortOrder
    caseStudy?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    heroImage?: SortOrder
    liveDemo?: SortOrder
    github?: SortOrder
    caseStudy?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    slug?: SortOrder
    status?: SortOrder
    heroImage?: SortOrder
    liveDemo?: SortOrder
    github?: SortOrder
    caseStudy?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectOverviewCountOrderByAggregateInput = {
    id?: SortOrder
    problem?: SortOrder
    solution?: SortOrder
    role?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectOverviewAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectOverviewMaxOrderByAggregateInput = {
    id?: SortOrder
    problem?: SortOrder
    solution?: SortOrder
    role?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectOverviewMinOrderByAggregateInput = {
    id?: SortOrder
    problem?: SortOrder
    solution?: SortOrder
    role?: SortOrder
    impact?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectOverviewSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    launchDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectMetricsAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    launchDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    launchDate?: SortOrder
    duration?: SortOrder
    teamSize?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ProjectMetricsSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TechnicalDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    database?: SortOrder
    api?: SortOrder
    components?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TechnicalDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TechnicalDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    database?: SortOrder
    api?: SortOrder
    components?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TechnicalDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    database?: SortOrder
    api?: SortOrder
    components?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TechnicalDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ScreenshotCountOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ScreenshotAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
  }

  export type ScreenshotMaxOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ScreenshotMinOrderByAggregateInput = {
    id?: SortOrder
    url?: SortOrder
    description?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ScreenshotSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    projectId?: SortOrder
  }

  export type TechnologyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TechnologyAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TechnologyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TechnologyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type TechnologySumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ProjectTagProjectIdTagIdCompoundUniqueInput = {
    projectId: number
    tagId: number
  }

  export type ProjectTagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
  }

  export type ProjectTagAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
  }

  export type ProjectTagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
  }

  export type ProjectTagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
  }

  export type ProjectTagSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
    tagId?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type BusinessOutcomeCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type BusinessOutcomeAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type BusinessOutcomeMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type BusinessOutcomeMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type BusinessOutcomeSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ImprovementCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ImprovementAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type ImprovementMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ImprovementMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type ImprovementSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type NextStepCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type NextStepAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type NextStepMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type NextStepMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type NextStepSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type FutureToolCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type FutureToolAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type FutureToolMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type FutureToolMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type FutureToolSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PerformanceMetricCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type PerformanceMetricAvgOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type PerformanceMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type PerformanceMetricMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    projectId?: SortOrder
  }

  export type PerformanceMetricSumOrderByAggregateInput = {
    id?: SortOrder
    projectId?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CategoryNullableScalarRelationFilter = {
    is?: CategoryWhereInput | null
    isNot?: CategoryWhereInput | null
  }

  export type SeriesNullableScalarRelationFilter = {
    is?: SeriesWhereInput | null
    isNot?: SeriesWhereInput | null
  }

  export type ContentBlockListRelationFilter = {
    every?: ContentBlockWhereInput
    some?: ContentBlockWhereInput
    none?: ContentBlockWhereInput
  }

  export type BlogPostTagListRelationFilter = {
    every?: BlogPostTagWhereInput
    some?: BlogPostTagWhereInput
    none?: BlogPostTagWhereInput
  }

  export type ContentBlockOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BlogPostCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    metaDescription?: SortOrder
    socialImage?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    heroImage?: SortOrder
    heroImageAlt?: SortOrder
    heroImageCaption?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: SortOrder
    categoryId?: SortOrder
    seriesId?: SortOrder
    seriesPart?: SortOrder
  }

  export type BlogPostAvgOrderByAggregateInput = {
    id?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
    seriesId?: SortOrder
    seriesPart?: SortOrder
  }

  export type BlogPostMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    metaDescription?: SortOrder
    socialImage?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    heroImage?: SortOrder
    heroImageAlt?: SortOrder
    heroImageCaption?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    seriesId?: SortOrder
    seriesPart?: SortOrder
  }

  export type BlogPostMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    title?: SortOrder
    subtitle?: SortOrder
    excerpt?: SortOrder
    metaDescription?: SortOrder
    socialImage?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    heroImage?: SortOrder
    heroImageAlt?: SortOrder
    heroImageCaption?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    categoryId?: SortOrder
    seriesId?: SortOrder
    seriesPart?: SortOrder
  }

  export type BlogPostSumOrderByAggregateInput = {
    id?: SortOrder
    readTime?: SortOrder
    wordCount?: SortOrder
    views?: SortOrder
    categoryId?: SortOrder
    seriesId?: SortOrder
    seriesPart?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BlogPostListRelationFilter = {
    every?: BlogPostWhereInput
    some?: BlogPostWhereInput
    none?: BlogPostWhereInput
  }

  export type BlogPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SeriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    totalParts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesAvgOrderByAggregateInput = {
    id?: SortOrder
    totalParts?: SortOrder
  }

  export type SeriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    totalParts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    totalParts?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SeriesSumOrderByAggregateInput = {
    id?: SortOrder
    totalParts?: SortOrder
  }

  export type EnumContentBlockTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentBlockType | EnumContentBlockTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentBlockTypeFilter<$PrismaModel> | $Enums.ContentBlockType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumCalloutVariantNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CalloutVariant | EnumCalloutVariantFieldRefInput<$PrismaModel> | null
    in?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCalloutVariantNullableFilter<$PrismaModel> | $Enums.CalloutVariant | null
  }

  export type EnumListStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ListStyle | EnumListStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListStyleNullableFilter<$PrismaModel> | $Enums.ListStyle | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumVideoTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVideoTypeNullableFilter<$PrismaModel> | $Enums.VideoType | null
  }

  export type BlogPostScalarRelationFilter = {
    is?: BlogPostWhereInput
    isNot?: BlogPostWhereInput
  }

  export type ContentBlockCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    language?: SortOrder
    codeTitle?: SortOrder
    imageUrl?: SortOrder
    imageAlt?: SortOrder
    imageCaption?: SortOrder
    imageAlignment?: SortOrder
    calloutVariant?: SortOrder
    calloutTitle?: SortOrder
    quoteAuthor?: SortOrder
    listStyle?: SortOrder
    listItems?: SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    videoTitle?: SortOrder
    paragraphStyle?: SortOrder
    blogPostId?: SortOrder
  }

  export type ContentBlockAvgOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    level?: SortOrder
    blogPostId?: SortOrder
  }

  export type ContentBlockMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    language?: SortOrder
    codeTitle?: SortOrder
    imageUrl?: SortOrder
    imageAlt?: SortOrder
    imageCaption?: SortOrder
    imageAlignment?: SortOrder
    calloutVariant?: SortOrder
    calloutTitle?: SortOrder
    quoteAuthor?: SortOrder
    listStyle?: SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    videoTitle?: SortOrder
    paragraphStyle?: SortOrder
    blogPostId?: SortOrder
  }

  export type ContentBlockMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    order?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    level?: SortOrder
    language?: SortOrder
    codeTitle?: SortOrder
    imageUrl?: SortOrder
    imageAlt?: SortOrder
    imageCaption?: SortOrder
    imageAlignment?: SortOrder
    calloutVariant?: SortOrder
    calloutTitle?: SortOrder
    quoteAuthor?: SortOrder
    listStyle?: SortOrder
    videoType?: SortOrder
    videoId?: SortOrder
    videoTitle?: SortOrder
    paragraphStyle?: SortOrder
    blogPostId?: SortOrder
  }

  export type ContentBlockSumOrderByAggregateInput = {
    id?: SortOrder
    order?: SortOrder
    level?: SortOrder
    blogPostId?: SortOrder
  }

  export type EnumContentBlockTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentBlockType | EnumContentBlockTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentBlockTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentBlockType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentBlockTypeFilter<$PrismaModel>
    _max?: NestedEnumContentBlockTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCalloutVariantNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalloutVariant | EnumCalloutVariantFieldRefInput<$PrismaModel> | null
    in?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCalloutVariantNullableWithAggregatesFilter<$PrismaModel> | $Enums.CalloutVariant | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCalloutVariantNullableFilter<$PrismaModel>
    _max?: NestedEnumCalloutVariantNullableFilter<$PrismaModel>
  }

  export type EnumListStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListStyle | EnumListStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.ListStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumListStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumListStyleNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumVideoTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVideoTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VideoType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVideoTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVideoTypeNullableFilter<$PrismaModel>
  }

  export type BlogTagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlogTagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BlogTagSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlogTagScalarRelationFilter = {
    is?: BlogTagWhereInput
    isNot?: BlogTagWhereInput
  }

  export type BlogPostTagBlogPostIdBlogTagIdCompoundUniqueInput = {
    blogPostId: number
    blogTagId: number
  }

  export type BlogPostTagCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
  }

  export type BlogPostTagAvgOrderByAggregateInput = {
    id?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
  }

  export type BlogPostTagMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
  }

  export type BlogPostTagMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
  }

  export type BlogPostTagSumOrderByAggregateInput = {
    id?: SortOrder
    blogPostId?: SortOrder
    blogTagId?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ContactSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSubmissionAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ContactSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type ContactSubmissionSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProjectOverviewCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectOverviewCreateWithoutProjectInput, ProjectOverviewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectOverviewCreateOrConnectWithoutProjectInput
    connect?: ProjectOverviewWhereUniqueInput
  }

  export type ProjectMetricsCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectMetricsCreateWithoutProjectInput, ProjectMetricsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectMetricsCreateOrConnectWithoutProjectInput
    connect?: ProjectMetricsWhereUniqueInput
  }

  export type TechnicalDetailsCreateNestedOneWithoutProjectInput = {
    create?: XOR<TechnicalDetailsCreateWithoutProjectInput, TechnicalDetailsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: TechnicalDetailsCreateOrConnectWithoutProjectInput
    connect?: TechnicalDetailsWhereUniqueInput
  }

  export type ScreenshotCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScreenshotCreateWithoutProjectInput, ScreenshotUncheckedCreateWithoutProjectInput> | ScreenshotCreateWithoutProjectInput[] | ScreenshotUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutProjectInput | ScreenshotCreateOrConnectWithoutProjectInput[]
    createMany?: ScreenshotCreateManyProjectInputEnvelope
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
  }

  export type TechnologyCreateNestedManyWithoutProjectInput = {
    create?: XOR<TechnologyCreateWithoutProjectInput, TechnologyUncheckedCreateWithoutProjectInput> | TechnologyCreateWithoutProjectInput[] | TechnologyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TechnologyCreateOrConnectWithoutProjectInput | TechnologyCreateOrConnectWithoutProjectInput[]
    createMany?: TechnologyCreateManyProjectInputEnvelope
    connect?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
  }

  export type ProjectTagCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTagCreateWithoutProjectInput, ProjectTagUncheckedCreateWithoutProjectInput> | ProjectTagCreateWithoutProjectInput[] | ProjectTagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutProjectInput | ProjectTagCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTagCreateManyProjectInputEnvelope
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutProjectInput = {
    create?: XOR<LessonCreateWithoutProjectInput, LessonUncheckedCreateWithoutProjectInput> | LessonCreateWithoutProjectInput[] | LessonUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutProjectInput | LessonCreateOrConnectWithoutProjectInput[]
    createMany?: LessonCreateManyProjectInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type BusinessOutcomeCreateNestedManyWithoutProjectInput = {
    create?: XOR<BusinessOutcomeCreateWithoutProjectInput, BusinessOutcomeUncheckedCreateWithoutProjectInput> | BusinessOutcomeCreateWithoutProjectInput[] | BusinessOutcomeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessOutcomeCreateOrConnectWithoutProjectInput | BusinessOutcomeCreateOrConnectWithoutProjectInput[]
    createMany?: BusinessOutcomeCreateManyProjectInputEnvelope
    connect?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
  }

  export type ImprovementCreateNestedManyWithoutProjectInput = {
    create?: XOR<ImprovementCreateWithoutProjectInput, ImprovementUncheckedCreateWithoutProjectInput> | ImprovementCreateWithoutProjectInput[] | ImprovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImprovementCreateOrConnectWithoutProjectInput | ImprovementCreateOrConnectWithoutProjectInput[]
    createMany?: ImprovementCreateManyProjectInputEnvelope
    connect?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
  }

  export type NextStepCreateNestedManyWithoutProjectInput = {
    create?: XOR<NextStepCreateWithoutProjectInput, NextStepUncheckedCreateWithoutProjectInput> | NextStepCreateWithoutProjectInput[] | NextStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NextStepCreateOrConnectWithoutProjectInput | NextStepCreateOrConnectWithoutProjectInput[]
    createMany?: NextStepCreateManyProjectInputEnvelope
    connect?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
  }

  export type FutureToolCreateNestedManyWithoutProjectInput = {
    create?: XOR<FutureToolCreateWithoutProjectInput, FutureToolUncheckedCreateWithoutProjectInput> | FutureToolCreateWithoutProjectInput[] | FutureToolUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FutureToolCreateOrConnectWithoutProjectInput | FutureToolCreateOrConnectWithoutProjectInput[]
    createMany?: FutureToolCreateManyProjectInputEnvelope
    connect?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
  }

  export type PerformanceMetricCreateNestedManyWithoutProjectInput = {
    create?: XOR<PerformanceMetricCreateWithoutProjectInput, PerformanceMetricUncheckedCreateWithoutProjectInput> | PerformanceMetricCreateWithoutProjectInput[] | PerformanceMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutProjectInput | PerformanceMetricCreateOrConnectWithoutProjectInput[]
    createMany?: PerformanceMetricCreateManyProjectInputEnvelope
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
  }

  export type ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectOverviewCreateWithoutProjectInput, ProjectOverviewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectOverviewCreateOrConnectWithoutProjectInput
    connect?: ProjectOverviewWhereUniqueInput
  }

  export type ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<ProjectMetricsCreateWithoutProjectInput, ProjectMetricsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectMetricsCreateOrConnectWithoutProjectInput
    connect?: ProjectMetricsWhereUniqueInput
  }

  export type TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput = {
    create?: XOR<TechnicalDetailsCreateWithoutProjectInput, TechnicalDetailsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: TechnicalDetailsCreateOrConnectWithoutProjectInput
    connect?: TechnicalDetailsWhereUniqueInput
  }

  export type ScreenshotUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ScreenshotCreateWithoutProjectInput, ScreenshotUncheckedCreateWithoutProjectInput> | ScreenshotCreateWithoutProjectInput[] | ScreenshotUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutProjectInput | ScreenshotCreateOrConnectWithoutProjectInput[]
    createMany?: ScreenshotCreateManyProjectInputEnvelope
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
  }

  export type TechnologyUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TechnologyCreateWithoutProjectInput, TechnologyUncheckedCreateWithoutProjectInput> | TechnologyCreateWithoutProjectInput[] | TechnologyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TechnologyCreateOrConnectWithoutProjectInput | TechnologyCreateOrConnectWithoutProjectInput[]
    createMany?: TechnologyCreateManyProjectInputEnvelope
    connect?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
  }

  export type ProjectTagUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectTagCreateWithoutProjectInput, ProjectTagUncheckedCreateWithoutProjectInput> | ProjectTagCreateWithoutProjectInput[] | ProjectTagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutProjectInput | ProjectTagCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectTagCreateManyProjectInputEnvelope
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LessonCreateWithoutProjectInput, LessonUncheckedCreateWithoutProjectInput> | LessonCreateWithoutProjectInput[] | LessonUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutProjectInput | LessonCreateOrConnectWithoutProjectInput[]
    createMany?: LessonCreateManyProjectInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<BusinessOutcomeCreateWithoutProjectInput, BusinessOutcomeUncheckedCreateWithoutProjectInput> | BusinessOutcomeCreateWithoutProjectInput[] | BusinessOutcomeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessOutcomeCreateOrConnectWithoutProjectInput | BusinessOutcomeCreateOrConnectWithoutProjectInput[]
    createMany?: BusinessOutcomeCreateManyProjectInputEnvelope
    connect?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
  }

  export type ImprovementUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ImprovementCreateWithoutProjectInput, ImprovementUncheckedCreateWithoutProjectInput> | ImprovementCreateWithoutProjectInput[] | ImprovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImprovementCreateOrConnectWithoutProjectInput | ImprovementCreateOrConnectWithoutProjectInput[]
    createMany?: ImprovementCreateManyProjectInputEnvelope
    connect?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
  }

  export type NextStepUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<NextStepCreateWithoutProjectInput, NextStepUncheckedCreateWithoutProjectInput> | NextStepCreateWithoutProjectInput[] | NextStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NextStepCreateOrConnectWithoutProjectInput | NextStepCreateOrConnectWithoutProjectInput[]
    createMany?: NextStepCreateManyProjectInputEnvelope
    connect?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
  }

  export type FutureToolUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<FutureToolCreateWithoutProjectInput, FutureToolUncheckedCreateWithoutProjectInput> | FutureToolCreateWithoutProjectInput[] | FutureToolUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FutureToolCreateOrConnectWithoutProjectInput | FutureToolCreateOrConnectWithoutProjectInput[]
    createMany?: FutureToolCreateManyProjectInputEnvelope
    connect?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
  }

  export type PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PerformanceMetricCreateWithoutProjectInput, PerformanceMetricUncheckedCreateWithoutProjectInput> | PerformanceMetricCreateWithoutProjectInput[] | PerformanceMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutProjectInput | PerformanceMetricCreateOrConnectWithoutProjectInput[]
    createMany?: PerformanceMetricCreateManyProjectInputEnvelope
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectOverviewUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectOverviewCreateWithoutProjectInput, ProjectOverviewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectOverviewCreateOrConnectWithoutProjectInput
    upsert?: ProjectOverviewUpsertWithoutProjectInput
    disconnect?: ProjectOverviewWhereInput | boolean
    delete?: ProjectOverviewWhereInput | boolean
    connect?: ProjectOverviewWhereUniqueInput
    update?: XOR<XOR<ProjectOverviewUpdateToOneWithWhereWithoutProjectInput, ProjectOverviewUpdateWithoutProjectInput>, ProjectOverviewUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMetricsUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectMetricsCreateWithoutProjectInput, ProjectMetricsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectMetricsCreateOrConnectWithoutProjectInput
    upsert?: ProjectMetricsUpsertWithoutProjectInput
    disconnect?: ProjectMetricsWhereInput | boolean
    delete?: ProjectMetricsWhereInput | boolean
    connect?: ProjectMetricsWhereUniqueInput
    update?: XOR<XOR<ProjectMetricsUpdateToOneWithWhereWithoutProjectInput, ProjectMetricsUpdateWithoutProjectInput>, ProjectMetricsUncheckedUpdateWithoutProjectInput>
  }

  export type TechnicalDetailsUpdateOneWithoutProjectNestedInput = {
    create?: XOR<TechnicalDetailsCreateWithoutProjectInput, TechnicalDetailsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: TechnicalDetailsCreateOrConnectWithoutProjectInput
    upsert?: TechnicalDetailsUpsertWithoutProjectInput
    disconnect?: TechnicalDetailsWhereInput | boolean
    delete?: TechnicalDetailsWhereInput | boolean
    connect?: TechnicalDetailsWhereUniqueInput
    update?: XOR<XOR<TechnicalDetailsUpdateToOneWithWhereWithoutProjectInput, TechnicalDetailsUpdateWithoutProjectInput>, TechnicalDetailsUncheckedUpdateWithoutProjectInput>
  }

  export type ScreenshotUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScreenshotCreateWithoutProjectInput, ScreenshotUncheckedCreateWithoutProjectInput> | ScreenshotCreateWithoutProjectInput[] | ScreenshotUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutProjectInput | ScreenshotCreateOrConnectWithoutProjectInput[]
    upsert?: ScreenshotUpsertWithWhereUniqueWithoutProjectInput | ScreenshotUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScreenshotCreateManyProjectInputEnvelope
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    update?: ScreenshotUpdateWithWhereUniqueWithoutProjectInput | ScreenshotUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScreenshotUpdateManyWithWhereWithoutProjectInput | ScreenshotUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
  }

  export type TechnologyUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TechnologyCreateWithoutProjectInput, TechnologyUncheckedCreateWithoutProjectInput> | TechnologyCreateWithoutProjectInput[] | TechnologyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TechnologyCreateOrConnectWithoutProjectInput | TechnologyCreateOrConnectWithoutProjectInput[]
    upsert?: TechnologyUpsertWithWhereUniqueWithoutProjectInput | TechnologyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TechnologyCreateManyProjectInputEnvelope
    set?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    disconnect?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    delete?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    connect?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    update?: TechnologyUpdateWithWhereUniqueWithoutProjectInput | TechnologyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TechnologyUpdateManyWithWhereWithoutProjectInput | TechnologyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TechnologyScalarWhereInput | TechnologyScalarWhereInput[]
  }

  export type ProjectTagUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTagCreateWithoutProjectInput, ProjectTagUncheckedCreateWithoutProjectInput> | ProjectTagCreateWithoutProjectInput[] | ProjectTagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutProjectInput | ProjectTagCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTagUpsertWithWhereUniqueWithoutProjectInput | ProjectTagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTagCreateManyProjectInputEnvelope
    set?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    disconnect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    delete?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    update?: ProjectTagUpdateWithWhereUniqueWithoutProjectInput | ProjectTagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTagUpdateManyWithWhereWithoutProjectInput | ProjectTagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTagScalarWhereInput | ProjectTagScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LessonCreateWithoutProjectInput, LessonUncheckedCreateWithoutProjectInput> | LessonCreateWithoutProjectInput[] | LessonUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutProjectInput | LessonCreateOrConnectWithoutProjectInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutProjectInput | LessonUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LessonCreateManyProjectInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutProjectInput | LessonUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutProjectInput | LessonUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type BusinessOutcomeUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BusinessOutcomeCreateWithoutProjectInput, BusinessOutcomeUncheckedCreateWithoutProjectInput> | BusinessOutcomeCreateWithoutProjectInput[] | BusinessOutcomeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessOutcomeCreateOrConnectWithoutProjectInput | BusinessOutcomeCreateOrConnectWithoutProjectInput[]
    upsert?: BusinessOutcomeUpsertWithWhereUniqueWithoutProjectInput | BusinessOutcomeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BusinessOutcomeCreateManyProjectInputEnvelope
    set?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    disconnect?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    delete?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    connect?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    update?: BusinessOutcomeUpdateWithWhereUniqueWithoutProjectInput | BusinessOutcomeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BusinessOutcomeUpdateManyWithWhereWithoutProjectInput | BusinessOutcomeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BusinessOutcomeScalarWhereInput | BusinessOutcomeScalarWhereInput[]
  }

  export type ImprovementUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ImprovementCreateWithoutProjectInput, ImprovementUncheckedCreateWithoutProjectInput> | ImprovementCreateWithoutProjectInput[] | ImprovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImprovementCreateOrConnectWithoutProjectInput | ImprovementCreateOrConnectWithoutProjectInput[]
    upsert?: ImprovementUpsertWithWhereUniqueWithoutProjectInput | ImprovementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ImprovementCreateManyProjectInputEnvelope
    set?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    disconnect?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    delete?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    connect?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    update?: ImprovementUpdateWithWhereUniqueWithoutProjectInput | ImprovementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ImprovementUpdateManyWithWhereWithoutProjectInput | ImprovementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ImprovementScalarWhereInput | ImprovementScalarWhereInput[]
  }

  export type NextStepUpdateManyWithoutProjectNestedInput = {
    create?: XOR<NextStepCreateWithoutProjectInput, NextStepUncheckedCreateWithoutProjectInput> | NextStepCreateWithoutProjectInput[] | NextStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NextStepCreateOrConnectWithoutProjectInput | NextStepCreateOrConnectWithoutProjectInput[]
    upsert?: NextStepUpsertWithWhereUniqueWithoutProjectInput | NextStepUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: NextStepCreateManyProjectInputEnvelope
    set?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    disconnect?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    delete?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    connect?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    update?: NextStepUpdateWithWhereUniqueWithoutProjectInput | NextStepUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: NextStepUpdateManyWithWhereWithoutProjectInput | NextStepUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: NextStepScalarWhereInput | NextStepScalarWhereInput[]
  }

  export type FutureToolUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FutureToolCreateWithoutProjectInput, FutureToolUncheckedCreateWithoutProjectInput> | FutureToolCreateWithoutProjectInput[] | FutureToolUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FutureToolCreateOrConnectWithoutProjectInput | FutureToolCreateOrConnectWithoutProjectInput[]
    upsert?: FutureToolUpsertWithWhereUniqueWithoutProjectInput | FutureToolUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FutureToolCreateManyProjectInputEnvelope
    set?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    disconnect?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    delete?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    connect?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    update?: FutureToolUpdateWithWhereUniqueWithoutProjectInput | FutureToolUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FutureToolUpdateManyWithWhereWithoutProjectInput | FutureToolUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FutureToolScalarWhereInput | FutureToolScalarWhereInput[]
  }

  export type PerformanceMetricUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PerformanceMetricCreateWithoutProjectInput, PerformanceMetricUncheckedCreateWithoutProjectInput> | PerformanceMetricCreateWithoutProjectInput[] | PerformanceMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutProjectInput | PerformanceMetricCreateOrConnectWithoutProjectInput[]
    upsert?: PerformanceMetricUpsertWithWhereUniqueWithoutProjectInput | PerformanceMetricUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PerformanceMetricCreateManyProjectInputEnvelope
    set?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    disconnect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    delete?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    update?: PerformanceMetricUpdateWithWhereUniqueWithoutProjectInput | PerformanceMetricUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PerformanceMetricUpdateManyWithWhereWithoutProjectInput | PerformanceMetricUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectOverviewCreateWithoutProjectInput, ProjectOverviewUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectOverviewCreateOrConnectWithoutProjectInput
    upsert?: ProjectOverviewUpsertWithoutProjectInput
    disconnect?: ProjectOverviewWhereInput | boolean
    delete?: ProjectOverviewWhereInput | boolean
    connect?: ProjectOverviewWhereUniqueInput
    update?: XOR<XOR<ProjectOverviewUpdateToOneWithWhereWithoutProjectInput, ProjectOverviewUpdateWithoutProjectInput>, ProjectOverviewUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<ProjectMetricsCreateWithoutProjectInput, ProjectMetricsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: ProjectMetricsCreateOrConnectWithoutProjectInput
    upsert?: ProjectMetricsUpsertWithoutProjectInput
    disconnect?: ProjectMetricsWhereInput | boolean
    delete?: ProjectMetricsWhereInput | boolean
    connect?: ProjectMetricsWhereUniqueInput
    update?: XOR<XOR<ProjectMetricsUpdateToOneWithWhereWithoutProjectInput, ProjectMetricsUpdateWithoutProjectInput>, ProjectMetricsUncheckedUpdateWithoutProjectInput>
  }

  export type TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput = {
    create?: XOR<TechnicalDetailsCreateWithoutProjectInput, TechnicalDetailsUncheckedCreateWithoutProjectInput>
    connectOrCreate?: TechnicalDetailsCreateOrConnectWithoutProjectInput
    upsert?: TechnicalDetailsUpsertWithoutProjectInput
    disconnect?: TechnicalDetailsWhereInput | boolean
    delete?: TechnicalDetailsWhereInput | boolean
    connect?: TechnicalDetailsWhereUniqueInput
    update?: XOR<XOR<TechnicalDetailsUpdateToOneWithWhereWithoutProjectInput, TechnicalDetailsUpdateWithoutProjectInput>, TechnicalDetailsUncheckedUpdateWithoutProjectInput>
  }

  export type ScreenshotUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ScreenshotCreateWithoutProjectInput, ScreenshotUncheckedCreateWithoutProjectInput> | ScreenshotCreateWithoutProjectInput[] | ScreenshotUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ScreenshotCreateOrConnectWithoutProjectInput | ScreenshotCreateOrConnectWithoutProjectInput[]
    upsert?: ScreenshotUpsertWithWhereUniqueWithoutProjectInput | ScreenshotUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ScreenshotCreateManyProjectInputEnvelope
    set?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    disconnect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    delete?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    connect?: ScreenshotWhereUniqueInput | ScreenshotWhereUniqueInput[]
    update?: ScreenshotUpdateWithWhereUniqueWithoutProjectInput | ScreenshotUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ScreenshotUpdateManyWithWhereWithoutProjectInput | ScreenshotUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
  }

  export type TechnologyUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TechnologyCreateWithoutProjectInput, TechnologyUncheckedCreateWithoutProjectInput> | TechnologyCreateWithoutProjectInput[] | TechnologyUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TechnologyCreateOrConnectWithoutProjectInput | TechnologyCreateOrConnectWithoutProjectInput[]
    upsert?: TechnologyUpsertWithWhereUniqueWithoutProjectInput | TechnologyUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TechnologyCreateManyProjectInputEnvelope
    set?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    disconnect?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    delete?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    connect?: TechnologyWhereUniqueInput | TechnologyWhereUniqueInput[]
    update?: TechnologyUpdateWithWhereUniqueWithoutProjectInput | TechnologyUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TechnologyUpdateManyWithWhereWithoutProjectInput | TechnologyUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TechnologyScalarWhereInput | TechnologyScalarWhereInput[]
  }

  export type ProjectTagUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectTagCreateWithoutProjectInput, ProjectTagUncheckedCreateWithoutProjectInput> | ProjectTagCreateWithoutProjectInput[] | ProjectTagUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutProjectInput | ProjectTagCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectTagUpsertWithWhereUniqueWithoutProjectInput | ProjectTagUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectTagCreateManyProjectInputEnvelope
    set?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    disconnect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    delete?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    update?: ProjectTagUpdateWithWhereUniqueWithoutProjectInput | ProjectTagUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectTagUpdateManyWithWhereWithoutProjectInput | ProjectTagUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectTagScalarWhereInput | ProjectTagScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LessonCreateWithoutProjectInput, LessonUncheckedCreateWithoutProjectInput> | LessonCreateWithoutProjectInput[] | LessonUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutProjectInput | LessonCreateOrConnectWithoutProjectInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutProjectInput | LessonUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LessonCreateManyProjectInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutProjectInput | LessonUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutProjectInput | LessonUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<BusinessOutcomeCreateWithoutProjectInput, BusinessOutcomeUncheckedCreateWithoutProjectInput> | BusinessOutcomeCreateWithoutProjectInput[] | BusinessOutcomeUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: BusinessOutcomeCreateOrConnectWithoutProjectInput | BusinessOutcomeCreateOrConnectWithoutProjectInput[]
    upsert?: BusinessOutcomeUpsertWithWhereUniqueWithoutProjectInput | BusinessOutcomeUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: BusinessOutcomeCreateManyProjectInputEnvelope
    set?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    disconnect?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    delete?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    connect?: BusinessOutcomeWhereUniqueInput | BusinessOutcomeWhereUniqueInput[]
    update?: BusinessOutcomeUpdateWithWhereUniqueWithoutProjectInput | BusinessOutcomeUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: BusinessOutcomeUpdateManyWithWhereWithoutProjectInput | BusinessOutcomeUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: BusinessOutcomeScalarWhereInput | BusinessOutcomeScalarWhereInput[]
  }

  export type ImprovementUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ImprovementCreateWithoutProjectInput, ImprovementUncheckedCreateWithoutProjectInput> | ImprovementCreateWithoutProjectInput[] | ImprovementUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ImprovementCreateOrConnectWithoutProjectInput | ImprovementCreateOrConnectWithoutProjectInput[]
    upsert?: ImprovementUpsertWithWhereUniqueWithoutProjectInput | ImprovementUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ImprovementCreateManyProjectInputEnvelope
    set?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    disconnect?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    delete?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    connect?: ImprovementWhereUniqueInput | ImprovementWhereUniqueInput[]
    update?: ImprovementUpdateWithWhereUniqueWithoutProjectInput | ImprovementUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ImprovementUpdateManyWithWhereWithoutProjectInput | ImprovementUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ImprovementScalarWhereInput | ImprovementScalarWhereInput[]
  }

  export type NextStepUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<NextStepCreateWithoutProjectInput, NextStepUncheckedCreateWithoutProjectInput> | NextStepCreateWithoutProjectInput[] | NextStepUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: NextStepCreateOrConnectWithoutProjectInput | NextStepCreateOrConnectWithoutProjectInput[]
    upsert?: NextStepUpsertWithWhereUniqueWithoutProjectInput | NextStepUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: NextStepCreateManyProjectInputEnvelope
    set?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    disconnect?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    delete?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    connect?: NextStepWhereUniqueInput | NextStepWhereUniqueInput[]
    update?: NextStepUpdateWithWhereUniqueWithoutProjectInput | NextStepUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: NextStepUpdateManyWithWhereWithoutProjectInput | NextStepUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: NextStepScalarWhereInput | NextStepScalarWhereInput[]
  }

  export type FutureToolUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<FutureToolCreateWithoutProjectInput, FutureToolUncheckedCreateWithoutProjectInput> | FutureToolCreateWithoutProjectInput[] | FutureToolUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: FutureToolCreateOrConnectWithoutProjectInput | FutureToolCreateOrConnectWithoutProjectInput[]
    upsert?: FutureToolUpsertWithWhereUniqueWithoutProjectInput | FutureToolUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: FutureToolCreateManyProjectInputEnvelope
    set?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    disconnect?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    delete?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    connect?: FutureToolWhereUniqueInput | FutureToolWhereUniqueInput[]
    update?: FutureToolUpdateWithWhereUniqueWithoutProjectInput | FutureToolUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: FutureToolUpdateManyWithWhereWithoutProjectInput | FutureToolUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: FutureToolScalarWhereInput | FutureToolScalarWhereInput[]
  }

  export type PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PerformanceMetricCreateWithoutProjectInput, PerformanceMetricUncheckedCreateWithoutProjectInput> | PerformanceMetricCreateWithoutProjectInput[] | PerformanceMetricUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PerformanceMetricCreateOrConnectWithoutProjectInput | PerformanceMetricCreateOrConnectWithoutProjectInput[]
    upsert?: PerformanceMetricUpsertWithWhereUniqueWithoutProjectInput | PerformanceMetricUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PerformanceMetricCreateManyProjectInputEnvelope
    set?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    disconnect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    delete?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    connect?: PerformanceMetricWhereUniqueInput | PerformanceMetricWhereUniqueInput[]
    update?: PerformanceMetricUpdateWithWhereUniqueWithoutProjectInput | PerformanceMetricUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PerformanceMetricUpdateManyWithWhereWithoutProjectInput | PerformanceMetricUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutOverviewInput = {
    create?: XOR<ProjectCreateWithoutOverviewInput, ProjectUncheckedCreateWithoutOverviewInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOverviewInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutOverviewNestedInput = {
    create?: XOR<ProjectCreateWithoutOverviewInput, ProjectUncheckedCreateWithoutOverviewInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutOverviewInput
    upsert?: ProjectUpsertWithoutOverviewInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutOverviewInput, ProjectUpdateWithoutOverviewInput>, ProjectUncheckedUpdateWithoutOverviewInput>
  }

  export type ProjectCreateNestedOneWithoutMetricsInput = {
    create?: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMetricsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMetricsInput
    upsert?: ProjectUpsertWithoutMetricsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMetricsInput, ProjectUpdateWithoutMetricsInput>, ProjectUncheckedUpdateWithoutMetricsInput>
  }

  export type ProjectCreateNestedOneWithoutTechnicalDetailsInput = {
    create?: XOR<ProjectCreateWithoutTechnicalDetailsInput, ProjectUncheckedCreateWithoutTechnicalDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTechnicalDetailsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTechnicalDetailsNestedInput = {
    create?: XOR<ProjectCreateWithoutTechnicalDetailsInput, ProjectUncheckedCreateWithoutTechnicalDetailsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTechnicalDetailsInput
    upsert?: ProjectUpsertWithoutTechnicalDetailsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTechnicalDetailsInput, ProjectUpdateWithoutTechnicalDetailsInput>, ProjectUncheckedUpdateWithoutTechnicalDetailsInput>
  }

  export type ProjectCreateNestedOneWithoutScreenshotsInput = {
    create?: XOR<ProjectCreateWithoutScreenshotsInput, ProjectUncheckedCreateWithoutScreenshotsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScreenshotsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutScreenshotsNestedInput = {
    create?: XOR<ProjectCreateWithoutScreenshotsInput, ProjectUncheckedCreateWithoutScreenshotsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutScreenshotsInput
    upsert?: ProjectUpsertWithoutScreenshotsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutScreenshotsInput, ProjectUpdateWithoutScreenshotsInput>, ProjectUncheckedUpdateWithoutScreenshotsInput>
  }

  export type ProjectCreateNestedOneWithoutTechnologiesInput = {
    create?: XOR<ProjectCreateWithoutTechnologiesInput, ProjectUncheckedCreateWithoutTechnologiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTechnologiesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutTechnologiesNestedInput = {
    create?: XOR<ProjectCreateWithoutTechnologiesInput, ProjectUncheckedCreateWithoutTechnologiesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTechnologiesInput
    upsert?: ProjectUpsertWithoutTechnologiesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTechnologiesInput, ProjectUpdateWithoutTechnologiesInput>, ProjectUncheckedUpdateWithoutTechnologiesInput>
  }

  export type ProjectTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ProjectTagCreateWithoutTagInput, ProjectTagUncheckedCreateWithoutTagInput> | ProjectTagCreateWithoutTagInput[] | ProjectTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutTagInput | ProjectTagCreateOrConnectWithoutTagInput[]
    createMany?: ProjectTagCreateManyTagInputEnvelope
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
  }

  export type ProjectTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ProjectTagCreateWithoutTagInput, ProjectTagUncheckedCreateWithoutTagInput> | ProjectTagCreateWithoutTagInput[] | ProjectTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutTagInput | ProjectTagCreateOrConnectWithoutTagInput[]
    createMany?: ProjectTagCreateManyTagInputEnvelope
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
  }

  export type ProjectTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ProjectTagCreateWithoutTagInput, ProjectTagUncheckedCreateWithoutTagInput> | ProjectTagCreateWithoutTagInput[] | ProjectTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutTagInput | ProjectTagCreateOrConnectWithoutTagInput[]
    upsert?: ProjectTagUpsertWithWhereUniqueWithoutTagInput | ProjectTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ProjectTagCreateManyTagInputEnvelope
    set?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    disconnect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    delete?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    update?: ProjectTagUpdateWithWhereUniqueWithoutTagInput | ProjectTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ProjectTagUpdateManyWithWhereWithoutTagInput | ProjectTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ProjectTagScalarWhereInput | ProjectTagScalarWhereInput[]
  }

  export type ProjectTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ProjectTagCreateWithoutTagInput, ProjectTagUncheckedCreateWithoutTagInput> | ProjectTagCreateWithoutTagInput[] | ProjectTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProjectTagCreateOrConnectWithoutTagInput | ProjectTagCreateOrConnectWithoutTagInput[]
    upsert?: ProjectTagUpsertWithWhereUniqueWithoutTagInput | ProjectTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ProjectTagCreateManyTagInputEnvelope
    set?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    disconnect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    delete?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    connect?: ProjectTagWhereUniqueInput | ProjectTagWhereUniqueInput[]
    update?: ProjectTagUpdateWithWhereUniqueWithoutTagInput | ProjectTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ProjectTagUpdateManyWithWhereWithoutTagInput | ProjectTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ProjectTagScalarWhereInput | ProjectTagScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutProjectTagsInput = {
    create?: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTagsInput
    connect?: ProjectWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutProjectTagsInput = {
    create?: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProjectTagsInput
    connect?: TagWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutProjectTagsNestedInput = {
    create?: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutProjectTagsInput
    upsert?: ProjectUpsertWithoutProjectTagsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutProjectTagsInput, ProjectUpdateWithoutProjectTagsInput>, ProjectUncheckedUpdateWithoutProjectTagsInput>
  }

  export type TagUpdateOneRequiredWithoutProjectTagsNestedInput = {
    create?: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProjectTagsInput
    upsert?: TagUpsertWithoutProjectTagsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutProjectTagsInput, TagUpdateWithoutProjectTagsInput>, TagUncheckedUpdateWithoutProjectTagsInput>
  }

  export type ProjectCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ProjectCreateWithoutLessonsInput, ProjectUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLessonsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<ProjectCreateWithoutLessonsInput, ProjectUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLessonsInput
    upsert?: ProjectUpsertWithoutLessonsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLessonsInput, ProjectUpdateWithoutLessonsInput>, ProjectUncheckedUpdateWithoutLessonsInput>
  }

  export type ProjectCreateNestedOneWithoutBusinessOutcomesInput = {
    create?: XOR<ProjectCreateWithoutBusinessOutcomesInput, ProjectUncheckedCreateWithoutBusinessOutcomesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBusinessOutcomesInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutBusinessOutcomesNestedInput = {
    create?: XOR<ProjectCreateWithoutBusinessOutcomesInput, ProjectUncheckedCreateWithoutBusinessOutcomesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutBusinessOutcomesInput
    upsert?: ProjectUpsertWithoutBusinessOutcomesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutBusinessOutcomesInput, ProjectUpdateWithoutBusinessOutcomesInput>, ProjectUncheckedUpdateWithoutBusinessOutcomesInput>
  }

  export type ProjectCreateNestedOneWithoutImprovementsInput = {
    create?: XOR<ProjectCreateWithoutImprovementsInput, ProjectUncheckedCreateWithoutImprovementsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutImprovementsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutImprovementsNestedInput = {
    create?: XOR<ProjectCreateWithoutImprovementsInput, ProjectUncheckedCreateWithoutImprovementsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutImprovementsInput
    upsert?: ProjectUpsertWithoutImprovementsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutImprovementsInput, ProjectUpdateWithoutImprovementsInput>, ProjectUncheckedUpdateWithoutImprovementsInput>
  }

  export type ProjectCreateNestedOneWithoutNextStepsInput = {
    create?: XOR<ProjectCreateWithoutNextStepsInput, ProjectUncheckedCreateWithoutNextStepsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNextStepsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutNextStepsNestedInput = {
    create?: XOR<ProjectCreateWithoutNextStepsInput, ProjectUncheckedCreateWithoutNextStepsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutNextStepsInput
    upsert?: ProjectUpsertWithoutNextStepsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutNextStepsInput, ProjectUpdateWithoutNextStepsInput>, ProjectUncheckedUpdateWithoutNextStepsInput>
  }

  export type ProjectCreateNestedOneWithoutFutureToolsInput = {
    create?: XOR<ProjectCreateWithoutFutureToolsInput, ProjectUncheckedCreateWithoutFutureToolsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFutureToolsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutFutureToolsNestedInput = {
    create?: XOR<ProjectCreateWithoutFutureToolsInput, ProjectUncheckedCreateWithoutFutureToolsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFutureToolsInput
    upsert?: ProjectUpsertWithoutFutureToolsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFutureToolsInput, ProjectUpdateWithoutFutureToolsInput>, ProjectUncheckedUpdateWithoutFutureToolsInput>
  }

  export type ProjectCreateNestedOneWithoutPerformanceMetricsInput = {
    create?: XOR<ProjectCreateWithoutPerformanceMetricsInput, ProjectUncheckedCreateWithoutPerformanceMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPerformanceMetricsInput
    connect?: ProjectWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutPerformanceMetricsNestedInput = {
    create?: XOR<ProjectCreateWithoutPerformanceMetricsInput, ProjectUncheckedCreateWithoutPerformanceMetricsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPerformanceMetricsInput
    upsert?: ProjectUpsertWithoutPerformanceMetricsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPerformanceMetricsInput, ProjectUpdateWithoutPerformanceMetricsInput>, ProjectUncheckedUpdateWithoutPerformanceMetricsInput>
  }

  export type CategoryCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<CategoryCreateWithoutBlogPostsInput, CategoryUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBlogPostsInput
    connect?: CategoryWhereUniqueInput
  }

  export type SeriesCreateNestedOneWithoutBlogPostsInput = {
    create?: XOR<SeriesCreateWithoutBlogPostsInput, SeriesUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutBlogPostsInput
    connect?: SeriesWhereUniqueInput
  }

  export type ContentBlockCreateNestedManyWithoutBlogPostInput = {
    create?: XOR<ContentBlockCreateWithoutBlogPostInput, ContentBlockUncheckedCreateWithoutBlogPostInput> | ContentBlockCreateWithoutBlogPostInput[] | ContentBlockUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogPostInput | ContentBlockCreateOrConnectWithoutBlogPostInput[]
    createMany?: ContentBlockCreateManyBlogPostInputEnvelope
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
  }

  export type BlogPostTagCreateNestedManyWithoutBlogPostInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogPostInput, BlogPostTagUncheckedCreateWithoutBlogPostInput> | BlogPostTagCreateWithoutBlogPostInput[] | BlogPostTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogPostInput | BlogPostTagCreateOrConnectWithoutBlogPostInput[]
    createMany?: BlogPostTagCreateManyBlogPostInputEnvelope
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
  }

  export type ContentBlockUncheckedCreateNestedManyWithoutBlogPostInput = {
    create?: XOR<ContentBlockCreateWithoutBlogPostInput, ContentBlockUncheckedCreateWithoutBlogPostInput> | ContentBlockCreateWithoutBlogPostInput[] | ContentBlockUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogPostInput | ContentBlockCreateOrConnectWithoutBlogPostInput[]
    createMany?: ContentBlockCreateManyBlogPostInputEnvelope
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
  }

  export type BlogPostTagUncheckedCreateNestedManyWithoutBlogPostInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogPostInput, BlogPostTagUncheckedCreateWithoutBlogPostInput> | BlogPostTagCreateWithoutBlogPostInput[] | BlogPostTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogPostInput | BlogPostTagCreateOrConnectWithoutBlogPostInput[]
    createMany?: BlogPostTagCreateManyBlogPostInputEnvelope
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CategoryUpdateOneWithoutBlogPostsNestedInput = {
    create?: XOR<CategoryCreateWithoutBlogPostsInput, CategoryUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutBlogPostsInput
    upsert?: CategoryUpsertWithoutBlogPostsInput
    disconnect?: CategoryWhereInput | boolean
    delete?: CategoryWhereInput | boolean
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutBlogPostsInput, CategoryUpdateWithoutBlogPostsInput>, CategoryUncheckedUpdateWithoutBlogPostsInput>
  }

  export type SeriesUpdateOneWithoutBlogPostsNestedInput = {
    create?: XOR<SeriesCreateWithoutBlogPostsInput, SeriesUncheckedCreateWithoutBlogPostsInput>
    connectOrCreate?: SeriesCreateOrConnectWithoutBlogPostsInput
    upsert?: SeriesUpsertWithoutBlogPostsInput
    disconnect?: SeriesWhereInput | boolean
    delete?: SeriesWhereInput | boolean
    connect?: SeriesWhereUniqueInput
    update?: XOR<XOR<SeriesUpdateToOneWithWhereWithoutBlogPostsInput, SeriesUpdateWithoutBlogPostsInput>, SeriesUncheckedUpdateWithoutBlogPostsInput>
  }

  export type ContentBlockUpdateManyWithoutBlogPostNestedInput = {
    create?: XOR<ContentBlockCreateWithoutBlogPostInput, ContentBlockUncheckedCreateWithoutBlogPostInput> | ContentBlockCreateWithoutBlogPostInput[] | ContentBlockUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogPostInput | ContentBlockCreateOrConnectWithoutBlogPostInput[]
    upsert?: ContentBlockUpsertWithWhereUniqueWithoutBlogPostInput | ContentBlockUpsertWithWhereUniqueWithoutBlogPostInput[]
    createMany?: ContentBlockCreateManyBlogPostInputEnvelope
    set?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    disconnect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    delete?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    update?: ContentBlockUpdateWithWhereUniqueWithoutBlogPostInput | ContentBlockUpdateWithWhereUniqueWithoutBlogPostInput[]
    updateMany?: ContentBlockUpdateManyWithWhereWithoutBlogPostInput | ContentBlockUpdateManyWithWhereWithoutBlogPostInput[]
    deleteMany?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
  }

  export type BlogPostTagUpdateManyWithoutBlogPostNestedInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogPostInput, BlogPostTagUncheckedCreateWithoutBlogPostInput> | BlogPostTagCreateWithoutBlogPostInput[] | BlogPostTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogPostInput | BlogPostTagCreateOrConnectWithoutBlogPostInput[]
    upsert?: BlogPostTagUpsertWithWhereUniqueWithoutBlogPostInput | BlogPostTagUpsertWithWhereUniqueWithoutBlogPostInput[]
    createMany?: BlogPostTagCreateManyBlogPostInputEnvelope
    set?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    disconnect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    delete?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    update?: BlogPostTagUpdateWithWhereUniqueWithoutBlogPostInput | BlogPostTagUpdateWithWhereUniqueWithoutBlogPostInput[]
    updateMany?: BlogPostTagUpdateManyWithWhereWithoutBlogPostInput | BlogPostTagUpdateManyWithWhereWithoutBlogPostInput[]
    deleteMany?: BlogPostTagScalarWhereInput | BlogPostTagScalarWhereInput[]
  }

  export type ContentBlockUncheckedUpdateManyWithoutBlogPostNestedInput = {
    create?: XOR<ContentBlockCreateWithoutBlogPostInput, ContentBlockUncheckedCreateWithoutBlogPostInput> | ContentBlockCreateWithoutBlogPostInput[] | ContentBlockUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: ContentBlockCreateOrConnectWithoutBlogPostInput | ContentBlockCreateOrConnectWithoutBlogPostInput[]
    upsert?: ContentBlockUpsertWithWhereUniqueWithoutBlogPostInput | ContentBlockUpsertWithWhereUniqueWithoutBlogPostInput[]
    createMany?: ContentBlockCreateManyBlogPostInputEnvelope
    set?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    disconnect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    delete?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    connect?: ContentBlockWhereUniqueInput | ContentBlockWhereUniqueInput[]
    update?: ContentBlockUpdateWithWhereUniqueWithoutBlogPostInput | ContentBlockUpdateWithWhereUniqueWithoutBlogPostInput[]
    updateMany?: ContentBlockUpdateManyWithWhereWithoutBlogPostInput | ContentBlockUpdateManyWithWhereWithoutBlogPostInput[]
    deleteMany?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
  }

  export type BlogPostTagUncheckedUpdateManyWithoutBlogPostNestedInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogPostInput, BlogPostTagUncheckedCreateWithoutBlogPostInput> | BlogPostTagCreateWithoutBlogPostInput[] | BlogPostTagUncheckedCreateWithoutBlogPostInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogPostInput | BlogPostTagCreateOrConnectWithoutBlogPostInput[]
    upsert?: BlogPostTagUpsertWithWhereUniqueWithoutBlogPostInput | BlogPostTagUpsertWithWhereUniqueWithoutBlogPostInput[]
    createMany?: BlogPostTagCreateManyBlogPostInputEnvelope
    set?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    disconnect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    delete?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    update?: BlogPostTagUpdateWithWhereUniqueWithoutBlogPostInput | BlogPostTagUpdateWithWhereUniqueWithoutBlogPostInput[]
    updateMany?: BlogPostTagUpdateManyWithWhereWithoutBlogPostInput | BlogPostTagUpdateManyWithWhereWithoutBlogPostInput[]
    deleteMany?: BlogPostTagScalarWhereInput | BlogPostTagScalarWhereInput[]
  }

  export type BlogPostCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput> | BlogPostCreateWithoutCategoryInput[] | BlogPostUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutCategoryInput | BlogPostCreateOrConnectWithoutCategoryInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutCategoryInput | BlogPostUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: BlogPostCreateManyCategoryInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutCategoryInput | BlogPostUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutCategoryInput | BlogPostUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostCreateNestedManyWithoutSeriesInput = {
    create?: XOR<BlogPostCreateWithoutSeriesInput, BlogPostUncheckedCreateWithoutSeriesInput> | BlogPostCreateWithoutSeriesInput[] | BlogPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeriesInput | BlogPostCreateOrConnectWithoutSeriesInput[]
    createMany?: BlogPostCreateManySeriesInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUncheckedCreateNestedManyWithoutSeriesInput = {
    create?: XOR<BlogPostCreateWithoutSeriesInput, BlogPostUncheckedCreateWithoutSeriesInput> | BlogPostCreateWithoutSeriesInput[] | BlogPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeriesInput | BlogPostCreateOrConnectWithoutSeriesInput[]
    createMany?: BlogPostCreateManySeriesInputEnvelope
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
  }

  export type BlogPostUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<BlogPostCreateWithoutSeriesInput, BlogPostUncheckedCreateWithoutSeriesInput> | BlogPostCreateWithoutSeriesInput[] | BlogPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeriesInput | BlogPostCreateOrConnectWithoutSeriesInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutSeriesInput | BlogPostUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: BlogPostCreateManySeriesInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutSeriesInput | BlogPostUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutSeriesInput | BlogPostUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostUncheckedUpdateManyWithoutSeriesNestedInput = {
    create?: XOR<BlogPostCreateWithoutSeriesInput, BlogPostUncheckedCreateWithoutSeriesInput> | BlogPostCreateWithoutSeriesInput[] | BlogPostUncheckedCreateWithoutSeriesInput[]
    connectOrCreate?: BlogPostCreateOrConnectWithoutSeriesInput | BlogPostCreateOrConnectWithoutSeriesInput[]
    upsert?: BlogPostUpsertWithWhereUniqueWithoutSeriesInput | BlogPostUpsertWithWhereUniqueWithoutSeriesInput[]
    createMany?: BlogPostCreateManySeriesInputEnvelope
    set?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    disconnect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    delete?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    connect?: BlogPostWhereUniqueInput | BlogPostWhereUniqueInput[]
    update?: BlogPostUpdateWithWhereUniqueWithoutSeriesInput | BlogPostUpdateWithWhereUniqueWithoutSeriesInput[]
    updateMany?: BlogPostUpdateManyWithWhereWithoutSeriesInput | BlogPostUpdateManyWithWhereWithoutSeriesInput[]
    deleteMany?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutContentBlocksInput = {
    create?: XOR<BlogPostCreateWithoutContentBlocksInput, BlogPostUncheckedCreateWithoutContentBlocksInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutContentBlocksInput
    connect?: BlogPostWhereUniqueInput
  }

  export type EnumContentBlockTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentBlockType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableEnumCalloutVariantFieldUpdateOperationsInput = {
    set?: $Enums.CalloutVariant | null
  }

  export type NullableEnumListStyleFieldUpdateOperationsInput = {
    set?: $Enums.ListStyle | null
  }

  export type NullableEnumVideoTypeFieldUpdateOperationsInput = {
    set?: $Enums.VideoType | null
  }

  export type BlogPostUpdateOneRequiredWithoutContentBlocksNestedInput = {
    create?: XOR<BlogPostCreateWithoutContentBlocksInput, BlogPostUncheckedCreateWithoutContentBlocksInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutContentBlocksInput
    upsert?: BlogPostUpsertWithoutContentBlocksInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutContentBlocksInput, BlogPostUpdateWithoutContentBlocksInput>, BlogPostUncheckedUpdateWithoutContentBlocksInput>
  }

  export type BlogPostTagCreateNestedManyWithoutBlogTagInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogTagInput, BlogPostTagUncheckedCreateWithoutBlogTagInput> | BlogPostTagCreateWithoutBlogTagInput[] | BlogPostTagUncheckedCreateWithoutBlogTagInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogTagInput | BlogPostTagCreateOrConnectWithoutBlogTagInput[]
    createMany?: BlogPostTagCreateManyBlogTagInputEnvelope
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
  }

  export type BlogPostTagUncheckedCreateNestedManyWithoutBlogTagInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogTagInput, BlogPostTagUncheckedCreateWithoutBlogTagInput> | BlogPostTagCreateWithoutBlogTagInput[] | BlogPostTagUncheckedCreateWithoutBlogTagInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogTagInput | BlogPostTagCreateOrConnectWithoutBlogTagInput[]
    createMany?: BlogPostTagCreateManyBlogTagInputEnvelope
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
  }

  export type BlogPostTagUpdateManyWithoutBlogTagNestedInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogTagInput, BlogPostTagUncheckedCreateWithoutBlogTagInput> | BlogPostTagCreateWithoutBlogTagInput[] | BlogPostTagUncheckedCreateWithoutBlogTagInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogTagInput | BlogPostTagCreateOrConnectWithoutBlogTagInput[]
    upsert?: BlogPostTagUpsertWithWhereUniqueWithoutBlogTagInput | BlogPostTagUpsertWithWhereUniqueWithoutBlogTagInput[]
    createMany?: BlogPostTagCreateManyBlogTagInputEnvelope
    set?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    disconnect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    delete?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    update?: BlogPostTagUpdateWithWhereUniqueWithoutBlogTagInput | BlogPostTagUpdateWithWhereUniqueWithoutBlogTagInput[]
    updateMany?: BlogPostTagUpdateManyWithWhereWithoutBlogTagInput | BlogPostTagUpdateManyWithWhereWithoutBlogTagInput[]
    deleteMany?: BlogPostTagScalarWhereInput | BlogPostTagScalarWhereInput[]
  }

  export type BlogPostTagUncheckedUpdateManyWithoutBlogTagNestedInput = {
    create?: XOR<BlogPostTagCreateWithoutBlogTagInput, BlogPostTagUncheckedCreateWithoutBlogTagInput> | BlogPostTagCreateWithoutBlogTagInput[] | BlogPostTagUncheckedCreateWithoutBlogTagInput[]
    connectOrCreate?: BlogPostTagCreateOrConnectWithoutBlogTagInput | BlogPostTagCreateOrConnectWithoutBlogTagInput[]
    upsert?: BlogPostTagUpsertWithWhereUniqueWithoutBlogTagInput | BlogPostTagUpsertWithWhereUniqueWithoutBlogTagInput[]
    createMany?: BlogPostTagCreateManyBlogTagInputEnvelope
    set?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    disconnect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    delete?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    connect?: BlogPostTagWhereUniqueInput | BlogPostTagWhereUniqueInput[]
    update?: BlogPostTagUpdateWithWhereUniqueWithoutBlogTagInput | BlogPostTagUpdateWithWhereUniqueWithoutBlogTagInput[]
    updateMany?: BlogPostTagUpdateManyWithWhereWithoutBlogTagInput | BlogPostTagUpdateManyWithWhereWithoutBlogTagInput[]
    deleteMany?: BlogPostTagScalarWhereInput | BlogPostTagScalarWhereInput[]
  }

  export type BlogPostCreateNestedOneWithoutBlogPostTagsInput = {
    create?: XOR<BlogPostCreateWithoutBlogPostTagsInput, BlogPostUncheckedCreateWithoutBlogPostTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutBlogPostTagsInput
    connect?: BlogPostWhereUniqueInput
  }

  export type BlogTagCreateNestedOneWithoutBlogPostTagsInput = {
    create?: XOR<BlogTagCreateWithoutBlogPostTagsInput, BlogTagUncheckedCreateWithoutBlogPostTagsInput>
    connectOrCreate?: BlogTagCreateOrConnectWithoutBlogPostTagsInput
    connect?: BlogTagWhereUniqueInput
  }

  export type BlogPostUpdateOneRequiredWithoutBlogPostTagsNestedInput = {
    create?: XOR<BlogPostCreateWithoutBlogPostTagsInput, BlogPostUncheckedCreateWithoutBlogPostTagsInput>
    connectOrCreate?: BlogPostCreateOrConnectWithoutBlogPostTagsInput
    upsert?: BlogPostUpsertWithoutBlogPostTagsInput
    connect?: BlogPostWhereUniqueInput
    update?: XOR<XOR<BlogPostUpdateToOneWithWhereWithoutBlogPostTagsInput, BlogPostUpdateWithoutBlogPostTagsInput>, BlogPostUncheckedUpdateWithoutBlogPostTagsInput>
  }

  export type BlogTagUpdateOneRequiredWithoutBlogPostTagsNestedInput = {
    create?: XOR<BlogTagCreateWithoutBlogPostTagsInput, BlogTagUncheckedCreateWithoutBlogPostTagsInput>
    connectOrCreate?: BlogTagCreateOrConnectWithoutBlogPostTagsInput
    upsert?: BlogTagUpsertWithoutBlogPostTagsInput
    connect?: BlogTagWhereUniqueInput
    update?: XOR<XOR<BlogTagUpdateToOneWithWhereWithoutBlogPostTagsInput, BlogTagUpdateWithoutBlogPostTagsInput>, BlogTagUncheckedUpdateWithoutBlogPostTagsInput>
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumContentBlockTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentBlockType | EnumContentBlockTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentBlockTypeFilter<$PrismaModel> | $Enums.ContentBlockType
  }

  export type NestedEnumCalloutVariantNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.CalloutVariant | EnumCalloutVariantFieldRefInput<$PrismaModel> | null
    in?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCalloutVariantNullableFilter<$PrismaModel> | $Enums.CalloutVariant | null
  }

  export type NestedEnumListStyleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ListStyle | EnumListStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListStyleNullableFilter<$PrismaModel> | $Enums.ListStyle | null
  }

  export type NestedEnumVideoTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVideoTypeNullableFilter<$PrismaModel> | $Enums.VideoType | null
  }

  export type NestedEnumContentBlockTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentBlockType | EnumContentBlockTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentBlockType[] | ListEnumContentBlockTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentBlockTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentBlockType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentBlockTypeFilter<$PrismaModel>
    _max?: NestedEnumContentBlockTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCalloutVariantNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CalloutVariant | EnumCalloutVariantFieldRefInput<$PrismaModel> | null
    in?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.CalloutVariant[] | ListEnumCalloutVariantFieldRefInput<$PrismaModel> | null
    not?: NestedEnumCalloutVariantNullableWithAggregatesFilter<$PrismaModel> | $Enums.CalloutVariant | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumCalloutVariantNullableFilter<$PrismaModel>
    _max?: NestedEnumCalloutVariantNullableFilter<$PrismaModel>
  }

  export type NestedEnumListStyleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ListStyle | EnumListStyleFieldRefInput<$PrismaModel> | null
    in?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ListStyle[] | ListEnumListStyleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumListStyleNullableWithAggregatesFilter<$PrismaModel> | $Enums.ListStyle | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumListStyleNullableFilter<$PrismaModel>
    _max?: NestedEnumListStyleNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumVideoTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VideoType | EnumVideoTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.VideoType[] | ListEnumVideoTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumVideoTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.VideoType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumVideoTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumVideoTypeNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ProjectOverviewCreateWithoutProjectInput = {
    problem: string
    solution: string
    role: string
    impact: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectOverviewUncheckedCreateWithoutProjectInput = {
    id?: number
    problem: string
    solution: string
    role: string
    impact: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectOverviewCreateOrConnectWithoutProjectInput = {
    where: ProjectOverviewWhereUniqueInput
    create: XOR<ProjectOverviewCreateWithoutProjectInput, ProjectOverviewUncheckedCreateWithoutProjectInput>
  }

  export type ProjectMetricsCreateWithoutProjectInput = {
    launchDate: string
    duration: string
    teamSize: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMetricsUncheckedCreateWithoutProjectInput = {
    id?: number
    launchDate: string
    duration: string
    teamSize: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectMetricsCreateOrConnectWithoutProjectInput = {
    where: ProjectMetricsWhereUniqueInput
    create: XOR<ProjectMetricsCreateWithoutProjectInput, ProjectMetricsUncheckedCreateWithoutProjectInput>
  }

  export type TechnicalDetailsCreateWithoutProjectInput = {
    database: string
    api: string
    components: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicalDetailsUncheckedCreateWithoutProjectInput = {
    id?: number
    database: string
    api: string
    components: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnicalDetailsCreateOrConnectWithoutProjectInput = {
    where: TechnicalDetailsWhereUniqueInput
    create: XOR<TechnicalDetailsCreateWithoutProjectInput, TechnicalDetailsUncheckedCreateWithoutProjectInput>
  }

  export type ScreenshotCreateWithoutProjectInput = {
    url: string
    description: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScreenshotUncheckedCreateWithoutProjectInput = {
    id?: number
    url: string
    description: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScreenshotCreateOrConnectWithoutProjectInput = {
    where: ScreenshotWhereUniqueInput
    create: XOR<ScreenshotCreateWithoutProjectInput, ScreenshotUncheckedCreateWithoutProjectInput>
  }

  export type ScreenshotCreateManyProjectInputEnvelope = {
    data: ScreenshotCreateManyProjectInput | ScreenshotCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TechnologyCreateWithoutProjectInput = {
    name: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnologyUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnologyCreateOrConnectWithoutProjectInput = {
    where: TechnologyWhereUniqueInput
    create: XOR<TechnologyCreateWithoutProjectInput, TechnologyUncheckedCreateWithoutProjectInput>
  }

  export type TechnologyCreateManyProjectInputEnvelope = {
    data: TechnologyCreateManyProjectInput | TechnologyCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTagCreateWithoutProjectInput = {
    createdAt?: Date | string
    tag: TagCreateNestedOneWithoutProjectTagsInput
  }

  export type ProjectTagUncheckedCreateWithoutProjectInput = {
    id?: number
    createdAt?: Date | string
    tagId: number
  }

  export type ProjectTagCreateOrConnectWithoutProjectInput = {
    where: ProjectTagWhereUniqueInput
    create: XOR<ProjectTagCreateWithoutProjectInput, ProjectTagUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTagCreateManyProjectInputEnvelope = {
    data: ProjectTagCreateManyProjectInput | ProjectTagCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutProjectInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUncheckedCreateWithoutProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateOrConnectWithoutProjectInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutProjectInput, LessonUncheckedCreateWithoutProjectInput>
  }

  export type LessonCreateManyProjectInputEnvelope = {
    data: LessonCreateManyProjectInput | LessonCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type BusinessOutcomeCreateWithoutProjectInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessOutcomeUncheckedCreateWithoutProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessOutcomeCreateOrConnectWithoutProjectInput = {
    where: BusinessOutcomeWhereUniqueInput
    create: XOR<BusinessOutcomeCreateWithoutProjectInput, BusinessOutcomeUncheckedCreateWithoutProjectInput>
  }

  export type BusinessOutcomeCreateManyProjectInputEnvelope = {
    data: BusinessOutcomeCreateManyProjectInput | BusinessOutcomeCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ImprovementCreateWithoutProjectInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImprovementUncheckedCreateWithoutProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImprovementCreateOrConnectWithoutProjectInput = {
    where: ImprovementWhereUniqueInput
    create: XOR<ImprovementCreateWithoutProjectInput, ImprovementUncheckedCreateWithoutProjectInput>
  }

  export type ImprovementCreateManyProjectInputEnvelope = {
    data: ImprovementCreateManyProjectInput | ImprovementCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type NextStepCreateWithoutProjectInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NextStepUncheckedCreateWithoutProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NextStepCreateOrConnectWithoutProjectInput = {
    where: NextStepWhereUniqueInput
    create: XOR<NextStepCreateWithoutProjectInput, NextStepUncheckedCreateWithoutProjectInput>
  }

  export type NextStepCreateManyProjectInputEnvelope = {
    data: NextStepCreateManyProjectInput | NextStepCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type FutureToolCreateWithoutProjectInput = {
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FutureToolUncheckedCreateWithoutProjectInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FutureToolCreateOrConnectWithoutProjectInput = {
    where: FutureToolWhereUniqueInput
    create: XOR<FutureToolCreateWithoutProjectInput, FutureToolUncheckedCreateWithoutProjectInput>
  }

  export type FutureToolCreateManyProjectInputEnvelope = {
    data: FutureToolCreateManyProjectInput | FutureToolCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PerformanceMetricCreateWithoutProjectInput = {
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceMetricUncheckedCreateWithoutProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceMetricCreateOrConnectWithoutProjectInput = {
    where: PerformanceMetricWhereUniqueInput
    create: XOR<PerformanceMetricCreateWithoutProjectInput, PerformanceMetricUncheckedCreateWithoutProjectInput>
  }

  export type PerformanceMetricCreateManyProjectInputEnvelope = {
    data: PerformanceMetricCreateManyProjectInput | PerformanceMetricCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectOverviewUpsertWithoutProjectInput = {
    update: XOR<ProjectOverviewUpdateWithoutProjectInput, ProjectOverviewUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectOverviewCreateWithoutProjectInput, ProjectOverviewUncheckedCreateWithoutProjectInput>
    where?: ProjectOverviewWhereInput
  }

  export type ProjectOverviewUpdateToOneWithWhereWithoutProjectInput = {
    where?: ProjectOverviewWhereInput
    data: XOR<ProjectOverviewUpdateWithoutProjectInput, ProjectOverviewUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectOverviewUpdateWithoutProjectInput = {
    problem?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectOverviewUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    problem?: StringFieldUpdateOperationsInput | string
    solution?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    impact?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricsUpsertWithoutProjectInput = {
    update: XOR<ProjectMetricsUpdateWithoutProjectInput, ProjectMetricsUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectMetricsCreateWithoutProjectInput, ProjectMetricsUncheckedCreateWithoutProjectInput>
    where?: ProjectMetricsWhereInput
  }

  export type ProjectMetricsUpdateToOneWithWhereWithoutProjectInput = {
    where?: ProjectMetricsWhereInput
    data: XOR<ProjectMetricsUpdateWithoutProjectInput, ProjectMetricsUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectMetricsUpdateWithoutProjectInput = {
    launchDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectMetricsUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    launchDate?: StringFieldUpdateOperationsInput | string
    duration?: StringFieldUpdateOperationsInput | string
    teamSize?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicalDetailsUpsertWithoutProjectInput = {
    update: XOR<TechnicalDetailsUpdateWithoutProjectInput, TechnicalDetailsUncheckedUpdateWithoutProjectInput>
    create: XOR<TechnicalDetailsCreateWithoutProjectInput, TechnicalDetailsUncheckedCreateWithoutProjectInput>
    where?: TechnicalDetailsWhereInput
  }

  export type TechnicalDetailsUpdateToOneWithWhereWithoutProjectInput = {
    where?: TechnicalDetailsWhereInput
    data: XOR<TechnicalDetailsUpdateWithoutProjectInput, TechnicalDetailsUncheckedUpdateWithoutProjectInput>
  }

  export type TechnicalDetailsUpdateWithoutProjectInput = {
    database?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
    components?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnicalDetailsUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    database?: StringFieldUpdateOperationsInput | string
    api?: StringFieldUpdateOperationsInput | string
    components?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenshotUpsertWithWhereUniqueWithoutProjectInput = {
    where: ScreenshotWhereUniqueInput
    update: XOR<ScreenshotUpdateWithoutProjectInput, ScreenshotUncheckedUpdateWithoutProjectInput>
    create: XOR<ScreenshotCreateWithoutProjectInput, ScreenshotUncheckedCreateWithoutProjectInput>
  }

  export type ScreenshotUpdateWithWhereUniqueWithoutProjectInput = {
    where: ScreenshotWhereUniqueInput
    data: XOR<ScreenshotUpdateWithoutProjectInput, ScreenshotUncheckedUpdateWithoutProjectInput>
  }

  export type ScreenshotUpdateManyWithWhereWithoutProjectInput = {
    where: ScreenshotScalarWhereInput
    data: XOR<ScreenshotUpdateManyMutationInput, ScreenshotUncheckedUpdateManyWithoutProjectInput>
  }

  export type ScreenshotScalarWhereInput = {
    AND?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
    OR?: ScreenshotScalarWhereInput[]
    NOT?: ScreenshotScalarWhereInput | ScreenshotScalarWhereInput[]
    id?: IntFilter<"Screenshot"> | number
    url?: StringFilter<"Screenshot"> | string
    description?: StringFilter<"Screenshot"> | string
    order?: IntFilter<"Screenshot"> | number
    createdAt?: DateTimeFilter<"Screenshot"> | Date | string
    updatedAt?: DateTimeFilter<"Screenshot"> | Date | string
    projectId?: IntFilter<"Screenshot"> | number
  }

  export type TechnologyUpsertWithWhereUniqueWithoutProjectInput = {
    where: TechnologyWhereUniqueInput
    update: XOR<TechnologyUpdateWithoutProjectInput, TechnologyUncheckedUpdateWithoutProjectInput>
    create: XOR<TechnologyCreateWithoutProjectInput, TechnologyUncheckedCreateWithoutProjectInput>
  }

  export type TechnologyUpdateWithWhereUniqueWithoutProjectInput = {
    where: TechnologyWhereUniqueInput
    data: XOR<TechnologyUpdateWithoutProjectInput, TechnologyUncheckedUpdateWithoutProjectInput>
  }

  export type TechnologyUpdateManyWithWhereWithoutProjectInput = {
    where: TechnologyScalarWhereInput
    data: XOR<TechnologyUpdateManyMutationInput, TechnologyUncheckedUpdateManyWithoutProjectInput>
  }

  export type TechnologyScalarWhereInput = {
    AND?: TechnologyScalarWhereInput | TechnologyScalarWhereInput[]
    OR?: TechnologyScalarWhereInput[]
    NOT?: TechnologyScalarWhereInput | TechnologyScalarWhereInput[]
    id?: IntFilter<"Technology"> | number
    name?: StringFilter<"Technology"> | string
    reason?: StringFilter<"Technology"> | string
    createdAt?: DateTimeFilter<"Technology"> | Date | string
    updatedAt?: DateTimeFilter<"Technology"> | Date | string
    projectId?: IntFilter<"Technology"> | number
  }

  export type ProjectTagUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectTagWhereUniqueInput
    update: XOR<ProjectTagUpdateWithoutProjectInput, ProjectTagUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectTagCreateWithoutProjectInput, ProjectTagUncheckedCreateWithoutProjectInput>
  }

  export type ProjectTagUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectTagWhereUniqueInput
    data: XOR<ProjectTagUpdateWithoutProjectInput, ProjectTagUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectTagUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectTagScalarWhereInput
    data: XOR<ProjectTagUpdateManyMutationInput, ProjectTagUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectTagScalarWhereInput = {
    AND?: ProjectTagScalarWhereInput | ProjectTagScalarWhereInput[]
    OR?: ProjectTagScalarWhereInput[]
    NOT?: ProjectTagScalarWhereInput | ProjectTagScalarWhereInput[]
    id?: IntFilter<"ProjectTag"> | number
    createdAt?: DateTimeFilter<"ProjectTag"> | Date | string
    projectId?: IntFilter<"ProjectTag"> | number
    tagId?: IntFilter<"ProjectTag"> | number
  }

  export type LessonUpsertWithWhereUniqueWithoutProjectInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutProjectInput, LessonUncheckedUpdateWithoutProjectInput>
    create: XOR<LessonCreateWithoutProjectInput, LessonUncheckedCreateWithoutProjectInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutProjectInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutProjectInput, LessonUncheckedUpdateWithoutProjectInput>
  }

  export type LessonUpdateManyWithWhereWithoutProjectInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutProjectInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: IntFilter<"Lesson"> | number
    description?: StringFilter<"Lesson"> | string
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    projectId?: IntFilter<"Lesson"> | number
  }

  export type BusinessOutcomeUpsertWithWhereUniqueWithoutProjectInput = {
    where: BusinessOutcomeWhereUniqueInput
    update: XOR<BusinessOutcomeUpdateWithoutProjectInput, BusinessOutcomeUncheckedUpdateWithoutProjectInput>
    create: XOR<BusinessOutcomeCreateWithoutProjectInput, BusinessOutcomeUncheckedCreateWithoutProjectInput>
  }

  export type BusinessOutcomeUpdateWithWhereUniqueWithoutProjectInput = {
    where: BusinessOutcomeWhereUniqueInput
    data: XOR<BusinessOutcomeUpdateWithoutProjectInput, BusinessOutcomeUncheckedUpdateWithoutProjectInput>
  }

  export type BusinessOutcomeUpdateManyWithWhereWithoutProjectInput = {
    where: BusinessOutcomeScalarWhereInput
    data: XOR<BusinessOutcomeUpdateManyMutationInput, BusinessOutcomeUncheckedUpdateManyWithoutProjectInput>
  }

  export type BusinessOutcomeScalarWhereInput = {
    AND?: BusinessOutcomeScalarWhereInput | BusinessOutcomeScalarWhereInput[]
    OR?: BusinessOutcomeScalarWhereInput[]
    NOT?: BusinessOutcomeScalarWhereInput | BusinessOutcomeScalarWhereInput[]
    id?: IntFilter<"BusinessOutcome"> | number
    description?: StringFilter<"BusinessOutcome"> | string
    createdAt?: DateTimeFilter<"BusinessOutcome"> | Date | string
    updatedAt?: DateTimeFilter<"BusinessOutcome"> | Date | string
    projectId?: IntFilter<"BusinessOutcome"> | number
  }

  export type ImprovementUpsertWithWhereUniqueWithoutProjectInput = {
    where: ImprovementWhereUniqueInput
    update: XOR<ImprovementUpdateWithoutProjectInput, ImprovementUncheckedUpdateWithoutProjectInput>
    create: XOR<ImprovementCreateWithoutProjectInput, ImprovementUncheckedCreateWithoutProjectInput>
  }

  export type ImprovementUpdateWithWhereUniqueWithoutProjectInput = {
    where: ImprovementWhereUniqueInput
    data: XOR<ImprovementUpdateWithoutProjectInput, ImprovementUncheckedUpdateWithoutProjectInput>
  }

  export type ImprovementUpdateManyWithWhereWithoutProjectInput = {
    where: ImprovementScalarWhereInput
    data: XOR<ImprovementUpdateManyMutationInput, ImprovementUncheckedUpdateManyWithoutProjectInput>
  }

  export type ImprovementScalarWhereInput = {
    AND?: ImprovementScalarWhereInput | ImprovementScalarWhereInput[]
    OR?: ImprovementScalarWhereInput[]
    NOT?: ImprovementScalarWhereInput | ImprovementScalarWhereInput[]
    id?: IntFilter<"Improvement"> | number
    description?: StringFilter<"Improvement"> | string
    createdAt?: DateTimeFilter<"Improvement"> | Date | string
    updatedAt?: DateTimeFilter<"Improvement"> | Date | string
    projectId?: IntFilter<"Improvement"> | number
  }

  export type NextStepUpsertWithWhereUniqueWithoutProjectInput = {
    where: NextStepWhereUniqueInput
    update: XOR<NextStepUpdateWithoutProjectInput, NextStepUncheckedUpdateWithoutProjectInput>
    create: XOR<NextStepCreateWithoutProjectInput, NextStepUncheckedCreateWithoutProjectInput>
  }

  export type NextStepUpdateWithWhereUniqueWithoutProjectInput = {
    where: NextStepWhereUniqueInput
    data: XOR<NextStepUpdateWithoutProjectInput, NextStepUncheckedUpdateWithoutProjectInput>
  }

  export type NextStepUpdateManyWithWhereWithoutProjectInput = {
    where: NextStepScalarWhereInput
    data: XOR<NextStepUpdateManyMutationInput, NextStepUncheckedUpdateManyWithoutProjectInput>
  }

  export type NextStepScalarWhereInput = {
    AND?: NextStepScalarWhereInput | NextStepScalarWhereInput[]
    OR?: NextStepScalarWhereInput[]
    NOT?: NextStepScalarWhereInput | NextStepScalarWhereInput[]
    id?: IntFilter<"NextStep"> | number
    description?: StringFilter<"NextStep"> | string
    createdAt?: DateTimeFilter<"NextStep"> | Date | string
    updatedAt?: DateTimeFilter<"NextStep"> | Date | string
    projectId?: IntFilter<"NextStep"> | number
  }

  export type FutureToolUpsertWithWhereUniqueWithoutProjectInput = {
    where: FutureToolWhereUniqueInput
    update: XOR<FutureToolUpdateWithoutProjectInput, FutureToolUncheckedUpdateWithoutProjectInput>
    create: XOR<FutureToolCreateWithoutProjectInput, FutureToolUncheckedCreateWithoutProjectInput>
  }

  export type FutureToolUpdateWithWhereUniqueWithoutProjectInput = {
    where: FutureToolWhereUniqueInput
    data: XOR<FutureToolUpdateWithoutProjectInput, FutureToolUncheckedUpdateWithoutProjectInput>
  }

  export type FutureToolUpdateManyWithWhereWithoutProjectInput = {
    where: FutureToolScalarWhereInput
    data: XOR<FutureToolUpdateManyMutationInput, FutureToolUncheckedUpdateManyWithoutProjectInput>
  }

  export type FutureToolScalarWhereInput = {
    AND?: FutureToolScalarWhereInput | FutureToolScalarWhereInput[]
    OR?: FutureToolScalarWhereInput[]
    NOT?: FutureToolScalarWhereInput | FutureToolScalarWhereInput[]
    id?: IntFilter<"FutureTool"> | number
    name?: StringFilter<"FutureTool"> | string
    createdAt?: DateTimeFilter<"FutureTool"> | Date | string
    updatedAt?: DateTimeFilter<"FutureTool"> | Date | string
    projectId?: IntFilter<"FutureTool"> | number
  }

  export type PerformanceMetricUpsertWithWhereUniqueWithoutProjectInput = {
    where: PerformanceMetricWhereUniqueInput
    update: XOR<PerformanceMetricUpdateWithoutProjectInput, PerformanceMetricUncheckedUpdateWithoutProjectInput>
    create: XOR<PerformanceMetricCreateWithoutProjectInput, PerformanceMetricUncheckedCreateWithoutProjectInput>
  }

  export type PerformanceMetricUpdateWithWhereUniqueWithoutProjectInput = {
    where: PerformanceMetricWhereUniqueInput
    data: XOR<PerformanceMetricUpdateWithoutProjectInput, PerformanceMetricUncheckedUpdateWithoutProjectInput>
  }

  export type PerformanceMetricUpdateManyWithWhereWithoutProjectInput = {
    where: PerformanceMetricScalarWhereInput
    data: XOR<PerformanceMetricUpdateManyMutationInput, PerformanceMetricUncheckedUpdateManyWithoutProjectInput>
  }

  export type PerformanceMetricScalarWhereInput = {
    AND?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
    OR?: PerformanceMetricScalarWhereInput[]
    NOT?: PerformanceMetricScalarWhereInput | PerformanceMetricScalarWhereInput[]
    id?: IntFilter<"PerformanceMetric"> | number
    description?: StringFilter<"PerformanceMetric"> | string
    createdAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    updatedAt?: DateTimeFilter<"PerformanceMetric"> | Date | string
    projectId?: IntFilter<"PerformanceMetric"> | number
  }

  export type ProjectCreateWithoutOverviewInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutOverviewInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutOverviewInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutOverviewInput, ProjectUncheckedCreateWithoutOverviewInput>
  }

  export type ProjectUpsertWithoutOverviewInput = {
    update: XOR<ProjectUpdateWithoutOverviewInput, ProjectUncheckedUpdateWithoutOverviewInput>
    create: XOR<ProjectCreateWithoutOverviewInput, ProjectUncheckedCreateWithoutOverviewInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutOverviewInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutOverviewInput, ProjectUncheckedUpdateWithoutOverviewInput>
  }

  export type ProjectUpdateWithoutOverviewInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutOverviewInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutMetricsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMetricsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMetricsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
  }

  export type ProjectUpsertWithoutMetricsInput = {
    update: XOR<ProjectUpdateWithoutMetricsInput, ProjectUncheckedUpdateWithoutMetricsInput>
    create: XOR<ProjectCreateWithoutMetricsInput, ProjectUncheckedCreateWithoutMetricsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMetricsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMetricsInput, ProjectUncheckedUpdateWithoutMetricsInput>
  }

  export type ProjectUpdateWithoutMetricsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMetricsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutTechnicalDetailsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTechnicalDetailsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTechnicalDetailsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTechnicalDetailsInput, ProjectUncheckedCreateWithoutTechnicalDetailsInput>
  }

  export type ProjectUpsertWithoutTechnicalDetailsInput = {
    update: XOR<ProjectUpdateWithoutTechnicalDetailsInput, ProjectUncheckedUpdateWithoutTechnicalDetailsInput>
    create: XOR<ProjectCreateWithoutTechnicalDetailsInput, ProjectUncheckedCreateWithoutTechnicalDetailsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTechnicalDetailsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTechnicalDetailsInput, ProjectUncheckedUpdateWithoutTechnicalDetailsInput>
  }

  export type ProjectUpdateWithoutTechnicalDetailsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTechnicalDetailsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutScreenshotsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutScreenshotsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutScreenshotsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutScreenshotsInput, ProjectUncheckedCreateWithoutScreenshotsInput>
  }

  export type ProjectUpsertWithoutScreenshotsInput = {
    update: XOR<ProjectUpdateWithoutScreenshotsInput, ProjectUncheckedUpdateWithoutScreenshotsInput>
    create: XOR<ProjectCreateWithoutScreenshotsInput, ProjectUncheckedCreateWithoutScreenshotsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutScreenshotsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutScreenshotsInput, ProjectUncheckedUpdateWithoutScreenshotsInput>
  }

  export type ProjectUpdateWithoutScreenshotsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutScreenshotsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutTechnologiesInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutTechnologiesInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutTechnologiesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTechnologiesInput, ProjectUncheckedCreateWithoutTechnologiesInput>
  }

  export type ProjectUpsertWithoutTechnologiesInput = {
    update: XOR<ProjectUpdateWithoutTechnologiesInput, ProjectUncheckedUpdateWithoutTechnologiesInput>
    create: XOR<ProjectCreateWithoutTechnologiesInput, ProjectUncheckedCreateWithoutTechnologiesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTechnologiesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTechnologiesInput, ProjectUncheckedUpdateWithoutTechnologiesInput>
  }

  export type ProjectUpdateWithoutTechnologiesInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutTechnologiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectTagCreateWithoutTagInput = {
    createdAt?: Date | string
    project: ProjectCreateNestedOneWithoutProjectTagsInput
  }

  export type ProjectTagUncheckedCreateWithoutTagInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
  }

  export type ProjectTagCreateOrConnectWithoutTagInput = {
    where: ProjectTagWhereUniqueInput
    create: XOR<ProjectTagCreateWithoutTagInput, ProjectTagUncheckedCreateWithoutTagInput>
  }

  export type ProjectTagCreateManyTagInputEnvelope = {
    data: ProjectTagCreateManyTagInput | ProjectTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ProjectTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ProjectTagWhereUniqueInput
    update: XOR<ProjectTagUpdateWithoutTagInput, ProjectTagUncheckedUpdateWithoutTagInput>
    create: XOR<ProjectTagCreateWithoutTagInput, ProjectTagUncheckedCreateWithoutTagInput>
  }

  export type ProjectTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ProjectTagWhereUniqueInput
    data: XOR<ProjectTagUpdateWithoutTagInput, ProjectTagUncheckedUpdateWithoutTagInput>
  }

  export type ProjectTagUpdateManyWithWhereWithoutTagInput = {
    where: ProjectTagScalarWhereInput
    data: XOR<ProjectTagUpdateManyMutationInput, ProjectTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ProjectCreateWithoutProjectTagsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutProjectTagsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutProjectTagsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
  }

  export type TagCreateWithoutProjectTagsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutProjectTagsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutProjectTagsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
  }

  export type ProjectUpsertWithoutProjectTagsInput = {
    update: XOR<ProjectUpdateWithoutProjectTagsInput, ProjectUncheckedUpdateWithoutProjectTagsInput>
    create: XOR<ProjectCreateWithoutProjectTagsInput, ProjectUncheckedCreateWithoutProjectTagsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutProjectTagsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutProjectTagsInput, ProjectUncheckedUpdateWithoutProjectTagsInput>
  }

  export type ProjectUpdateWithoutProjectTagsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutProjectTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type TagUpsertWithoutProjectTagsInput = {
    update: XOR<TagUpdateWithoutProjectTagsInput, TagUncheckedUpdateWithoutProjectTagsInput>
    create: XOR<TagCreateWithoutProjectTagsInput, TagUncheckedCreateWithoutProjectTagsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutProjectTagsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutProjectTagsInput, TagUncheckedUpdateWithoutProjectTagsInput>
  }

  export type TagUpdateWithoutProjectTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutProjectTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateWithoutLessonsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLessonsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLessonsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLessonsInput, ProjectUncheckedCreateWithoutLessonsInput>
  }

  export type ProjectUpsertWithoutLessonsInput = {
    update: XOR<ProjectUpdateWithoutLessonsInput, ProjectUncheckedUpdateWithoutLessonsInput>
    create: XOR<ProjectCreateWithoutLessonsInput, ProjectUncheckedCreateWithoutLessonsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLessonsInput, ProjectUncheckedUpdateWithoutLessonsInput>
  }

  export type ProjectUpdateWithoutLessonsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLessonsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutBusinessOutcomesInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutBusinessOutcomesInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutBusinessOutcomesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutBusinessOutcomesInput, ProjectUncheckedCreateWithoutBusinessOutcomesInput>
  }

  export type ProjectUpsertWithoutBusinessOutcomesInput = {
    update: XOR<ProjectUpdateWithoutBusinessOutcomesInput, ProjectUncheckedUpdateWithoutBusinessOutcomesInput>
    create: XOR<ProjectCreateWithoutBusinessOutcomesInput, ProjectUncheckedCreateWithoutBusinessOutcomesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutBusinessOutcomesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutBusinessOutcomesInput, ProjectUncheckedUpdateWithoutBusinessOutcomesInput>
  }

  export type ProjectUpdateWithoutBusinessOutcomesInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutBusinessOutcomesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutImprovementsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutImprovementsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutImprovementsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutImprovementsInput, ProjectUncheckedCreateWithoutImprovementsInput>
  }

  export type ProjectUpsertWithoutImprovementsInput = {
    update: XOR<ProjectUpdateWithoutImprovementsInput, ProjectUncheckedUpdateWithoutImprovementsInput>
    create: XOR<ProjectCreateWithoutImprovementsInput, ProjectUncheckedCreateWithoutImprovementsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutImprovementsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutImprovementsInput, ProjectUncheckedUpdateWithoutImprovementsInput>
  }

  export type ProjectUpdateWithoutImprovementsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutImprovementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutNextStepsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutNextStepsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutNextStepsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutNextStepsInput, ProjectUncheckedCreateWithoutNextStepsInput>
  }

  export type ProjectUpsertWithoutNextStepsInput = {
    update: XOR<ProjectUpdateWithoutNextStepsInput, ProjectUncheckedUpdateWithoutNextStepsInput>
    create: XOR<ProjectCreateWithoutNextStepsInput, ProjectUncheckedCreateWithoutNextStepsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutNextStepsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutNextStepsInput, ProjectUncheckedUpdateWithoutNextStepsInput>
  }

  export type ProjectUpdateWithoutNextStepsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutNextStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutFutureToolsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFutureToolsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    performanceMetrics?: PerformanceMetricUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFutureToolsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFutureToolsInput, ProjectUncheckedCreateWithoutFutureToolsInput>
  }

  export type ProjectUpsertWithoutFutureToolsInput = {
    update: XOR<ProjectUpdateWithoutFutureToolsInput, ProjectUncheckedUpdateWithoutFutureToolsInput>
    create: XOR<ProjectCreateWithoutFutureToolsInput, ProjectUncheckedCreateWithoutFutureToolsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFutureToolsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFutureToolsInput, ProjectUncheckedUpdateWithoutFutureToolsInput>
  }

  export type ProjectUpdateWithoutFutureToolsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFutureToolsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    performanceMetrics?: PerformanceMetricUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateWithoutPerformanceMetricsInput = {
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotCreateNestedManyWithoutProjectInput
    technologies?: TechnologyCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagCreateNestedManyWithoutProjectInput
    lessons?: LessonCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeCreateNestedManyWithoutProjectInput
    improvements?: ImprovementCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPerformanceMetricsInput = {
    id?: number
    title: string
    subtitle: string
    slug: string
    status: $Enums.ProjectStatus
    heroImage: string
    liveDemo?: string | null
    github?: string | null
    caseStudy?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    overview?: ProjectOverviewUncheckedCreateNestedOneWithoutProjectInput
    metrics?: ProjectMetricsUncheckedCreateNestedOneWithoutProjectInput
    technicalDetails?: TechnicalDetailsUncheckedCreateNestedOneWithoutProjectInput
    screenshots?: ScreenshotUncheckedCreateNestedManyWithoutProjectInput
    technologies?: TechnologyUncheckedCreateNestedManyWithoutProjectInput
    projectTags?: ProjectTagUncheckedCreateNestedManyWithoutProjectInput
    lessons?: LessonUncheckedCreateNestedManyWithoutProjectInput
    businessOutcomes?: BusinessOutcomeUncheckedCreateNestedManyWithoutProjectInput
    improvements?: ImprovementUncheckedCreateNestedManyWithoutProjectInput
    nextSteps?: NextStepUncheckedCreateNestedManyWithoutProjectInput
    futureTools?: FutureToolUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPerformanceMetricsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPerformanceMetricsInput, ProjectUncheckedCreateWithoutPerformanceMetricsInput>
  }

  export type ProjectUpsertWithoutPerformanceMetricsInput = {
    update: XOR<ProjectUpdateWithoutPerformanceMetricsInput, ProjectUncheckedUpdateWithoutPerformanceMetricsInput>
    create: XOR<ProjectCreateWithoutPerformanceMetricsInput, ProjectUncheckedCreateWithoutPerformanceMetricsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPerformanceMetricsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPerformanceMetricsInput, ProjectUncheckedUpdateWithoutPerformanceMetricsInput>
  }

  export type ProjectUpdateWithoutPerformanceMetricsInput = {
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUpdateManyWithoutProjectNestedInput
    lessons?: LessonUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPerformanceMetricsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    heroImage?: StringFieldUpdateOperationsInput | string
    liveDemo?: NullableStringFieldUpdateOperationsInput | string | null
    github?: NullableStringFieldUpdateOperationsInput | string | null
    caseStudy?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    overview?: ProjectOverviewUncheckedUpdateOneWithoutProjectNestedInput
    metrics?: ProjectMetricsUncheckedUpdateOneWithoutProjectNestedInput
    technicalDetails?: TechnicalDetailsUncheckedUpdateOneWithoutProjectNestedInput
    screenshots?: ScreenshotUncheckedUpdateManyWithoutProjectNestedInput
    technologies?: TechnologyUncheckedUpdateManyWithoutProjectNestedInput
    projectTags?: ProjectTagUncheckedUpdateManyWithoutProjectNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutProjectNestedInput
    businessOutcomes?: BusinessOutcomeUncheckedUpdateManyWithoutProjectNestedInput
    improvements?: ImprovementUncheckedUpdateManyWithoutProjectNestedInput
    nextSteps?: NextStepUncheckedUpdateManyWithoutProjectNestedInput
    futureTools?: FutureToolUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type CategoryCreateWithoutBlogPostsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryUncheckedCreateWithoutBlogPostsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CategoryCreateOrConnectWithoutBlogPostsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutBlogPostsInput, CategoryUncheckedCreateWithoutBlogPostsInput>
  }

  export type SeriesCreateWithoutBlogPostsInput = {
    name: string
    slug: string
    description?: string | null
    totalParts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesUncheckedCreateWithoutBlogPostsInput = {
    id?: number
    name: string
    slug: string
    description?: string | null
    totalParts?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SeriesCreateOrConnectWithoutBlogPostsInput = {
    where: SeriesWhereUniqueInput
    create: XOR<SeriesCreateWithoutBlogPostsInput, SeriesUncheckedCreateWithoutBlogPostsInput>
  }

  export type ContentBlockCreateWithoutBlogPostInput = {
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: number | null
    language?: string | null
    codeTitle?: string | null
    imageUrl?: string | null
    imageAlt?: string | null
    imageCaption?: string | null
    imageAlignment?: string | null
    calloutVariant?: $Enums.CalloutVariant | null
    calloutTitle?: string | null
    quoteAuthor?: string | null
    listStyle?: $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: $Enums.VideoType | null
    videoId?: string | null
    videoTitle?: string | null
    paragraphStyle?: string | null
  }

  export type ContentBlockUncheckedCreateWithoutBlogPostInput = {
    id?: number
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: number | null
    language?: string | null
    codeTitle?: string | null
    imageUrl?: string | null
    imageAlt?: string | null
    imageCaption?: string | null
    imageAlignment?: string | null
    calloutVariant?: $Enums.CalloutVariant | null
    calloutTitle?: string | null
    quoteAuthor?: string | null
    listStyle?: $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: $Enums.VideoType | null
    videoId?: string | null
    videoTitle?: string | null
    paragraphStyle?: string | null
  }

  export type ContentBlockCreateOrConnectWithoutBlogPostInput = {
    where: ContentBlockWhereUniqueInput
    create: XOR<ContentBlockCreateWithoutBlogPostInput, ContentBlockUncheckedCreateWithoutBlogPostInput>
  }

  export type ContentBlockCreateManyBlogPostInputEnvelope = {
    data: ContentBlockCreateManyBlogPostInput | ContentBlockCreateManyBlogPostInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostTagCreateWithoutBlogPostInput = {
    createdAt?: Date | string
    blogTag: BlogTagCreateNestedOneWithoutBlogPostTagsInput
  }

  export type BlogPostTagUncheckedCreateWithoutBlogPostInput = {
    id?: number
    createdAt?: Date | string
    blogTagId: number
  }

  export type BlogPostTagCreateOrConnectWithoutBlogPostInput = {
    where: BlogPostTagWhereUniqueInput
    create: XOR<BlogPostTagCreateWithoutBlogPostInput, BlogPostTagUncheckedCreateWithoutBlogPostInput>
  }

  export type BlogPostTagCreateManyBlogPostInputEnvelope = {
    data: BlogPostTagCreateManyBlogPostInput | BlogPostTagCreateManyBlogPostInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutBlogPostsInput = {
    update: XOR<CategoryUpdateWithoutBlogPostsInput, CategoryUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<CategoryCreateWithoutBlogPostsInput, CategoryUncheckedCreateWithoutBlogPostsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutBlogPostsInput, CategoryUncheckedUpdateWithoutBlogPostsInput>
  }

  export type CategoryUpdateWithoutBlogPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CategoryUncheckedUpdateWithoutBlogPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUpsertWithoutBlogPostsInput = {
    update: XOR<SeriesUpdateWithoutBlogPostsInput, SeriesUncheckedUpdateWithoutBlogPostsInput>
    create: XOR<SeriesCreateWithoutBlogPostsInput, SeriesUncheckedCreateWithoutBlogPostsInput>
    where?: SeriesWhereInput
  }

  export type SeriesUpdateToOneWithWhereWithoutBlogPostsInput = {
    where?: SeriesWhereInput
    data: XOR<SeriesUpdateWithoutBlogPostsInput, SeriesUncheckedUpdateWithoutBlogPostsInput>
  }

  export type SeriesUpdateWithoutBlogPostsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalParts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SeriesUncheckedUpdateWithoutBlogPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalParts?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentBlockUpsertWithWhereUniqueWithoutBlogPostInput = {
    where: ContentBlockWhereUniqueInput
    update: XOR<ContentBlockUpdateWithoutBlogPostInput, ContentBlockUncheckedUpdateWithoutBlogPostInput>
    create: XOR<ContentBlockCreateWithoutBlogPostInput, ContentBlockUncheckedCreateWithoutBlogPostInput>
  }

  export type ContentBlockUpdateWithWhereUniqueWithoutBlogPostInput = {
    where: ContentBlockWhereUniqueInput
    data: XOR<ContentBlockUpdateWithoutBlogPostInput, ContentBlockUncheckedUpdateWithoutBlogPostInput>
  }

  export type ContentBlockUpdateManyWithWhereWithoutBlogPostInput = {
    where: ContentBlockScalarWhereInput
    data: XOR<ContentBlockUpdateManyMutationInput, ContentBlockUncheckedUpdateManyWithoutBlogPostInput>
  }

  export type ContentBlockScalarWhereInput = {
    AND?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
    OR?: ContentBlockScalarWhereInput[]
    NOT?: ContentBlockScalarWhereInput | ContentBlockScalarWhereInput[]
    id?: IntFilter<"ContentBlock"> | number
    type?: EnumContentBlockTypeFilter<"ContentBlock"> | $Enums.ContentBlockType
    order?: FloatFilter<"ContentBlock"> | number
    content?: StringFilter<"ContentBlock"> | string
    createdAt?: DateTimeFilter<"ContentBlock"> | Date | string
    updatedAt?: DateTimeFilter<"ContentBlock"> | Date | string
    level?: IntNullableFilter<"ContentBlock"> | number | null
    language?: StringNullableFilter<"ContentBlock"> | string | null
    codeTitle?: StringNullableFilter<"ContentBlock"> | string | null
    imageUrl?: StringNullableFilter<"ContentBlock"> | string | null
    imageAlt?: StringNullableFilter<"ContentBlock"> | string | null
    imageCaption?: StringNullableFilter<"ContentBlock"> | string | null
    imageAlignment?: StringNullableFilter<"ContentBlock"> | string | null
    calloutVariant?: EnumCalloutVariantNullableFilter<"ContentBlock"> | $Enums.CalloutVariant | null
    calloutTitle?: StringNullableFilter<"ContentBlock"> | string | null
    quoteAuthor?: StringNullableFilter<"ContentBlock"> | string | null
    listStyle?: EnumListStyleNullableFilter<"ContentBlock"> | $Enums.ListStyle | null
    listItems?: JsonNullableFilter<"ContentBlock">
    videoType?: EnumVideoTypeNullableFilter<"ContentBlock"> | $Enums.VideoType | null
    videoId?: StringNullableFilter<"ContentBlock"> | string | null
    videoTitle?: StringNullableFilter<"ContentBlock"> | string | null
    paragraphStyle?: StringNullableFilter<"ContentBlock"> | string | null
    blogPostId?: IntFilter<"ContentBlock"> | number
  }

  export type BlogPostTagUpsertWithWhereUniqueWithoutBlogPostInput = {
    where: BlogPostTagWhereUniqueInput
    update: XOR<BlogPostTagUpdateWithoutBlogPostInput, BlogPostTagUncheckedUpdateWithoutBlogPostInput>
    create: XOR<BlogPostTagCreateWithoutBlogPostInput, BlogPostTagUncheckedCreateWithoutBlogPostInput>
  }

  export type BlogPostTagUpdateWithWhereUniqueWithoutBlogPostInput = {
    where: BlogPostTagWhereUniqueInput
    data: XOR<BlogPostTagUpdateWithoutBlogPostInput, BlogPostTagUncheckedUpdateWithoutBlogPostInput>
  }

  export type BlogPostTagUpdateManyWithWhereWithoutBlogPostInput = {
    where: BlogPostTagScalarWhereInput
    data: XOR<BlogPostTagUpdateManyMutationInput, BlogPostTagUncheckedUpdateManyWithoutBlogPostInput>
  }

  export type BlogPostTagScalarWhereInput = {
    AND?: BlogPostTagScalarWhereInput | BlogPostTagScalarWhereInput[]
    OR?: BlogPostTagScalarWhereInput[]
    NOT?: BlogPostTagScalarWhereInput | BlogPostTagScalarWhereInput[]
    id?: IntFilter<"BlogPostTag"> | number
    createdAt?: DateTimeFilter<"BlogPostTag"> | Date | string
    blogPostId?: IntFilter<"BlogPostTag"> | number
    blogTagId?: IntFilter<"BlogPostTag"> | number
  }

  export type BlogPostCreateWithoutCategoryInput = {
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesPart?: number | null
    series?: SeriesCreateNestedOneWithoutBlogPostsInput
    contentBlocks?: ContentBlockCreateNestedManyWithoutBlogPostInput
    blogPostTags?: BlogPostTagCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutCategoryInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesId?: number | null
    seriesPart?: number | null
    contentBlocks?: ContentBlockUncheckedCreateNestedManyWithoutBlogPostInput
    blogPostTags?: BlogPostTagUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostCreateManyCategoryInputEnvelope = {
    data: BlogPostCreateManyCategoryInput | BlogPostCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
    create: XOR<BlogPostCreateWithoutCategoryInput, BlogPostUncheckedCreateWithoutCategoryInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutCategoryInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutCategoryInput, BlogPostUncheckedUpdateWithoutCategoryInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutCategoryInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BlogPostScalarWhereInput = {
    AND?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    OR?: BlogPostScalarWhereInput[]
    NOT?: BlogPostScalarWhereInput | BlogPostScalarWhereInput[]
    id?: IntFilter<"BlogPost"> | number
    slug?: StringFilter<"BlogPost"> | string
    title?: StringFilter<"BlogPost"> | string
    subtitle?: StringNullableFilter<"BlogPost"> | string | null
    excerpt?: StringFilter<"BlogPost"> | string
    metaDescription?: StringFilter<"BlogPost"> | string
    socialImage?: StringNullableFilter<"BlogPost"> | string | null
    readTime?: IntFilter<"BlogPost"> | number
    wordCount?: IntFilter<"BlogPost"> | number
    views?: IntFilter<"BlogPost"> | number
    heroImage?: StringNullableFilter<"BlogPost"> | string | null
    heroImageAlt?: StringNullableFilter<"BlogPost"> | string | null
    heroImageCaption?: StringNullableFilter<"BlogPost"> | string | null
    publishedAt?: DateTimeNullableFilter<"BlogPost"> | Date | string | null
    createdAt?: DateTimeFilter<"BlogPost"> | Date | string
    updatedAt?: DateTimeFilter<"BlogPost"> | Date | string
    author?: JsonFilter<"BlogPost">
    categoryId?: IntNullableFilter<"BlogPost"> | number | null
    seriesId?: IntNullableFilter<"BlogPost"> | number | null
    seriesPart?: IntNullableFilter<"BlogPost"> | number | null
  }

  export type BlogPostCreateWithoutSeriesInput = {
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesPart?: number | null
    category?: CategoryCreateNestedOneWithoutBlogPostsInput
    contentBlocks?: ContentBlockCreateNestedManyWithoutBlogPostInput
    blogPostTags?: BlogPostTagCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutSeriesInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    categoryId?: number | null
    seriesPart?: number | null
    contentBlocks?: ContentBlockUncheckedCreateNestedManyWithoutBlogPostInput
    blogPostTags?: BlogPostTagUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutSeriesInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutSeriesInput, BlogPostUncheckedCreateWithoutSeriesInput>
  }

  export type BlogPostCreateManySeriesInputEnvelope = {
    data: BlogPostCreateManySeriesInput | BlogPostCreateManySeriesInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostUpsertWithWhereUniqueWithoutSeriesInput = {
    where: BlogPostWhereUniqueInput
    update: XOR<BlogPostUpdateWithoutSeriesInput, BlogPostUncheckedUpdateWithoutSeriesInput>
    create: XOR<BlogPostCreateWithoutSeriesInput, BlogPostUncheckedCreateWithoutSeriesInput>
  }

  export type BlogPostUpdateWithWhereUniqueWithoutSeriesInput = {
    where: BlogPostWhereUniqueInput
    data: XOR<BlogPostUpdateWithoutSeriesInput, BlogPostUncheckedUpdateWithoutSeriesInput>
  }

  export type BlogPostUpdateManyWithWhereWithoutSeriesInput = {
    where: BlogPostScalarWhereInput
    data: XOR<BlogPostUpdateManyMutationInput, BlogPostUncheckedUpdateManyWithoutSeriesInput>
  }

  export type BlogPostCreateWithoutContentBlocksInput = {
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesPart?: number | null
    category?: CategoryCreateNestedOneWithoutBlogPostsInput
    series?: SeriesCreateNestedOneWithoutBlogPostsInput
    blogPostTags?: BlogPostTagCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutContentBlocksInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    categoryId?: number | null
    seriesId?: number | null
    seriesPart?: number | null
    blogPostTags?: BlogPostTagUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutContentBlocksInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutContentBlocksInput, BlogPostUncheckedCreateWithoutContentBlocksInput>
  }

  export type BlogPostUpsertWithoutContentBlocksInput = {
    update: XOR<BlogPostUpdateWithoutContentBlocksInput, BlogPostUncheckedUpdateWithoutContentBlocksInput>
    create: XOR<BlogPostCreateWithoutContentBlocksInput, BlogPostUncheckedCreateWithoutContentBlocksInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutContentBlocksInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutContentBlocksInput, BlogPostUncheckedUpdateWithoutContentBlocksInput>
  }

  export type BlogPostUpdateWithoutContentBlocksInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutBlogPostsNestedInput
    series?: SeriesUpdateOneWithoutBlogPostsNestedInput
    blogPostTags?: BlogPostTagUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutContentBlocksInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    blogPostTags?: BlogPostTagUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostTagCreateWithoutBlogTagInput = {
    createdAt?: Date | string
    blogPost: BlogPostCreateNestedOneWithoutBlogPostTagsInput
  }

  export type BlogPostTagUncheckedCreateWithoutBlogTagInput = {
    id?: number
    createdAt?: Date | string
    blogPostId: number
  }

  export type BlogPostTagCreateOrConnectWithoutBlogTagInput = {
    where: BlogPostTagWhereUniqueInput
    create: XOR<BlogPostTagCreateWithoutBlogTagInput, BlogPostTagUncheckedCreateWithoutBlogTagInput>
  }

  export type BlogPostTagCreateManyBlogTagInputEnvelope = {
    data: BlogPostTagCreateManyBlogTagInput | BlogPostTagCreateManyBlogTagInput[]
    skipDuplicates?: boolean
  }

  export type BlogPostTagUpsertWithWhereUniqueWithoutBlogTagInput = {
    where: BlogPostTagWhereUniqueInput
    update: XOR<BlogPostTagUpdateWithoutBlogTagInput, BlogPostTagUncheckedUpdateWithoutBlogTagInput>
    create: XOR<BlogPostTagCreateWithoutBlogTagInput, BlogPostTagUncheckedCreateWithoutBlogTagInput>
  }

  export type BlogPostTagUpdateWithWhereUniqueWithoutBlogTagInput = {
    where: BlogPostTagWhereUniqueInput
    data: XOR<BlogPostTagUpdateWithoutBlogTagInput, BlogPostTagUncheckedUpdateWithoutBlogTagInput>
  }

  export type BlogPostTagUpdateManyWithWhereWithoutBlogTagInput = {
    where: BlogPostTagScalarWhereInput
    data: XOR<BlogPostTagUpdateManyMutationInput, BlogPostTagUncheckedUpdateManyWithoutBlogTagInput>
  }

  export type BlogPostCreateWithoutBlogPostTagsInput = {
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesPart?: number | null
    category?: CategoryCreateNestedOneWithoutBlogPostsInput
    series?: SeriesCreateNestedOneWithoutBlogPostsInput
    contentBlocks?: ContentBlockCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostUncheckedCreateWithoutBlogPostTagsInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    categoryId?: number | null
    seriesId?: number | null
    seriesPart?: number | null
    contentBlocks?: ContentBlockUncheckedCreateNestedManyWithoutBlogPostInput
  }

  export type BlogPostCreateOrConnectWithoutBlogPostTagsInput = {
    where: BlogPostWhereUniqueInput
    create: XOR<BlogPostCreateWithoutBlogPostTagsInput, BlogPostUncheckedCreateWithoutBlogPostTagsInput>
  }

  export type BlogTagCreateWithoutBlogPostTagsInput = {
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTagUncheckedCreateWithoutBlogPostTagsInput = {
    id?: number
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BlogTagCreateOrConnectWithoutBlogPostTagsInput = {
    where: BlogTagWhereUniqueInput
    create: XOR<BlogTagCreateWithoutBlogPostTagsInput, BlogTagUncheckedCreateWithoutBlogPostTagsInput>
  }

  export type BlogPostUpsertWithoutBlogPostTagsInput = {
    update: XOR<BlogPostUpdateWithoutBlogPostTagsInput, BlogPostUncheckedUpdateWithoutBlogPostTagsInput>
    create: XOR<BlogPostCreateWithoutBlogPostTagsInput, BlogPostUncheckedCreateWithoutBlogPostTagsInput>
    where?: BlogPostWhereInput
  }

  export type BlogPostUpdateToOneWithWhereWithoutBlogPostTagsInput = {
    where?: BlogPostWhereInput
    data: XOR<BlogPostUpdateWithoutBlogPostTagsInput, BlogPostUncheckedUpdateWithoutBlogPostTagsInput>
  }

  export type BlogPostUpdateWithoutBlogPostTagsInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutBlogPostsNestedInput
    series?: SeriesUpdateOneWithoutBlogPostsNestedInput
    contentBlocks?: ContentBlockUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutBlogPostTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    contentBlocks?: ContentBlockUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogTagUpsertWithoutBlogPostTagsInput = {
    update: XOR<BlogTagUpdateWithoutBlogPostTagsInput, BlogTagUncheckedUpdateWithoutBlogPostTagsInput>
    create: XOR<BlogTagCreateWithoutBlogPostTagsInput, BlogTagUncheckedCreateWithoutBlogPostTagsInput>
    where?: BlogTagWhereInput
  }

  export type BlogTagUpdateToOneWithWhereWithoutBlogPostTagsInput = {
    where?: BlogTagWhereInput
    data: XOR<BlogTagUpdateWithoutBlogPostTagsInput, BlogTagUncheckedUpdateWithoutBlogPostTagsInput>
  }

  export type BlogTagUpdateWithoutBlogPostTagsInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlogTagUncheckedUpdateWithoutBlogPostTagsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenshotCreateManyProjectInput = {
    id?: number
    url: string
    description: string
    order?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TechnologyCreateManyProjectInput = {
    id?: number
    name: string
    reason: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectTagCreateManyProjectInput = {
    id?: number
    createdAt?: Date | string
    tagId: number
  }

  export type LessonCreateManyProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BusinessOutcomeCreateManyProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ImprovementCreateManyProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NextStepCreateManyProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FutureToolCreateManyProjectInput = {
    id?: number
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PerformanceMetricCreateManyProjectInput = {
    id?: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScreenshotUpdateWithoutProjectInput = {
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenshotUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScreenshotUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnologyUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnologyUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TechnologyUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    reason?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagUpdateWithoutProjectInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutProjectTagsNestedInput
  }

  export type ProjectTagUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tagId?: IntFieldUpdateOperationsInput | number
  }

  export type LessonUpdateWithoutProjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessOutcomeUpdateWithoutProjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessOutcomeUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BusinessOutcomeUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImprovementUpdateWithoutProjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImprovementUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImprovementUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NextStepUpdateWithoutProjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NextStepUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NextStepUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FutureToolUpdateWithoutProjectInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FutureToolUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FutureToolUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUpdateWithoutProjectInput = {
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PerformanceMetricUncheckedUpdateManyWithoutProjectInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectTagCreateManyTagInput = {
    id?: number
    createdAt?: Date | string
    projectId: number
  }

  export type ProjectTagUpdateWithoutTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutProjectTagsNestedInput
  }

  export type ProjectTagUncheckedUpdateWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ProjectTagUncheckedUpdateManyWithoutTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    projectId?: IntFieldUpdateOperationsInput | number
  }

  export type ContentBlockCreateManyBlogPostInput = {
    id?: number
    type: $Enums.ContentBlockType
    order: number
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    level?: number | null
    language?: string | null
    codeTitle?: string | null
    imageUrl?: string | null
    imageAlt?: string | null
    imageCaption?: string | null
    imageAlignment?: string | null
    calloutVariant?: $Enums.CalloutVariant | null
    calloutTitle?: string | null
    quoteAuthor?: string | null
    listStyle?: $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: $Enums.VideoType | null
    videoId?: string | null
    videoTitle?: string | null
    paragraphStyle?: string | null
  }

  export type BlogPostTagCreateManyBlogPostInput = {
    id?: number
    createdAt?: Date | string
    blogTagId: number
  }

  export type ContentBlockUpdateWithoutBlogPostInput = {
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentBlockUncheckedUpdateWithoutBlogPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ContentBlockUncheckedUpdateManyWithoutBlogPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: EnumContentBlockTypeFieldUpdateOperationsInput | $Enums.ContentBlockType
    order?: FloatFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    level?: NullableIntFieldUpdateOperationsInput | number | null
    language?: NullableStringFieldUpdateOperationsInput | string | null
    codeTitle?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    imageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    imageAlignment?: NullableStringFieldUpdateOperationsInput | string | null
    calloutVariant?: NullableEnumCalloutVariantFieldUpdateOperationsInput | $Enums.CalloutVariant | null
    calloutTitle?: NullableStringFieldUpdateOperationsInput | string | null
    quoteAuthor?: NullableStringFieldUpdateOperationsInput | string | null
    listStyle?: NullableEnumListStyleFieldUpdateOperationsInput | $Enums.ListStyle | null
    listItems?: NullableJsonNullValueInput | InputJsonValue
    videoType?: NullableEnumVideoTypeFieldUpdateOperationsInput | $Enums.VideoType | null
    videoId?: NullableStringFieldUpdateOperationsInput | string | null
    videoTitle?: NullableStringFieldUpdateOperationsInput | string | null
    paragraphStyle?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BlogPostTagUpdateWithoutBlogPostInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogTag?: BlogTagUpdateOneRequiredWithoutBlogPostTagsNestedInput
  }

  export type BlogPostTagUncheckedUpdateWithoutBlogPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogTagId?: IntFieldUpdateOperationsInput | number
  }

  export type BlogPostTagUncheckedUpdateManyWithoutBlogPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogTagId?: IntFieldUpdateOperationsInput | number
  }

  export type BlogPostCreateManyCategoryInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    seriesId?: number | null
    seriesPart?: number | null
  }

  export type BlogPostUpdateWithoutCategoryInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    series?: SeriesUpdateOneWithoutBlogPostsNestedInput
    contentBlocks?: ContentBlockUpdateManyWithoutBlogPostNestedInput
    blogPostTags?: BlogPostTagUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    contentBlocks?: ContentBlockUncheckedUpdateManyWithoutBlogPostNestedInput
    blogPostTags?: BlogPostTagUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogPostCreateManySeriesInput = {
    id?: number
    slug: string
    title: string
    subtitle?: string | null
    excerpt: string
    metaDescription: string
    socialImage?: string | null
    readTime: number
    wordCount?: number
    views?: number
    heroImage?: string | null
    heroImageAlt?: string | null
    heroImageCaption?: string | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author: JsonNullValueInput | InputJsonValue
    categoryId?: number | null
    seriesPart?: number | null
  }

  export type BlogPostUpdateWithoutSeriesInput = {
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    category?: CategoryUpdateOneWithoutBlogPostsNestedInput
    contentBlocks?: ContentBlockUpdateManyWithoutBlogPostNestedInput
    blogPostTags?: BlogPostTagUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
    contentBlocks?: ContentBlockUncheckedUpdateManyWithoutBlogPostNestedInput
    blogPostTags?: BlogPostTagUncheckedUpdateManyWithoutBlogPostNestedInput
  }

  export type BlogPostUncheckedUpdateManyWithoutSeriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    slug?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    subtitle?: NullableStringFieldUpdateOperationsInput | string | null
    excerpt?: StringFieldUpdateOperationsInput | string
    metaDescription?: StringFieldUpdateOperationsInput | string
    socialImage?: NullableStringFieldUpdateOperationsInput | string | null
    readTime?: IntFieldUpdateOperationsInput | number
    wordCount?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    heroImage?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageAlt?: NullableStringFieldUpdateOperationsInput | string | null
    heroImageCaption?: NullableStringFieldUpdateOperationsInput | string | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: JsonNullValueInput | InputJsonValue
    categoryId?: NullableIntFieldUpdateOperationsInput | number | null
    seriesPart?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type BlogPostTagCreateManyBlogTagInput = {
    id?: number
    createdAt?: Date | string
    blogPostId: number
  }

  export type BlogPostTagUpdateWithoutBlogTagInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPost?: BlogPostUpdateOneRequiredWithoutBlogPostTagsNestedInput
  }

  export type BlogPostTagUncheckedUpdateWithoutBlogTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPostId?: IntFieldUpdateOperationsInput | number
  }

  export type BlogPostTagUncheckedUpdateManyWithoutBlogTagInput = {
    id?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    blogPostId?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}